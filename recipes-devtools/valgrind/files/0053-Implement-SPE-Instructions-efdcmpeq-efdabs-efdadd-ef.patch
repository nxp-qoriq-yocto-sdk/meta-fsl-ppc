From 9eb04d0b1c7f951fb1b1ca2a95a64ed07d29ed9c Mon Sep 17 00:00:00 2001
From: Anmol P. Paralkar <anmol@freescale.com>
Date: Fri, 19 Apr 2013 13:23:23 -0700
Subject: [PATCH 53/65] Implement SPE Instructions: { efdcmpeq, efdabs, efdadd, efdsub, efdcfs, efdcfsf, efdcfsi, efdcfuf, efdcfui }.

---
 FSL-SPE-README.txt                       |   13 +-
 VEX/priv/guest_ppc_defs.h                |   22 ++
 VEX/priv/guest_ppc_helpers.c             |  108 ++++++++++
 VEX/priv/guest_ppc_toIR.c                |  237 +++++++++++++++++++++
 memcheck/tests/ppc32/test_spe.c          |  332 ++++++++++++++++++++++++++++++
 memcheck/tests/ppc32/test_spe.h          |    4 +-
 memcheck/tests/ppc32/test_spe.stderr.exp |   24 +-
 memcheck/tests/ppc32/test_spe.stdout.exp |   13 ++
 regtest-power7-64.default-build.log      |   46 ++--
 regtest-power7-64.log                    |   48 +++---
 10 files changed, 783 insertions(+), 64 deletions(-)

diff --git a/FSL-SPE-README.txt b/FSL-SPE-README.txt
index e5d2e27..02a37f4 100644
--- a/FSL-SPE-README.txt
+++ b/FSL-SPE-README.txt
@@ -75,7 +75,8 @@
 
  New instructions implemented since last release:
 
- mfspefscr, mtspefscr,
+ mfspefscr, mtspefscr, efdcmpeq, efdabs, efdadd, efdsub, efdcfs, efdcfsf, efdcfsi,
+ efdcfuf, efdcfui,
 
  Note: Synthetic instructions appear prefixed with a leading underscore in the
        above list. All synthetic instructions are tested as working under
@@ -87,10 +88,9 @@
 
  Note: Non SPE instructions are indicated by suffixing them with a '?' sign.
 
- eciwx?, ecowx?, efdabs, efdadd, efdcfs, efdcfsf, efdcfsi, efdcfsid, efdcfuf,
- efdcfui, efdcfuid, efdcmpeq, efdcmpgt, efdcmplt, efdctsf, efdctsi, efdctsidz,
+ eciwx?, ecowx?, efdcmpgt, efdcmplt, efdctsf, efdctsi, efdctsidz,
  efdctsiz, efdctuf, efdctui, efdctuidz, efdctuiz, efddiv, efdmul, efdnabs,
- efdneg, efdsub, efdtsteq, efdtstgt, efdtstlt, efsabs, efsadd, efscfd, efscfsf,
+ efdneg, efdtsteq, efdtstgt, efdtstlt, efsabs, efsadd, efscfd, efscfsf,
  efscfsi, efscfuf, efscfui, efscmpeq, efscmpgt, efscmplt, efsctsf, efsctsi,
  efsctsiz, efsctuf, efsctui, efsctuiz, efsdiv, efsmul, efsnabs, efsneg, efssub,
  efststeq, efststgt, efststlt, ehpriv?, eqv?, eqv.?, evfsabs, evfsadd,
@@ -104,6 +104,11 @@
  evmwlusiaaw, evmwlusianw, evmwssf, evmwssfa, evmwssfaa, evmwssfan,
  evsubfssiaaw, evsubfusiaaw, extsb?, extsb.?, extsh?, extsh.?
 
+ The following instructions may only be implemented for 64-bit implementations,
+ and are hence out of scope for this porting effort:
+
+ efdcfsid, efdcfuid,
+
  Simple UNIX Utilities running under Valgrind on a p1022ds Linux system
  ----------------------------------------------------------------------
 
diff --git a/VEX/priv/guest_ppc_defs.h b/VEX/priv/guest_ppc_defs.h
index 217f73e..cb79b14 100644
--- a/VEX/priv/guest_ppc_defs.h
+++ b/VEX/priv/guest_ppc_defs.h
@@ -288,6 +288,28 @@ extern void spe_dirtyhelper_mfspefscr ( VexGuestPPC32State* gst,
 extern void spe_dirtyhelper_mtspefscr ( VexGuestPPC32State* gst,
                                         UInt rD_off );
 
+#define SPE_DIRTY_HELPER_DECL_crfDrArB(insn) \
+extern UInt spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt rA_off, UInt rB_off );
+
+#define SPE_DIRTY_HELPER_DECL_rDrArB(insn) \
+extern void spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt rD_off, UInt rA_off, UInt rB_off );
+
+#define SPE_DIRTY_HELPER_DECL_rDrA(insn) \
+extern void spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt rD_off, UInt rA_off )
+
+#define SPE_DIRTY_HELPER_DECL_rDrB(insn) \
+extern void spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt rD_off, UInt rB_off )
+
+SPE_DIRTY_HELPER_DECL_crfDrArB(efdcmpeq);
+SPE_DIRTY_HELPER_DECL_rDrA(efdabs);
+SPE_DIRTY_HELPER_DECL_rDrArB(efdadd);
+SPE_DIRTY_HELPER_DECL_rDrArB(efdsub);
+SPE_DIRTY_HELPER_DECL_rDrB(efdcfs);
+SPE_DIRTY_HELPER_DECL_rDrB(efdcfsf);
+SPE_DIRTY_HELPER_DECL_rDrB(efdcfsi);
+SPE_DIRTY_HELPER_DECL_rDrB(efdcfuf);
+SPE_DIRTY_HELPER_DECL_rDrB(efdcfui);
+
 #endif /* ndef __VEX_GUEST_PPC_DEFS_H */
 
 /*---------------------------------------------------------------*/
diff --git a/VEX/priv/guest_ppc_helpers.c b/VEX/priv/guest_ppc_helpers.c
index 6be07a5..a494653 100644
--- a/VEX/priv/guest_ppc_helpers.c
+++ b/VEX/priv/guest_ppc_helpers.c
@@ -1429,6 +1429,114 @@ void spe_dirtyhelper_mtspefscr ( VexGuestPPC32State* gst,
   return;
 }
 
+/* CALLED FROM GENERATED CODE */
+/* DIRTY HELPER (reads guest state, writes guest state) */
+#ifdef __SPE__
+#define SPE_DIRTY_HELPER_DEFN_crfDrArB(insn, rA_type, rB_type)                    \
+UInt spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt rA_off, UInt rB_off ) \
+{                                                                                 \
+  register rA_type      rA asm ("29");                                            \
+  register rB_type      rB asm ("28");                                            \
+  register unsigned int CR asm ("27");                                            \
+                                                                                  \
+  vassert(rA_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));               \
+  vassert(rB_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));               \
+                                                                                  \
+  /* Read rA, rB from the Guest State: */                                         \
+  rA = *((rA_type *) ((UChar *) gst + rA_off));                                   \
+  rB = *((rB_type *) ((UChar *) gst + rB_off));                                   \
+                                                                                  \
+  /* (Use CR7 for the result of the comparison). */                               \
+  asm volatile (#insn " 7, %[a], %[b]" : : [a] "r" (rA), [b] "r" (rB));           \
+                                                                                  \
+  /* Get hard reg CR into the variable CR: */                                     \
+  asm volatile ("mfcr %[cr]" : [cr] "=r" (CR));                                   \
+                                                                                  \
+  /* From CR7, extract and return just that one bit holding the result. */        \
+  return ((CR & 0xf) >> 2) & 0x1;                                                 \
+}
+#else
+#define SPE_DIRTY_HELPER_DEFN_crfDrArB(insn, rA_type, rB_type)                    \
+UInt spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt rA_off, UInt rB_off ) \
+{                                                                                 \
+  return 0;                                                                       \
+}
+#endif // __SPE__
+
+/* CALLED FROM GENERATED CODE */
+/* DIRTY HELPER (reads guest state, writes guest state) */
+#ifdef __SPE__
+#define SPE_DIRTY_HELPER_DEFN_rDrArB(insn, rD_type, rA_type, rB_type)                          \
+void spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt rD_off, UInt rA_off, UInt rB_off ) \
+{                                                                                              \
+  register rD_type rD asm ("29");                                                              \
+  register rA_type rA asm ("28");                                                              \
+  register rB_type rB asm ("27");                                                              \
+                                                                                               \
+  vassert(rD_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));                            \
+  vassert(rA_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));                            \
+  vassert(rB_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));                            \
+                                                                                               \
+  /* Read rA, rB from the Guest State: */                                                      \
+  rA = *((rA_type *) ((UChar *) gst + rA_off));                                                \
+  rB = *((rB_type *) ((UChar *) gst + rB_off));                                                \
+                                                                                               \
+  asm volatile (#insn " %[d], %[a], %[b]" : [d] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));       \
+                                                                                               \
+  /* Write rD to the Guest State: */                                                           \
+  *((rD_type *) ((UChar *) gst + rD_off)) = rD;                                                \
+  return;                                                                                      \
+}
+#else
+#define SPE_DIRTY_HELPER_DEFN_rDrArB(insn, rD_type, rA_type, rB_type)                          \
+void spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt rD_off, UInt rA_off, UInt rB_off ) \
+{                                                                                              \
+  return;                                                                                      \
+}
+#endif // __SPE__
+
+/* CALLED FROM GENERATED CODE */
+/* DIRTY HELPER (reads guest state, writes guest state) */
+#ifdef __SPE__
+#define SPE_DIRTY_HELPER_DEFN_rDrB(insn, rD_type, rB_type)                        \
+void spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt rD_off, UInt rB_off ) \
+{                                                                                 \
+  register rD_type rD asm ("30");                                                 \
+  register rB_type rB asm ("29");                                                 \
+                                                                                  \
+  vassert(rD_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));               \
+  vassert(rB_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));               \
+                                                                                  \
+  /* Read rB from the Guest State: */                                             \
+  rB = *((rB_type*) ((UChar *) gst + rB_off));                                    \
+                                                                                  \
+  asm volatile (#insn " %[d], %[b]" : [d] "=r" (rD) : [b] "r" (rB));              \
+                                                                                  \
+  /* Write rD to the Guest State: */                                              \
+  *((rD_type *) ((UChar *) gst + rD_off)) = rD;                                   \
+  return;                                                                         \
+}
+#else
+#define SPE_DIRTY_HELPER_DEFN_rDrB(insn, rD_type, rB_type)                        \
+void spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt rD_off, UInt rB_off ) \
+{                                                                                 \
+  return;                                                                         \
+}
+#endif // __SPE__
+
+#define SPE_DIRTY_HELPER_DEFN_rDrA(insn, rD_type, rA_type) \
+        SPE_DIRTY_HELPER_DEFN_rDrB(insn, rD_type, rA_type)
+
+SPE_DIRTY_HELPER_DEFN_crfDrArB(efdcmpeq, double, double)
+SPE_DIRTY_HELPER_DEFN_rDrA(efdabs, double, double)
+SPE_DIRTY_HELPER_DEFN_rDrArB(efdadd, double, double, double)
+SPE_DIRTY_HELPER_DEFN_rDrArB(efdsub, double, double, double)
+SPE_DIRTY_HELPER_DEFN_rDrB(efdcfs, double, double)
+SPE_DIRTY_HELPER_DEFN_rDrB(efdcfsf, double, __ev64_u32__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efdcfsi, double, __ev64_s32__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efdcfuf, double, __ev64_u64__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efdcfui, double, __ev64_u32__)
+
 /*----------------------------------------------*/
 /*--- The exported fns ..                    ---*/
 /*----------------------------------------------*/
diff --git a/VEX/priv/guest_ppc_toIR.c b/VEX/priv/guest_ppc_toIR.c
index b395826..475a454 100644
--- a/VEX/priv/guest_ppc_toIR.c
+++ b/VEX/priv/guest_ppc_toIR.c
@@ -15031,6 +15031,231 @@ static Bool dis_spe_ACC_based_fractional_multiply_insns ( UInt theInstr )
   }
   return True;
 }
+
+#define PREPARE_DIRTY_HELPER_CALL_rDrArB(insn)                \
+     args = mkIRExprVec_3 ( mkU32( rD_off ),                  \
+                            mkU32( rA_off ),                  \
+                            mkU32( rB_off ) );                \
+     d = unsafeIRDirty_0_N (0 /* regparms */,                 \
+                            "spe_dirtyhelper_" #insn,         \
+                            &spe_dirtyhelper_##insn,          \
+                            args);                            \
+     DIP( #insn " r%d, r%d\n", rD_addr, rA_addr, rB_addr );   \
+     /* declare guest state effects */                        \
+     d->needsBBP = True;                                      \
+     d->nFxState = 3;                                         \
+     vex_bzero(&d->fxState, sizeof(d->fxState));              \
+     d->fxState[0].fx     = Ifx_Write;                        \
+     d->fxState[0].offset = rD_off;                           \
+     d->fxState[0].size   = sizeof(ULong);                    \
+     d->fxState[1].fx     = Ifx_Read;                         \
+     d->fxState[1].offset = rA_off;                           \
+     d->fxState[1].size   = sizeof(ULong);                    \
+     d->fxState[2].fx     = Ifx_Read;                         \
+     d->fxState[2].offset = rB_off;                           \
+     d->fxState[2].size   = sizeof(ULong);                    \
+                                                              \
+     /* execute the dirty call, side-effecting guest state */ \
+     stmt( IRStmt_Dirty(d) );
+
+#define PREPARE_DIRTY_HELPER_CALL_crfDrArB(insn)                        \
+     args = mkIRExprVec_2 ( mkU32( rA_off ),                            \
+                            mkU32( rB_off ) );                          \
+     d = unsafeIRDirty_1_N (val,                                        \
+                            0 /* regparms */,                           \
+                            "spe_dirtyhelper_" #insn,                   \
+                            &spe_dirtyhelper_##insn,                    \
+                            args);                                      \
+     DIP( #insn " CR%d, r%d, r%d\n", CR_field, rA_addr, rB_addr );      \
+     /* declare guest state effects */                                  \
+     d->needsBBP = True;                                                \
+     d->nFxState = 2;                                                   \
+     vex_bzero(&d->fxState, sizeof(d->fxState));                        \
+     d->fxState[0].fx     = Ifx_Read;                                   \
+     d->fxState[0].offset = rA_off;                                     \
+     d->fxState[0].size   = sizeof(ULong);                              \
+     d->fxState[1].fx     = Ifx_Read;                                   \
+     d->fxState[1].offset = rB_off;                                     \
+     d->fxState[1].size   = sizeof(ULong);                              \
+                                                                        \
+     /* execute the dirty call, side-effecting guest state */           \
+     stmt( IRStmt_Dirty(d) );                                           \
+     /* Update the CR in the guest state with the returned bit-value */ \
+     putCRbit ( CR_field * 4 + 1, mkexpr ( val ) );
+
+#define PREPARE_DIRTY_HELPER_CALL_rDrB(insn)                  \
+     args = mkIRExprVec_2 ( mkU32( rD_off ),                  \
+                            mkU32( rB_off ) );                \
+     d = unsafeIRDirty_0_N (0 /* regparms */,                 \
+                            "spe_dirtyhelper_" #insn,         \
+                            &spe_dirtyhelper_##insn,          \
+                            args);                            \
+     DIP( #insn " r%d, r%d\n", rD_addr, rB_addr );            \
+     /* declare guest state effects */                        \
+     d->needsBBP = True;                                      \
+     d->nFxState = 2;                                         \
+     vex_bzero(&d->fxState, sizeof(d->fxState));              \
+     d->fxState[0].fx     = Ifx_Write;                        \
+     d->fxState[0].offset = rD_off;                           \
+     d->fxState[0].size   = sizeof(ULong);                    \
+     d->fxState[1].fx     = Ifx_Read;                         \
+     d->fxState[1].offset = rB_off;                           \
+     d->fxState[1].size   = sizeof(ULong);                    \
+                                                              \
+     /* execute the dirty call, side-effecting guest state */ \
+     stmt( IRStmt_Dirty(d) );
+
+#define PREPARE_DIRTY_HELPER_CALL_rDrA(insn)                  \
+     args = mkIRExprVec_2 ( mkU32( rD_off ),                  \
+                            mkU32( rA_off ) );                \
+     d = unsafeIRDirty_0_N (0 /* regparms */,                 \
+                            "spe_dirtyhelper_" #insn,         \
+                            &spe_dirtyhelper_##insn,          \
+                            args);                            \
+     DIP( "efdabs r%d, r%d\n", rD_addr, rA_addr );            \
+     /* declare guest state effects */                        \
+     d->needsBBP = True;                                      \
+     d->nFxState = 2;                                         \
+     vex_bzero(&d->fxState, sizeof(d->fxState));              \
+     d->fxState[0].fx     = Ifx_Write;                        \
+     d->fxState[0].offset = rD_off;                           \
+     d->fxState[0].size   = sizeof(ULong);                    \
+     d->fxState[1].fx     = Ifx_Read;                         \
+     d->fxState[1].offset = rA_off;                           \
+     d->fxState[1].size   = sizeof(ULong);                    \
+                                                              \
+     /* execute the dirty call, side-effecting guest state */ \
+     stmt( IRStmt_Dirty(d) );
+
+static Bool dis_spe_fs ( UInt theInstr )
+{
+  /* EVX-Form */
+  UChar opc1    = evxOpcode( theInstr );
+  UInt  opc2    = evxXO( theInstr );
+  UChar rD_addr = evxRD( theInstr );
+  UChar rA_addr = evxRA( theInstr );
+  UChar rB_addr = evxRB( theInstr );
+  UChar uimm    = evxRB( theInstr );
+  Char  simm    = evxRA( theInstr );
+
+  UInt ACC_off = speACCRegOffset( );
+  UInt rD_off  = speGuestRegOffset( rD_addr );
+  UInt rA_off  = speGuestRegOffset( rA_addr );
+  UInt rB_off  = speGuestRegOffset( rB_addr );
+
+  IRDirty* d;
+  IRExpr** args;
+
+  if (opc1 != 0x4) {
+     vex_printf( "dis_spe_fs (ppc)(opc1 != 0x4)\n" );
+     return False;
+  }
+  switch (opc2) {
+  default:
+     return False;
+  }
+  return True;
+}
+
+static Bool dis_spe_fv ( UInt theInstr )
+{
+  /* EVX-Form */
+  UChar opc1    = evxOpcode( theInstr );
+  UInt  opc2    = evxXO( theInstr );
+  UChar rD_addr = evxRD( theInstr );
+  UChar rA_addr = evxRA( theInstr );
+  UChar rB_addr = evxRB( theInstr );
+  UChar uimm    = evxRB( theInstr );
+  Char  simm    = evxRA( theInstr );
+
+  UInt ACC_off = speACCRegOffset( );
+  UInt rD_off  = speGuestRegOffset( rD_addr );
+  UInt rA_off  = speGuestRegOffset( rA_addr );
+  UInt rB_off  = speGuestRegOffset( rB_addr );
+
+  IRDirty* d;
+  IRExpr** args;
+
+  if (opc1 != 0x4) {
+     vex_printf( "dis_spe_fv (ppc)(opc1 != 0x4)\n" );
+     return False;
+  }
+  switch (opc2) {
+  default:
+     return False;
+  }
+  return True;
+}
+
+static Bool dis_spe_fd ( UInt theInstr )
+{
+  /* EVX-Form */
+  UChar opc1     = evxOpcode( theInstr );
+  UInt  opc2     = evxXO( theInstr );
+  UChar CR_field = evxBF( theInstr );
+  UChar rD_addr  = evxRD( theInstr );
+  UChar rA_addr  = evxRA( theInstr );
+  UChar rB_addr  = evxRB( theInstr );
+  UChar uimm     = evxRB( theInstr );
+  Char  simm     = evxRA( theInstr );
+
+  UInt ACC_off = speACCRegOffset( );
+  UInt rD_off  = speGuestRegOffset( rD_addr );
+  UInt rA_off  = speGuestRegOffset( rA_addr );
+  UInt rB_off  = speGuestRegOffset( rB_addr );
+  UInt CRf_off;
+
+  IRDirty* d;
+  IRExpr** args;
+  IRTemp   val = newTemp(Ity_I32);
+
+  if (opc1 != 0x4) {
+     vex_printf( "dis_spe_fd (ppc)(opc1 != 0x4)\n" );
+     return False;
+  }
+  switch (opc2) {
+  case 0x2e0:
+     // efdadd (Floating-Point Double-Precision Add, SPEPEM p5-18)
+     PREPARE_DIRTY_HELPER_CALL_rDrArB(efdadd);
+  break;
+  case 0x2e1:
+     // efdsub (Floating-Point Double-Precision Subtract, SPEPEM p5-41)
+     PREPARE_DIRTY_HELPER_CALL_rDrArB(efdsub);
+  break;
+  case 0x2e4:
+     // efdabs (Floating-Point Double-Precision Absolute Value, SPEPEM p5-17)
+     PREPARE_DIRTY_HELPER_CALL_rDrA(efdabs);
+  break;
+  case 0x2ee:
+     // efdcmpeq (Floating-Point Double-Precision Compare Equal, SPEPEM p5-26)
+     PREPARE_DIRTY_HELPER_CALL_crfDrArB(efdcmpeq);
+  break;
+  case 0x2ef:
+     // efdcfs (Floating-Point Double-Precision Convert from Single-Precision, SPEPEM p5-19)
+     PREPARE_DIRTY_HELPER_CALL_rDrB(efdcfs);
+  break;
+  case 0x2f0:
+     // efdcfui (Convert Floating-Point Double-Precision from Unsigned Integer, SPEPEM p5-24)
+     PREPARE_DIRTY_HELPER_CALL_rDrB(efdcfui);
+  break;
+  case 0x2f1:
+      // efdcfsi (Convert Floating-Point Double-Precision from Signed Integer, SPEPEM p5-21)
+     PREPARE_DIRTY_HELPER_CALL_rDrB(efdcfsi);
+  break;
+  case 0x2f2:
+     // efdcfuf (Convert Floating-Point Double-Precision from Unsigned Fraction, SPEPEM p5-23)
+     PREPARE_DIRTY_HELPER_CALL_rDrB(efdcfuf);
+  break;
+  case 0x2f3:
+     // efdcfsf (Convert Floating-Point Double-Precision from Signed Fraction, SPEPEM p5-20)
+     PREPARE_DIRTY_HELPER_CALL_rDrB(efdcfsf);
+  break;
+  default:
+     return False;
+  }
+  return True;
+}
+
 /*------------------------------------------------------------*/
 /*--- AltiVec Instruction Translation                      ---*/
 /*------------------------------------------------------------*/
@@ -21012,6 +21237,18 @@ DisResult disInstr_PPC_WRK (
 #ifdef __SPE__
       opc2 = IFIELD(theInstr, 0, 11);
       switch (opc2) {
+      case 0x2e0: // efdadd
+      case 0x2e1: // efdsub
+      case 0x2e4: // efdabs
+      case 0x2ee: // efdcmpeq
+      case 0x2ef: // efdcfs
+      case 0x2f0: // efdcfui
+      case 0x2f1: // efdcfsi
+      case 0x2f2: // efdcfuf
+      case 0x2f3: // efdcfsf
+         if (!allow_SPE) goto decode_noSPE;
+         if (dis_spe_fd( theInstr )) goto decode_success;
+         goto decode_failure;
       case 0x22c: // evmergehi
       case 0x22d: // evmergelo
       case 0x22e: // evmergehilo
diff --git a/memcheck/tests/ppc32/test_spe.c b/memcheck/tests/ppc32/test_spe.c
index b489fa8..c31066a 100644
--- a/memcheck/tests/ppc32/test_spe.c
+++ b/memcheck/tests/ppc32/test_spe.c
@@ -16156,6 +16156,283 @@ int evmhogumian_asm(void)
 }
 TEST_SPE_DECL(evmhogumian_asm, "evmhogumian");
 
+#define EXTRACTOR
+
+#define SPE_DEFN_DEFAULT(insn) \
+int insn##_asm(void)           \
+{                              \
+  int failures = 0;            \
+  return failures;             \
+}
+
+#define SPE_CMP(insn, CR_field, cmp, regA, regB)                                        \
+{                                                                                       \
+  unsigned int CR;                                                                      \
+  int field;                                                                            \
+                                                                                        \
+  field = CR_field;                                                                     \
+  asm volatile (#insn " " #CR_field ", %[a], %[b]" : : [a] "r" (regA), [b] "r" (regB)); \
+  asm volatile ("mfcr %[cr]" : [cr] "=r" (CR));                                         \
+  VERIFY(((EXTRACT_CR_FIELD(CR, field) >> 2) & 0x1) == cmp, "i = %d\n", i);             \
+}
+
+#ifdef __SPE__
+#define SPE_DEFN_crfDrArB(insn, rA_type, rB_type, tvals...)  \
+int insn##_asm(void)                                         \
+{                                                            \
+  int failures = 0;                                          \
+  register rA_type regA asm ("30");                          \
+  register rB_type regB asm ("29");                          \
+  struct test_data {                                         \
+    int     cmp;                                             \
+    rA_type aval;                                            \
+    rB_type bval;                                            \
+  } tval[] = { tvals };                                      \
+  int i;                                                     \
+                                                             \
+  for (i = 0; i < NELTS(tval); i++) {                        \
+                                                             \
+    regA = tval[i].aval;                                     \
+    regB = tval[i].bval;                                     \
+                                                             \
+    /* CR0 */ SPE_CMP(insn, 0, tval[i].cmp, (regA), (regB)); \
+    /* CR1 */ SPE_CMP(insn, 1, tval[i].cmp, (regA), (regB)); \
+    /* CR5 */ SPE_CMP(insn, 5, tval[i].cmp, (regA), (regB)); \
+    /* CR6 */ SPE_CMP(insn, 6, tval[i].cmp, (regA), (regB)); \
+    /* CR7 */ SPE_CMP(insn, 7, tval[i].cmp, (regA), (regB)); \
+  }                                                          \
+  return failures;                                           \
+}                                                            \
+TEST_SPE_DECL(insn##_asm, #insn);
+#else
+#define SPE_DEFN_crfDrArB(insn, rD_type, rA_type, rB_type, tvals...) \
+SPE_DEFN_DEFAULT(insn)                                               \
+TEST_SPE_DECL(insn##_asm, #insn);
+#endif // __SPE__
+
+#ifdef __SPE__
+#define SPE_DEFN_rDrArB(insn, rD_type, rA_type, rB_type, generate_baseline, baseline_format, tvals...) \
+int insn##_asm(void)                                                                                   \
+{                                                                                                      \
+  int failures = 0;                                                                                    \
+  register rD_type regD asm ("30");                                                                    \
+  register rA_type regA asm ("29");                                                                    \
+  register rB_type regB asm ("28");                                                                    \
+  struct test_data {                                                                                   \
+    rD_type dval;                                                                                      \
+    rA_type aval;                                                                                      \
+    rB_type bval;                                                                                      \
+  } tval[] = { tvals };                                                                                \
+  int i;                                                                                               \
+                                                                                                       \
+  for (i = 0; i < NELTS(tval); i++) {                                                                  \
+    regA = tval[i].aval;                                                                               \
+    regB = tval[i].bval;                                                                               \
+    asm volatile (#insn " %[d], %[a], %[b]" : [d] "=r" (regD) : [a] "r" (regA), [b] "r" (regB));       \
+    if (generate_baseline)                                                                             \
+      printf (baseline_format, regD);                                                                  \
+    else                                                                                               \
+      VERIFY(EXTRACTOR(regD) == EXTRACTOR(tval[i].dval), "i = %d\n", i);                               \
+  }                                                                                                    \
+  return failures;                                                                                     \
+}                                                                                                      \
+TEST_SPE_DECL(insn##_asm, #insn);
+#else
+#define SPE_DEFN_rDrArB(insn, rD_type, rA_type, rB_type, generate_baseline, baseline_format, tvals...) \
+SPE_DEFN_DEFAULT(insn)                                                                                 \
+TEST_SPE_DECL(insn##_asm, #insn);
+#endif
+
+#ifdef __SPE__
+#define SPE_DEFN_rDrB(insn, rD_type, rB_type, generate_baseline, baseline_format, tvals...) \
+int insn##_asm(void)                                                                        \
+{                                                                                           \
+  int failures = 0;                                                                         \
+  register rD_type regD asm ("29");                                                         \
+  register rB_type regB asm ("28");                                                         \
+  struct test_data {                                                                        \
+    rD_type dval;                                                                           \
+    rB_type bval;                                                                           \
+  } tval[] = { tvals };                                                                     \
+  int i;                                                                                    \
+                                                                                            \
+  for (i = 0; i < NELTS(tval); i++) {                                                       \
+    regB = tval[i].bval;                                                                    \
+    asm volatile (#insn " %[d], %[b]" : [d] "=r" (regD) : [b] "r" (regB));                  \
+    if (generate_baseline)                                                                  \
+      printf (baseline_format, EXTRACTOR(regD));                                            \
+    else                                                                                    \
+      VERIFY(EXTRACTOR(regD) == EXTRACTOR(tval[i].dval), "i = %d\n", i);                    \
+  }                                                                                         \
+  return failures;                                                                          \
+}                                                                                           \
+TEST_SPE_DECL(insn##_asm, #insn);
+#else
+#define SPE_DEFN_rDrB(insn, rD_type, rB_type, generate_baseline, baseline_format, tvals...) \
+SPE_DEFN_DEFAULT(insn)                                                                      \
+TEST_SPE_DECL(insn##_asm, #insn);
+#endif // __SPE__
+
+#define SPE_DEFN_rDrA(insn, rD_type, rA_type, generate_baseline, baseline_format, tvals...) \
+        SPE_DEFN_rDrB(insn, rD_type, rA_type, generate_baseline, baseline_format, tvals)
+
+SPE_DEFN_crfDrArB(efdcmpeq, double, double,
+ { 0x1, 1.71, 1.71                         },
+ { 0x0, 1.71, 2.3                          },
+ { 0x0, 1.71, 0.0000000000001              },
+ { 0x0, 1.71, -1.71                        },
+ { 0x0, 1.71, -2.3                         },
+ { 0x0, 1.71, -0.0000000000001             },
+ { 0x0, 1.71, 0.0                          },
+ { 0x0, 2.3, 1.71                          },
+ { 0x1, 2.3, 2.3                           },
+ { 0x0, 2.3, 0.0000000000001               },
+ { 0x0, 2.3, -1.71                         },
+ { 0x0, 2.3, -2.3                          },
+ { 0x0, 2.3, -0.0000000000001              },
+ { 0x0, 2.3, 0.0                           },
+ { 0x0, 0.0000000000001, 1.71              },
+ { 0x0, 0.0000000000001, 2.3               },
+ { 0x1, 0.0000000000001, 0.0000000000001   },
+ { 0x0, 0.0000000000001, -1.71             },
+ { 0x0, 0.0000000000001, -2.3              },
+ { 0x0, 0.0000000000001, -0.0000000000001  },
+ { 0x0, 0.0000000000001, 0.0               },
+ { 0x0, -1.71, 1.71                        },
+ { 0x0, -1.71, 2.3                         },
+ { 0x0, -1.71, 0.0000000000001             },
+ { 0x1, -1.71, -1.71                       },
+ { 0x0, -1.71, -2.3                        },
+ { 0x0, -1.71, -0.0000000000001            },
+ { 0x0, -1.71, 0.0                         },
+ { 0x0, -2.3, 1.71                         },
+ { 0x0, -2.3, 2.3                          },
+ { 0x0, -2.3, 0.0000000000001              },
+ { 0x0, -2.3, -1.71                        },
+ { 0x1, -2.3, -2.3                         },
+ { 0x0, -2.3, -0.0000000000001             },
+ { 0x0, -2.3, 0.0                          },
+ { 0x0, -0.0000000000001, 1.71             },
+ { 0x0, -0.0000000000001, 2.3              },
+ { 0x0, -0.0000000000001, 0.0000000000001  },
+ { 0x0, -0.0000000000001, -1.71            },
+ { 0x0, -0.0000000000001, -2.3             },
+ { 0x1, -0.0000000000001, -0.0000000000001 },
+ { 0x0, -0.0000000000001, 0.0              },
+ { 0x0,  0.0, 1.71                         },
+ { 0x0,  0.0, 2.3                          },
+ { 0x0,  0.0, 0.0000000000001              },
+ { 0x0,  0.0, -1.71                        },
+ { 0x0,  0.0, -2.3                         },
+ { 0x0,  0.0, -0.0000000000001             },
+ { 0x1,  0.0, 0.0                          })
+
+SPE_DEFN_rDrArB(efdadd, double, double, double, 0, "%.20f\n",
+ { -2.00918516050100004477,    -0.01020304049999999976,    -1.99898212000100006236,    },
+ {  0.61200000000000009948,    -1.71799999999999997158,     2.33000000000000007105,    },
+ {  5.69600000000000061817,    -0.00200000000000000004,     5.69800000000000039790,    },
+ {  0.00400000000000000355,     2.30399999999999982592,     -2.29999999999999982236,   },
+ {  3.65899999999999980815,    -0.01899999999999999953,     3.67799999999999993605,    },
+ { -2125.99035221000031015137, -92.31222999999999956344,   -2033.67812221000008321425, },
+ {  0.42381700000000011030,     3.14304000000000005599,    -2.71922299999999994569,    },
+ {  31266.31910000000061700121, 31245.31899999999950523488, 21.00009999999999976694,   })
+
+SPE_DEFN_rDrArB(efdsub, double, double, double, 0, "%.20f\n",
+ {  1.98877907950100007994,    -0.01020304049999999976,     -1.99898212000100006236,    },
+ { -4.04800000000000004263,    -1.71799999999999997158,      2.33000000000000007105,    },
+ { -5.70000000000000017764,    -0.00200000000000000004,      5.69800000000000039790,    },
+ {  4.60399999999999920419,     2.30399999999999982592,     -2.29999999999999982236,    },
+ { -3.69700000000000006395,    -0.01899999999999999953,      3.67799999999999993605,    },
+ {  1941.36589221000008365081, -92.31222999999999956344,    -2033.67812221000008321425, },
+ {  5.86226300000000044577,     3.14304000000000005599,     -2.71922299999999994569,    },
+ {  31224.31889999999839346856, 31245.31899999999950523488,  21.00009999999999976694,   })
+
+SPE_DEFN_rDrA(efdabs, double, double, 0, "%.30e\n",
+ { 1.71,            -1.71            },
+ { 0.0,              0.0             },
+ { 2.3,              2.3             },
+ { 0.0000000000001, -0.0000000000001 })
+
+SPE_DEFN_rDrB(efdcfs, double, float, 0, "%.30e\n",
+ { 0.000000000000000000000000000000e+00,   0.000000000000000000000000000000e+00 },
+ { 1.000000000000000000000000000000e+00,   1.000000000000000000000000000000e+00 },
+ { 1.199999973177909851074218750000e-01,   1.199999973177909851074218750000e-01 },
+ { 9.999999776482582092285156250000e-03,   9.999999776482582092285156250000e-03 },
+ { 1.200000000000000000000000000000e+01,   1.200000000000000000000000000000e+01 },
+ { 1.000000000000000000000000000000e+02,   1.000000000000000000000000000000e+02 },
+ { 2.360000000000000000000000000000e+02,   2.360000000000000000000000000000e+02 },
+ { -1.000000000000000000000000000000e+00, -1.000000000000000000000000000000e+00 })
+
+SPE_DEFN_rDrB(efdcfsf, double, __ev64_u32__, 0, "%.30e\n",
+ { -2.500000000000000000000000000000e-01, { 0xe0000000, 0xe0000000 } }, // -(1/2^2)
+ { -6.250000000000000000000000000000e-02, { 0xf8000000, 0xf8000000 } }, // -(1/4^2)
+ { -1.562500000000000000000000000000e-02, { 0xfe000000, 0xfe000000 } }, // -(1/8^2)
+ { -3.906250000000000000000000000000e-03, { 0xff800000, 0xff800000 } }, // -(1/16^2)
+ { -1.220703125000000000000000000000e-03, { 0xffd80000, 0xffd80000 } }, // -(1/32^2)
+ { -2.441406250000000000000000000000e-04, { 0xfff80000, 0xfff80000 } }, // -(1/64^2)
+ { -6.103515625000000000000000000000e-05, { 0xfffe0000, 0xfffe0000 } }, // -(1/128^2)
+ { -1.525878906250000000000000000000e-05, { 0xffff8000, 0xffff8000 } }, // -(1/256^2)
+ { -4.768371582031250000000000000000e-06, { 0xffffd800, 0xffffd800 } }, // -(1/512^2)
+ { -9.536743164062500000000000000000e-07, { 0xfffff800, 0xfffff800 } }, // -(1/1024^2)
+ { -2.384185791015625000000000000000e-07, { 0xfffffe00, 0xfffffe00 } }, // -(1/2048^2)
+ { -5.960464477539062500000000000000e-08, { 0xffffff80, 0xffffff80 } }, // -(1/4096^2)
+ { -1.862645149230957031250000000000e-08, { 0xffffffd8, 0xffffffd8 } }, // -(1/8192^2)
+ { -3.725290298461914062500000000000e-09, { 0xfffffff8, 0xfffffff8 } }, // -(1/16284^2)
+ { -1.396983861923217773437500000000e-08, { 0xffffffe2, 0xffffffe2 } }) // -(1/32768^2)
+
+SPE_DEFN_rDrB(efdcfsi, double, __ev64_s32__, 0, "%.30e\n",
+ {  34.0 , { -1,   34  } },
+ { -179.0, {  2,  -179 } },
+ { -91.0,  { -11, -91  } },
+ {  1.0,   {  0,   1   } },
+ {  46.0,  {  32,  46  } },
+ {  0.0,   {  0,   0   } })
+
+#ifdef SPE64_AVAILABLE
+SPE_DEFN_rDrB(efdcfsid, double, __ev64_s32__, 0, "%.30e\n",
+ {  34.0 , (__ev64_s64__) {  34  } },
+ { -179.0, (__ev64_s64__) { -179 } },
+ { -91.0,  (__ev64_s64__) { -91  } },
+ {  1.0,   (__ev64_s64__) {  1   } },
+ {  46.0,  (__ev64_s64__) {  46  } },
+ {  0.0,   (__ev64_s64__) {  0   } },
+#endif
+
+SPE_DEFN_rDrB(efdcfuf, double, __ev64_u64__, 0, "%.30e\n",
+ { 2.500000000000000000000000000000e-01, powers_of_half[0]  },
+ { 1.250000000000000000000000000000e-01, powers_of_half[1]  },
+ { 6.250000000000000000000000000000e-02, powers_of_half[2]  },
+ { 3.125000000000000000000000000000e-02, powers_of_half[3]  },
+ { 1.562500000000000000000000000000e-02, powers_of_half[4]  },
+ { 7.812500000000000000000000000000e-03, powers_of_half[5]  },
+ { 3.906250000000000000000000000000e-03, powers_of_half[6]  },
+ { 1.953125000000000000000000000000e-03, powers_of_half[7]  },
+ { 9.765625000000000000000000000000e-04, powers_of_half[8]  },
+ { 4.882812500000000000000000000000e-04, powers_of_half[9]  },
+ { 2.441406250000000000000000000000e-04, powers_of_half[10] },
+ { 1.220703125000000000000000000000e-04, powers_of_half[11] },
+ { 6.103515625000000000000000000000e-05, powers_of_half[12] },
+ { 3.051757812500000000000000000000e-05, powers_of_half[13] },
+ { 1.525878906250000000000000000000e-05, powers_of_half[14] })
+
+SPE_DEFN_rDrB(efdcfui, double, __ev64_u32__, 0, "%.30e\n",
+ { 34.0,  { 1,  34  } },
+ { 179.0, { 2,  179 } },
+ { 91.0,  { 11, 91  } },
+ { 1.0,   { 0,  1   } },
+ { 46.0,  { 32, 46  } },
+ { 0.0,   { 0,  0   } })
+
+#ifdef SPE64_AVAILABLE
+SPE_DEFN_rDrB(efdcfuid, double, __ev64_u64__, 0, "%.30e\n",
+ { 34.0 , { 34  } },
+ { 179.0, { 179 } },
+ { 91.0,  { 91  } },
+ { 1.0,   { 1   } },
+ { 46.0,  { 46  } },
+ { 0.0,   { 0   } }),
+#endif
+
 /* NOTE: To avoid having to remaster the .exp files entirely, add
  *       new test functions /just above/ this comment.
  *       That way, you only need to worry about the test that you
@@ -16426,6 +16703,60 @@ test_t spe_isa_ACC_based_fractional_multiply_insns_test_table = {
   }
 };
 
+test_t spe_isa_spe_fs_test_table = {
+
+  .type = table,
+  .description = "SPE ISA Single Precision Scalar Floating Point Unit Tests",
+  .table = {
+    NULL
+  }
+};
+
+test_t spe_isa_spe_fv_test_table = {
+
+  .type = table,
+  .description = "SPE ISA Single Precision Vector Floating Point Unit Tests",
+  .table = {
+    NULL
+  }
+};
+
+test_t spe_isa_spe_fd_test_table = {
+
+  .type = table,
+  .description = "SPE ISA Double Precision Scalar Floating Point Unit Tests",
+  .table = {
+    F(efdcmpeq_asm),
+    F(efdabs_asm),
+    F(efdadd_asm),
+    F(efdsub_asm),
+    F(efdcfs_asm),
+    F(efdcfsf_asm),
+    F(efdcfsi_asm),
+#ifdef SPE64_AVAILABLE
+    F(efdcfsid_asm),
+#endif
+    F(efdcfuf_asm),
+    F(efdcfui_asm),
+#ifdef SPE64_AVAILABLE
+    F(efdcfuid_asm),
+#endif
+    NULL
+  }
+};
+
+test_t spe_isa_fp_test_table = {
+
+  .type = table,
+  .description = "SPE ISA Floating Point Unit Tests",
+  .table = {
+    &spe_isa_spe_fs_test_table,
+    &spe_isa_spe_fv_test_table,
+    &spe_isa_spe_fd_test_table,
+    NULL
+  }
+};
+
 test_t spe_isa_insn_test_table = {
 
   .type = table,
@@ -16441,6 +16772,7 @@ test_t spe_isa_insn_test_table = {
     &spe_isa_add_insns_test_table,
     &spe_isa_ACC_based_multiply_insns_test_table,
     &spe_isa_ACC_based_fractional_multiply_insns_test_table,
+    &spe_isa_fp_test_table,
     NULL
   }
 };
diff --git a/memcheck/tests/ppc32/test_spe.h b/memcheck/tests/ppc32/test_spe.h
index 0030d32..6058f24 100644
--- a/memcheck/tests/ppc32/test_spe.h
+++ b/memcheck/tests/ppc32/test_spe.h
@@ -5,6 +5,7 @@
 #include <malloc.h>
 #include <assert.h>
 #include <stdbool.h>
+#include <math.h>
 #ifdef __SPE__
 #include <spe.h>
 #endif
@@ -83,11 +84,12 @@ static void report (test_t *test)
   }
 }
 
-#define VERIFY(condition)                      \
+#define VERIFY(condition, state...)            \
 {                                              \
   if (!(condition)) {                          \
     failures++;                                \
     printf("Failure at line: %d\n", __LINE__); \
+    printf("State: " state);                   \
   }                                            \
 }
 
diff --git a/memcheck/tests/ppc32/test_spe.stderr.exp b/memcheck/tests/ppc32/test_spe.stderr.exp
index f520e54..d9c604f 100644
--- a/memcheck/tests/ppc32/test_spe.stderr.exp
+++ b/memcheck/tests/ppc32/test_spe.stderr.exp
@@ -2,18 +2,18 @@
 Invalid write of size 4
    at 0x........: vg_quick_start_guide_aux (test_spe.c:28)
    by 0x........: vg_quick_start_guide (test_spe.c:34)
-   by 0x........: run (test_spe.h:43)
-   by 0x........: run (test_spe.h:49)
-   by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:16634)
+   by 0x........: run (test_spe.h:44)
+   by 0x........: run (test_spe.h:50)
+   by 0x........: run (test_spe.h:50)
+   by 0x........: main (test_spe.c:16966)
  Address 0x........ is 0 bytes after a block of size 40 alloc'd
    at 0x........: malloc (vg_replace_malloc.c:...)
    by 0x........: vg_quick_start_guide_aux (test_spe.c:26)
    by 0x........: vg_quick_start_guide (test_spe.c:34)
-   by 0x........: run (test_spe.h:43)
-   by 0x........: run (test_spe.h:49)
-   by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:16634)
+   by 0x........: run (test_spe.h:44)
+   by 0x........: run (test_spe.h:50)
+   by 0x........: run (test_spe.h:50)
+   by 0x........: main (test_spe.c:16966)
 
 
 HEAP SUMMARY:
@@ -24,10 +24,10 @@ HEAP SUMMARY:
    at 0x........: malloc (vg_replace_malloc.c:...)
    by 0x........: vg_quick_start_guide_aux (test_spe.c:26)
    by 0x........: vg_quick_start_guide (test_spe.c:34)
-   by 0x........: run (test_spe.h:43)
-   by 0x........: run (test_spe.h:49)
-   by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:16634)
+   by 0x........: run (test_spe.h:44)
+   by 0x........: run (test_spe.h:50)
+   by 0x........: run (test_spe.h:50)
+   by 0x........: main (test_spe.c:16966)
 
 LEAK SUMMARY:
    definitely lost: 40 bytes in 1 blocks
diff --git a/memcheck/tests/ppc32/test_spe.stdout.exp b/memcheck/tests/ppc32/test_spe.stdout.exp
index 9ea6117..efdf0ca 100644
--- a/memcheck/tests/ppc32/test_spe.stdout.exp
+++ b/memcheck/tests/ppc32/test_spe.stdout.exp
@@ -165,6 +165,19 @@ SPE Regression Tests: PASS
 ....evmhogsmian: PASS
 ....evmhogumiaa: PASS
 ....evmhogumian: PASS
+...SPE ISA Floating Point Unit Tests: PASS
+....SPE ISA Single Precision Scalar Floating Point Unit Tests: PASS
+....SPE ISA Single Precision Vector Floating Point Unit Tests: PASS
+....SPE ISA Double Precision Scalar Floating Point Unit Tests: PASS
+.....efdcmpeq: PASS
+.....efdabs: PASS
+.....efdadd: PASS
+.....efdsub: PASS
+.....efdcfs: PASS
+.....efdcfsf: PASS
+.....efdcfsi: PASS
+.....efdcfuf: PASS
+.....efdcfui: PASS
 ..SPE2PIM Tests: PASS
 ...Chapter 2: High-Level Language Interface: PASS
 ...Chapter 5: Programming Interface Examples: PASS
diff --git a/regtest-power7-64.default-build.log b/regtest-power7-64.default-build.log
index 461f22e..4799852 100644
--- a/regtest-power7-64.default-build.log
+++ b/regtest-power7-64.default-build.log
@@ -461,7 +461,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -gdwarf-4 -fdebug-types-section -Wno-long-lo
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests'
-make[5]: Warning: File `.deps/xml1.Po' has modification time 78 s in the future
+make[5]: Warning: File `.deps/xml1.Po' has modification time 71 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -484,7 +484,7 @@ gcc -Winline -Wall -Wshadow -g -Wno-long-long  -Wno-pointer-sign -fno-stack-prot
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests/ppc32'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests/ppc32'
-make[5]: Warning: File `.deps/test_spe.Po' has modification time 82 s in the future
+make[5]: Warning: File `.deps/test_spe.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -504,7 +504,7 @@ gcc -Winline -Wall -Wshadow -g  -Winline -Wall -Wshadow -g -I../../../include -m
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests/ppc64'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests/ppc64'
-make[5]: Warning: File `.deps/power_ISA2_05-power_ISA2_05.Po' has modification time 82 s in the future
+make[5]: Warning: File `.deps/power_ISA2_05-power_ISA2_05.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -551,7 +551,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests/linux'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests/linux'
-make[5]: Warning: File `.deps/timerfd-syscall.Po' has modification time 82 s in the future
+make[5]: Warning: File `.deps/timerfd-syscall.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -605,7 +605,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -fPIC -Wno-long-long  -Wno-pointer-sign -fno
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/cachegrind/tests'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/cachegrind/tests'
-make[5]: Warning: File `.deps/myprint_so-myprint.Po' has modification time 82 s in the future
+make[5]: Warning: File `.deps/myprint_so-myprint.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -656,7 +656,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/callgrind/tests'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/callgrind/tests'
-make[5]: Warning: File `.deps/threads.Po' has modification time 82 s in the future
+make[5]: Warning: File `.deps/threads.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -764,7 +764,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[4]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/massif/tests'
 make  check-local
 make[4]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/massif/tests'
-make[4]: Warning: File `.deps/zero.Po' has modification time 82 s in the future
+make[4]: Warning: File `.deps/zero.Po' has modification time 83 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1158,7 +1158,7 @@ gcc -Winline -Wall -Wshadow -g -m32 -Winline -Wall -O -lm -g -mregnames -DHAS_DF
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests/ppc32'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests/ppc32'
-make[5]: Warning: File `.deps/xlc_dbl_u32.Po' has modification time 80 s in the future
+make[5]: Warning: File `.deps/xlc_dbl_u32.Po' has modification time 75 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1226,7 +1226,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Winline -Wall -O -lm -g -mregnames -DHAS_DF
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests/ppc64'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests/ppc64'
-make[5]: Warning: File `.deps/twi_tdi.Po' has modification time 79 s in the future
+make[5]: Warning: File `.deps/twi_tdi.Po' has modification time 78 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1255,7 +1255,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests/linux'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests/linux'
-make[5]: Warning: File `.deps/mremap3.Po' has modification time 82 s in the future
+make[5]: Warning: File `.deps/mremap3.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1418,7 +1418,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[4]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/helgrind/tests'
 make  check-local
 make[4]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/helgrind/tests'
-make[4]: Warning: File `.deps/tc24_nonzero_sem.Po' has modification time 82 s in the future
+make[4]: Warning: File `.deps/tc24_nonzero_sem.Po' has modification time 83 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1628,7 +1628,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wextra -Wno-inline -Wno-unused-parameter -W
 make[4]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/drd/tests'
 make  check-local
 make[4]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/drd/tests'
-make[4]: Warning: File `.deps/unit_vc-unit_vc.Po' has modification time 76 s in the future
+make[4]: Warning: File `.deps/unit_vc-unit_vc.Po' has modification time 70 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1689,7 +1689,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[4]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/exp-sgcheck/tests'
 make  check-local
 make[4]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/exp-sgcheck/tests'
-make[4]: Warning: File `.deps/stackerr.Po' has modification time 82 s in the future
+make[4]: Warning: File `.deps/stackerr.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1759,7 +1759,7 @@ gcc -Winline -Wall -Wshadow -g -Wno-long-long  -Wno-pointer-sign -fno-stack-prot
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/exp-bbv/tests/ppc32-linux'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/exp-bbv/tests/ppc32-linux'
-make[5]: Warning: File `.deps/million.Po' has modification time 82 s in the future
+make[5]: Warning: File `.deps/million.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1819,7 +1819,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[3]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/tests'
 make  check-local
 make[3]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/tests'
-make[3]: Warning: File `.deps/x86_amd64_features-x86_amd64_features.Po' has modification time 82 s in the future
+make[3]: Warning: File `.deps/x86_amd64_features-x86_amd64_features.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1863,7 +1863,7 @@ gcc -Winline -Wall -Wshadow -g -O -m64 -Wno-shadow -Wno-inline -Wno-long-long  -
 make[3]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/perf'
 make  check-local
 make[3]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/perf'
-make[3]: Warning: File `.deps/tinycc-tinycc.Po' has modification time 82 s in the future
+make[3]: Warning: File `.deps/tinycc-tinycc.Po' has modification time 83 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1901,7 +1901,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[3]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/gdbserver_tests'
 make  check-local
 make[3]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/gdbserver_tests'
-make[3]: Warning: File `.deps/watchpoints.Po' has modification time 82 s in the future
+make[3]: Warning: File `.deps/watchpoints.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1980,7 +1980,7 @@ badfree-2trace:  valgrind   --num-callers=2 -q ./badfree
 badfree:         valgrind   -q ./badfree 
 badfree3:        valgrind   -q --fullpath-after=/proj/ppc/DT/labhome/anmol/valgrind-3.8.1/ ./badfree 
 badjump:         valgrind   ./badjump 
-sh: line 1:  7110 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck ./badjump > badjump.stdout.out 2> badjump.stderr.out
+sh: line 1: 15337 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck ./badjump > badjump.stdout.out 2> badjump.stderr.out
 badjump2:        valgrind   -q ./badjump2 
 badloop:         valgrind   -q ./badloop 
 badpoll:         valgrind   -q ./badpoll 
@@ -1997,7 +1997,7 @@ clo_redzone_default: valgrind   --leak-check=no -q ./clo_redzone
 custom-overlap:  valgrind   --leak-check=summary -q ./custom-overlap 
 custom_alloc:    valgrind   -q ./custom_alloc 
 deep-backtrace:  valgrind   -q --num-callers=500 ./deep-backtrace 
-sh: line 1:  7669 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --num-callers=500 ./deep-backtrace > deep-backtrace.stdout.out 2> deep-backtrace.stderr.out
+sh: line 1: 22225 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --num-callers=500 ./deep-backtrace > deep-backtrace.stdout.out 2> deep-backtrace.stderr.out
 deep_templates:  valgrind   -q ./deep_templates 
 describe-block:  valgrind   ./describe-block 
 doublefree:      valgrind   -q ./doublefree 
@@ -2109,7 +2109,7 @@ supp-dir:        valgrind   --suppressions=x86/ ./../../tests/true
 supp1:           valgrind   --suppressions=supp.supp -q ./supp1 
 supp2:           valgrind   --suppressions=supp.supp -q ./supp2 
 supp_unknown:    valgrind   -q --suppressions=supp_unknown.supp ./badjump 
-sh: line 1: 12433 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --suppressions=supp_unknown.supp ./badjump > supp_unknown.stdout.out 2> supp_unknown.stderr.out
+sh: line 1:  7143 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --suppressions=supp_unknown.supp ./badjump > supp_unknown.stdout.out 2> supp_unknown.stderr.out
 *** supp_unknown failed (stderr) ***
 suppfree:        valgrind   --suppressions=suppfree.supp -q ./suppfree 
 test-plo-no:     valgrind   -q ./test-plo 
@@ -2246,7 +2246,7 @@ gxx304:          valgrind   ./gxx304
 ifunc:           (skipping, prereq failed: test -e ifunc)
 -- Running  tests in none/tests/linux ----------------------------------
 blockfault:      valgrind   ./blockfault 
-sh: line 1: 16942 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=none ./blockfault > blockfault.stdout.out 2> blockfault.stderr.out
+sh: line 1:  6544 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=none ./blockfault > blockfault.stdout.out 2> blockfault.stderr.out
 mremap:          valgrind   ./mremap 
 mremap2:         valgrind   ./mremap2 
 mremap3:         valgrind   ./mremap3 
@@ -2412,7 +2412,7 @@ tc20_verifywrap: valgrind   --read-var-info=yes ./tc20_verifywrap
 *** tc20_verifywrap failed (stderr) ***
 tc21_pthonce:    valgrind   --read-var-info=yes ./tc21_pthonce 
 tc22_exit_w_lock: valgrind   ./tc22_exit_w_lock 
-sh: line 1:  2095 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=helgrind ./tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
+sh: line 1: 13416 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=helgrind ./tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
 tc23_bogus_condwait: valgrind   ./tc23_bogus_condwait 
 tc24_nonzero_sem: valgrind   --hg-sanity-flags=111111 ./tc24_nonzero_sem 
 -- Finished tests in helgrind/tests ------------------------------------
@@ -2529,7 +2529,7 @@ tc18_semabuse:   valgrind   ./../../helgrind/tests/tc18_semabuse
 tc19_shadowmem:  valgrind   --error-limit=no --read-var-info=yes --show-confl-seg=no --num-callers=3 ./../../helgrind/tests/tc19_shadowmem 
 tc21_pthonce:    valgrind   --num-callers=3 ./../../helgrind/tests/tc21_pthonce 
 tc22_exit_w_lock: valgrind   --num-callers=3 ./../../helgrind/tests/tc22_exit_w_lock 
-sh: line 1:  7450 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=drd --num-callers=3 ./../../helgrind/tests/tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
+sh: line 1:  6595 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=drd --num-callers=3 ./../../helgrind/tests/tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
 tc23_bogus_condwait: valgrind   --num-callers=3 ./../../helgrind/tests/tc23_bogus_condwait 
 tc24_nonzero_sem: valgrind   --read-var-info=yes ./../../helgrind/tests/tc24_nonzero_sem 
 thread_name:     valgrind   --read-var-info=yes --check-stack-var=yes --num-callers=3 ./thread_name 
diff --git a/regtest-power7-64.log b/regtest-power7-64.log
index ea0edc2..46aea31 100644
--- a/regtest-power7-64.log
+++ b/regtest-power7-64.log
@@ -461,7 +461,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -gdwarf-4 -fdebug-types-section -Wno-long-lo
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests'
-make[5]: Warning: File `.deps/xml1.Po' has modification time 78 s in the future
+make[5]: Warning: File `.deps/xml1.Po' has modification time 76 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -484,7 +484,7 @@ gcc -Winline -Wall -Wshadow -g -Wno-long-long  -Wno-pointer-sign -fno-stack-prot
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests/ppc32'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests/ppc32'
-make[5]: Warning: File `.deps/test_spe.Po' has modification time 82 s in the future
+make[5]: Warning: File `.deps/test_spe.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -504,7 +504,7 @@ gcc -Winline -Wall -Wshadow -g  -Winline -Wall -Wshadow -g -I../../../include -m
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests/ppc64'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests/ppc64'
-make[5]: Warning: File `.deps/power_ISA2_05-power_ISA2_05.Po' has modification time 82 s in the future
+make[5]: Warning: File `.deps/power_ISA2_05-power_ISA2_05.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -551,7 +551,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests/linux'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests/linux'
-make[5]: Warning: File `.deps/timerfd-syscall.Po' has modification time 82 s in the future
+make[5]: Warning: File `.deps/timerfd-syscall.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -605,7 +605,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -fPIC -Wno-long-long  -Wno-pointer-sign -fno
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/cachegrind/tests'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/cachegrind/tests'
-make[5]: Warning: File `.deps/myprint_so-myprint.Po' has modification time 82 s in the future
+make[5]: Warning: File `.deps/myprint_so-myprint.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -656,7 +656,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/callgrind/tests'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/callgrind/tests'
-make[5]: Warning: File `.deps/threads.Po' has modification time 82 s in the future
+make[5]: Warning: File `.deps/threads.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -764,7 +764,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[4]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/massif/tests'
 make  check-local
 make[4]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/massif/tests'
-make[4]: Warning: File `.deps/zero.Po' has modification time 82 s in the future
+make[4]: Warning: File `.deps/zero.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1066,7 +1066,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests'
-make[5]: Warning: File `.deps/vgprintf.Po' has modification time 81 s in the future
+make[5]: Warning: File `.deps/vgprintf.Po' has modification time 82 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1158,7 +1158,7 @@ gcc -Winline -Wall -Wshadow -g -m32 -Winline -Wall -O -lm -g -mregnames -DHAS_DF
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests/ppc32'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests/ppc32'
-make[5]: Warning: File `.deps/xlc_dbl_u32.Po' has modification time 79 s in the future
+make[5]: Warning: File `.deps/xlc_dbl_u32.Po' has modification time 81 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1226,7 +1226,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Winline -Wall -O -lm -g -mregnames -DHAS_DF
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests/ppc64'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests/ppc64'
-make[5]: Warning: File `.deps/twi_tdi.Po' has modification time 79 s in the future
+make[5]: Warning: File `.deps/twi_tdi.Po' has modification time 70 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1255,7 +1255,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests/linux'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests/linux'
-make[5]: Warning: File `.deps/mremap3.Po' has modification time 82 s in the future
+make[5]: Warning: File `.deps/mremap3.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1418,7 +1418,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[4]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/helgrind/tests'
 make  check-local
 make[4]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/helgrind/tests'
-make[4]: Warning: File `.deps/tc24_nonzero_sem.Po' has modification time 82 s in the future
+make[4]: Warning: File `.deps/tc24_nonzero_sem.Po' has modification time 83 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1628,7 +1628,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wextra -Wno-inline -Wno-unused-parameter -W
 make[4]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/drd/tests'
 make  check-local
 make[4]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/drd/tests'
-make[4]: Warning: File `.deps/unit_vc-unit_vc.Po' has modification time 76 s in the future
+make[4]: Warning: File `.deps/unit_vc-unit_vc.Po' has modification time 75 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1689,7 +1689,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[4]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/exp-sgcheck/tests'
 make  check-local
 make[4]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/exp-sgcheck/tests'
-make[4]: Warning: File `.deps/stackerr.Po' has modification time 82 s in the future
+make[4]: Warning: File `.deps/stackerr.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1759,7 +1759,7 @@ gcc -Winline -Wall -Wshadow -g -Wno-long-long  -Wno-pointer-sign -fno-stack-prot
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/exp-bbv/tests/ppc32-linux'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/exp-bbv/tests/ppc32-linux'
-make[5]: Warning: File `.deps/million.Po' has modification time 82 s in the future
+make[5]: Warning: File `.deps/million.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1819,7 +1819,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[3]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/tests'
 make  check-local
 make[3]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/tests'
-make[3]: Warning: File `.deps/x86_amd64_features-x86_amd64_features.Po' has modification time 82 s in the future
+make[3]: Warning: File `.deps/x86_amd64_features-x86_amd64_features.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1863,7 +1863,7 @@ gcc -Winline -Wall -Wshadow -g -O -m64 -Wno-shadow -Wno-inline -Wno-long-long  -
 make[3]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/perf'
 make  check-local
 make[3]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/perf'
-make[3]: Warning: File `.deps/tinycc-tinycc.Po' has modification time 82 s in the future
+make[3]: Warning: File `.deps/tinycc-tinycc.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1901,7 +1901,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[3]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/gdbserver_tests'
 make  check-local
 make[3]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/gdbserver_tests'
-make[3]: Warning: File `.deps/watchpoints.Po' has modification time 82 s in the future
+make[3]: Warning: File `.deps/watchpoints.Po' has modification time 84 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1980,7 +1980,7 @@ badfree-2trace:  valgrind   --num-callers=2 -q ./badfree
 badfree:         valgrind   -q ./badfree 
 badfree3:        valgrind   -q --fullpath-after=/proj/ppc/DT/labhome/anmol/valgrind-3.8.1/ ./badfree 
 badjump:         valgrind   ./badjump 
-sh: line 1:  8454 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck ./badjump > badjump.stdout.out 2> badjump.stderr.out
+sh: line 1: 18191 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck ./badjump > badjump.stdout.out 2> badjump.stderr.out
 badjump2:        valgrind   -q ./badjump2 
 badloop:         valgrind   -q ./badloop 
 badpoll:         valgrind   -q ./badpoll 
@@ -1997,7 +1997,7 @@ clo_redzone_default: valgrind   --leak-check=no -q ./clo_redzone
 custom-overlap:  valgrind   --leak-check=summary -q ./custom-overlap 
 custom_alloc:    valgrind   -q ./custom_alloc 
 deep-backtrace:  valgrind   -q --num-callers=500 ./deep-backtrace 
-sh: line 1:  9018 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --num-callers=500 ./deep-backtrace > deep-backtrace.stdout.out 2> deep-backtrace.stderr.out
+sh: line 1: 18752 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --num-callers=500 ./deep-backtrace > deep-backtrace.stdout.out 2> deep-backtrace.stderr.out
 deep_templates:  valgrind   -q ./deep_templates 
 describe-block:  valgrind   ./describe-block 
 doublefree:      valgrind   -q ./doublefree 
@@ -2110,7 +2110,7 @@ supp-dir:        valgrind   --suppressions=x86/ ./../../tests/true
 supp1:           valgrind   --suppressions=supp.supp -q ./supp1 
 supp2:           valgrind   --suppressions=supp.supp -q ./supp2 
 supp_unknown:    valgrind   -q --suppressions=supp_unknown.supp ./badjump 
-sh: line 1: 15170 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --suppressions=supp_unknown.supp ./badjump > supp_unknown.stdout.out 2> supp_unknown.stderr.out
+sh: line 1: 25619 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --suppressions=supp_unknown.supp ./badjump > supp_unknown.stdout.out 2> supp_unknown.stderr.out
 *** supp_unknown failed (stderr) ***
 suppfree:        valgrind   --suppressions=suppfree.supp -q ./suppfree 
 test-plo-no:     valgrind   -q ./test-plo 
@@ -2246,7 +2246,7 @@ gxx304:          valgrind   ./gxx304
 ifunc:           (skipping, prereq failed: test -e ifunc)
 -- Running  tests in none/tests/linux ----------------------------------
 blockfault:      valgrind   ./blockfault 
-sh: line 1: 19728 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=none ./blockfault > blockfault.stdout.out 2> blockfault.stderr.out
+sh: line 1: 22984 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=none ./blockfault > blockfault.stdout.out 2> blockfault.stderr.out
 mremap:          valgrind   ./mremap 
 mremap2:         valgrind   ./mremap2 
 mremap3:         valgrind   ./mremap3 
@@ -2412,7 +2412,7 @@ tc20_verifywrap: valgrind   --read-var-info=yes ./tc20_verifywrap
 *** tc20_verifywrap failed (stderr) ***
 tc21_pthonce:    valgrind   --read-var-info=yes ./tc21_pthonce 
 tc22_exit_w_lock: valgrind   ./tc22_exit_w_lock 
-sh: line 1:  4905 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=helgrind ./tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
+sh: line 1: 14488 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=helgrind ./tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
 tc23_bogus_condwait: valgrind   ./tc23_bogus_condwait 
 tc24_nonzero_sem: valgrind   --hg-sanity-flags=111111 ./tc24_nonzero_sem 
 -- Finished tests in helgrind/tests ------------------------------------
@@ -2531,7 +2531,7 @@ tc18_semabuse:   valgrind   ./../../helgrind/tests/tc18_semabuse
 tc19_shadowmem:  valgrind   --error-limit=no --read-var-info=yes --show-confl-seg=no --num-callers=3 ./../../helgrind/tests/tc19_shadowmem 
 tc21_pthonce:    valgrind   --num-callers=3 ./../../helgrind/tests/tc21_pthonce 
 tc22_exit_w_lock: valgrind   --num-callers=3 ./../../helgrind/tests/tc22_exit_w_lock 
-sh: line 1: 11233 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=drd --num-callers=3 ./../../helgrind/tests/tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
+sh: line 1: 11114 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=drd --num-callers=3 ./../../helgrind/tests/tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
 tc23_bogus_condwait: valgrind   --num-callers=3 ./../../helgrind/tests/tc23_bogus_condwait 
 tc24_nonzero_sem: valgrind   --read-var-info=yes ./../../helgrind/tests/tc24_nonzero_sem 
 thread_name:     valgrind   --read-var-info=yes --check-stack-var=yes --num-callers=3 ./thread_name 
-- 
1.7.3.4

