From 12f88b3a0bd67e7776c4706d12bf2343d0abef3d Mon Sep 17 00:00:00 2001
From: Anmol P. Paralkar <anmol@freescale.com>
Date: Thu, 28 Mar 2013 08:00:46 -0700
Subject: [PATCH 40/65] Implement SPE Instructions: {

 evmhosmf, evmhosmfa, evmhosmfaaw, evmhosmfanw,
 evmhesmf, evmhesmfa, evmhesmfaaw, evmhesmfanw

}.
---
 VEX/priv/guest_ppc_defs.h                |   38 +
 VEX/priv/guest_ppc_helpers.c             |  341 ++++++
 VEX/priv/guest_ppc_toIR.c                |  248 ++++
 memcheck/tests/ppc32/test_spe.c          | 1882 ++++++++++++++++++++++++++++++
 memcheck/tests/ppc32/test_spe.stderr.exp |   54 +-
 memcheck/tests/ppc32/test_spe.stdout.exp |    8 +
 regtest-power7-64.log                    |   34 +-
 7 files changed, 2561 insertions(+), 44 deletions(-)

diff --git a/VEX/priv/guest_ppc_defs.h b/VEX/priv/guest_ppc_defs.h
index 3319127..9581447 100644
--- a/VEX/priv/guest_ppc_defs.h
+++ b/VEX/priv/guest_ppc_defs.h
@@ -185,6 +185,44 @@ extern void spe_dirtyhelper_evmwhsmf ( VexGuestPPC32State* gst,
                                        UInt rD_off,
                                        UInt rA_off,
                                        UInt rB_off);
+extern void spe_dirtyhelper_evmhosmfanw ( VexGuestPPC32State* gst,
+                                          UInt ACC_off,
+                                          UInt rD_off,
+                                          UInt rA_off,
+                                          UInt rB_off);
+extern void spe_dirtyhelper_evmhosmfaaw ( VexGuestPPC32State* gst,
+                                          UInt ACC_off,
+                                          UInt rD_off,
+                                          UInt rA_off,
+                                          UInt rB_off);
+extern void spe_dirtyhelper_evmhosmfa ( VexGuestPPC32State* gst,
+                                        UInt ACC_off,
+                                        UInt rD_off,
+                                        UInt rA_off,
+                                        UInt rB_off);
+extern void spe_dirtyhelper_evmhosmf ( VexGuestPPC32State* gst,
+                                       UInt rD_off,
+                                       UInt rA_off,
+                                       UInt rB_off);
+extern void spe_dirtyhelper_evmhesmfanw ( VexGuestPPC32State* gst,
+                                          UInt ACC_off,
+                                          UInt rD_off,
+                                          UInt rA_off,
+                                          UInt rB_off);
+extern void spe_dirtyhelper_evmhesmfaaw ( VexGuestPPC32State* gst,
+                                          UInt ACC_off,
+                                          UInt rD_off,
+                                          UInt rA_off,
+                                          UInt rB_off);
+extern void spe_dirtyhelper_evmhesmfa ( VexGuestPPC32State* gst,
+                                        UInt ACC_off,
+                                        UInt rD_off,
+                                        UInt rA_off,
+                                        UInt rB_off);
+extern void spe_dirtyhelper_evmhesmf ( VexGuestPPC32State* gst,
+                                       UInt rD_off,
+                                       UInt rA_off,
+                                       UInt rB_off);
 
 #endif /* ndef __VEX_GUEST_PPC_DEFS_H */
 
diff --git a/VEX/priv/guest_ppc_helpers.c b/VEX/priv/guest_ppc_helpers.c
index cf3d583..16af8e6 100644
--- a/VEX/priv/guest_ppc_helpers.c
+++ b/VEX/priv/guest_ppc_helpers.c
@@ -493,6 +493,347 @@ IRExpr* guest_ppc64_spechelper ( HChar* function_name,
    return NULL;
 }
 
+/* CALLED FROM GENERATED CODE */
+/* DIRTY HELPER (reads guest state, writes guest state) */
+void spe_dirtyhelper_evmhosmfanw ( VexGuestPPC32State* gst,
+                                   UInt ACC_off,
+                                   UInt rD_off,
+                                   UInt rA_off,
+                                   UInt rB_off)
+{
+#ifdef __SPE__
+
+  // evmhosmfanw (Vector Multiply Half Words, Odd, Signed, Modulo, Fractional
+  // and Accumulate Negative into Words, SPEPEM p5-168)
+
+  register __ev64_opaque__ rA  asm ("29");
+  register __ev64_opaque__ rB  asm ("28");
+  register __ev64_opaque__ rT  asm ("27");
+  register __ev64_opaque__ ACC asm ("26");
+  register __ev64_opaque__ rD  asm ("25");
+
+  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
+  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+
+  // Read ACC, rA, rB from the Guest State:
+  ACC = __ev_create_s64 (*((Long *) ((UChar *) gst + ACC_off)));
+  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
+  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
+
+  // rT[00:31] <- rA[16:31] Xsf rB[16:31]
+  // rT[32:63] <- rA[48:63] Xsf rB[48:63]
+  asm volatile ("evmhosmf %[t], %[a], %[b]" : [t] "=r" (rT) : [a] "r" (rA), [b] "r" (rB));
+
+  // rD[00:31] <- ACC[00:31] - rT[00:31]
+  rD = __ev_set_upper_s32 (rD, __ev_get_upper_s32(ACC) - __ev_get_upper_s32(rT));
+  // rD[32:63] <- ACC[32:63] - rT[32:63]
+  rD = __ev_set_lower_s32 (rD, __ev_get_lower_s32(ACC) - __ev_get_lower_s32(rT));
+  // Write rD to the Guest State:
+  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
+
+  // ACC[0:63] <- rD[0:63]
+  ACC = rD;
+  // Write ACC to the Guest State:
+  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
+#endif // __SPE__
+  return;
+}
+
+/* CALLED FROM GENERATED CODE */
+/* DIRTY HELPER (reads guest state, writes guest state) */
+void spe_dirtyhelper_evmhosmfaaw ( VexGuestPPC32State* gst,
+                                   UInt ACC_off,
+                                   UInt rD_off,
+                                   UInt rA_off,
+                                   UInt rB_off)
+{
+#ifdef __SPE__
+
+  // evmhosmfaaw (Vector Multiply Half Words, Odd, Signed, Modulo, Fractional
+  // and Accumulate into Words, SPEPEM p5-167)
+
+  register __ev64_opaque__ rA  asm ("29");
+  register __ev64_opaque__ rB  asm ("28");
+  register __ev64_opaque__ rT  asm ("27");
+  register __ev64_opaque__ ACC asm ("26");
+  register __ev64_opaque__ rD  asm ("25");
+
+  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
+  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+
+  // Read ACC, rA, rB from the Guest State:
+  ACC = __ev_create_s64 (*((Long *) ((UChar *) gst + ACC_off)));
+  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
+  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
+
+  // rT[00:31] <- rA[16:31] Xsf rB[16:31]
+  // rT[32:63] <- rA[48:63] Xsf rB[48:63]
+  asm volatile ("evmhosmf %[t], %[a], %[b]" : [t] "=r" (rT) : [a] "r" (rA), [b] "r" (rB));
+
+  // rD[00:31] <- ACC[00:31] + rT[00:31]
+  rD = __ev_set_upper_s32 (rD, __ev_get_upper_s32(ACC) + __ev_get_upper_s32(rT));
+  // rD[32:63] <- ACC[32:63] + rT[32:63]
+  rD = __ev_set_lower_s32 (rD, __ev_get_lower_s32(ACC) + __ev_get_lower_s32(rT));
+  // Write rD to the Guest State:
+  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
+
+  // ACC[0:63] <- rD[0:63]
+  ACC = rD;
+  // Write ACC to the Guest State:
+  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
+#endif // __SPE__
+  return;
+}
+
+/* CALLED FROM GENERATED CODE */
+/* DIRTY HELPER (reads guest state, writes guest state) */
+void spe_dirtyhelper_evmhosmfa ( VexGuestPPC32State* gst,
+                                 UInt ACC_off,
+                                 UInt rD_off,
+                                 UInt rA_off,
+                                 UInt rB_off)
+{
+#ifdef __SPE__
+
+  // evmhosmfa (Vector Multiply Half Words, Odd, Signed, Modulo, Fractional (to Accumulator), SPEPEM p5-166)
+
+  register __ev64_opaque__ rA  asm ("29");
+  register __ev64_opaque__ rB  asm ("28");
+  register __ev64_opaque__ rD  asm ("27");
+  register __ev64_opaque__ ACC asm ("26");
+
+  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
+  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+
+  // Read rA, rB from the Guest State:
+  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
+  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
+
+  // rD[00:31] <- rA[16:31] Xsf rB[16:31]
+  // rD[32:63] <- rA[48:63] Xsf rB[48:63]
+  asm volatile ("evmhosmf %[t], %[a], %[b]" : [t] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
+
+  // Write rD to the Guest State:
+  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
+
+  // ACC[0:63] <- rD[0:63]
+  ACC = rD;
+  // Write ACC to the Guest State:
+  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
+#endif // __SPE__
+  return;
+}
+
+/* CALLED FROM GENERATED CODE */
+/* DIRTY HELPER (reads guest state, writes guest state) */
+void spe_dirtyhelper_evmhosmf ( VexGuestPPC32State* gst,
+                                UInt rD_off,
+                                UInt rA_off,
+                                UInt rB_off)
+{
+#ifdef __SPE__
+
+  // evmhosmf (Vector Multiply Half Words, Odd, Signed, Modulo, Fractional, SPEPEM p5-166)
+
+  register __ev64_opaque__ rA asm ("29");
+  register __ev64_opaque__ rB asm ("28");
+  register __ev64_opaque__ rD asm ("27");
+
+  vassert(rD_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+  vassert(rA_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+  vassert(rB_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+
+  // Read rA, rB from the Guest State:
+  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
+  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
+
+  // rD[00:31] <- rA[16:31] Xsf rB[16:31]
+  // rD[32:63] <- rA[48:63] Xsf rB[48:63]
+  asm volatile ("evmhosmf %[t], %[a], %[b]" : [t] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
+
+  // Write rD to the Guest State:
+  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
+
+#endif // __SPE__
+  return;
+}
+
+/* CALLED FROM GENERATED CODE */
+/* DIRTY HELPER (reads guest state, writes guest state) */
+void spe_dirtyhelper_evmhesmfanw ( VexGuestPPC32State* gst,
+                                   UInt ACC_off,
+                                   UInt rD_off,
+                                   UInt rA_off,
+                                   UInt rB_off)
+{
+#ifdef __SPE__
+
+  // evmhesmfanw (Vector Multiply Half Words, Even, Signed, Modulo, Fractional
+  // and Accumulate Negative into Words, SPEPEM p5-146)
+
+  register __ev64_opaque__ rA  asm ("29");
+  register __ev64_opaque__ rB  asm ("28");
+  register __ev64_opaque__ rT  asm ("27");
+  register __ev64_opaque__ ACC asm ("26");
+  register __ev64_opaque__ rD  asm ("25");
+
+  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
+  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+
+  // Read ACC, rA, rB from the Guest State:
+  ACC = __ev_create_s64 (*((Long *) ((UChar *) gst + ACC_off)));
+  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
+  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
+
+  // rT[00:31] <- rA[00:15] Xsf rB[00:15]
+  // rT[32:63] <- rA[32:47] Xsf rB[32:47]
+  asm volatile ("evmhesmf %[t], %[a], %[b]" : [t] "=r" (rT) : [a] "r" (rA), [b] "r" (rB));
+
+  // rD[00:31] <- ACC[00:31] - rT[00:31]
+  rD = __ev_set_upper_s32 (rD, __ev_get_upper_s32(ACC) - __ev_get_upper_s32(rT));
+  // rD[32:63] <- ACC[32:63] - rT[32:63]
+  rD = __ev_set_lower_s32 (rD, __ev_get_lower_s32(ACC) - __ev_get_lower_s32(rT));
+  // Write rD to the Guest State:
+  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
+
+  // ACC[00:63] <- rD[0:63]
+  ACC = rD;
+  // Write ACC to the Guest State:
+  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
+#endif // __SPE__
+  return;
+}
+
+/* CALLED FROM GENERATED CODE */
+/* DIRTY HELPER (reads guest state, writes guest state) */
+void spe_dirtyhelper_evmhesmfaaw ( VexGuestPPC32State* gst,
+                                   UInt ACC_off,
+                                   UInt rD_off,
+                                   UInt rA_off,
+                                   UInt rB_off)
+{
+#ifdef __SPE__
+
+  // evmhesmfaaw (Vector Multiply Half Words, Even, Signed, Modulo, Fractional
+  // and Accumulate into Words, SPEPEM p5-167)
+
+  register __ev64_opaque__ rA  asm ("29");
+  register __ev64_opaque__ rB  asm ("28");
+  register __ev64_opaque__ rT  asm ("27");
+  register __ev64_opaque__ ACC asm ("26");
+  register __ev64_opaque__ rD  asm ("25");
+
+  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
+  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+
+  // Read ACC, rA, rB from the Guest State:
+  ACC = __ev_create_s64 (*((Long *) ((UChar *) gst + ACC_off)));
+  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
+  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
+
+  // rT[00:31] <- rA[00:15] Xsf rB[00:15]
+  // rT[32:63] <- rA[32:47] Xsf rB[32:47]
+  asm volatile ("evmhesmf %[t], %[a], %[b]" : [t] "=r" (rT) : [a] "r" (rA), [b] "r" (rB));
+
+  // rD[00:31] <- ACC[00:31] + rT[00:31]
+  rD = __ev_set_upper_s32 (rD, __ev_get_upper_s32(ACC) + __ev_get_upper_s32(rT));
+  // rD[32:63] <- ACC[32:63] + rT[32:63]
+  rD = __ev_set_lower_s32 (rD, __ev_get_lower_s32(ACC) + __ev_get_lower_s32(rT));
+  // Write rD to the Guest State:
+  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
+
+  // ACC[0:63] <- rD[0:63]
+  ACC = rD;
+  // Write ACC to the Guest State:
+  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
+#endif // __SPE__
+  return;
+}
+
+/* CALLED FROM GENERATED CODE */
+/* DIRTY HELPER (reads guest state, writes guest state) */
+void spe_dirtyhelper_evmhesmfa ( VexGuestPPC32State* gst,
+                                 UInt ACC_off,
+                                 UInt rD_off,
+                                 UInt rA_off,
+                                 UInt rB_off)
+{
+#ifdef __SPE__
+
+  // evmhesmfa (Vector Multiply Half Words, Even, Signed, Modulo, Fractional (to Accumulator), SPEPEM p5-166)
+
+  register __ev64_opaque__ rA  asm ("29");
+  register __ev64_opaque__ rB  asm ("28");
+  register __ev64_opaque__ rD  asm ("27");
+  register __ev64_opaque__ ACC asm ("26");
+
+  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
+  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+
+  // Read rA, rB from the Guest State:
+  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
+  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
+
+  // rD[00:31] <- rA[00:15] Xsf rB[00:15]
+  // rD[32:63] <- rA[32:47] Xsf rB[32:47]
+  asm volatile ("evmhesmf %[t], %[a], %[b]" : [t] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
+
+  // Write rD to the Guest State:
+  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
+
+  // ACC[0:63] <- rD[0:63]
+  ACC = rD;
+  // Write ACC to the Guest State:
+  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
+#endif // __SPE__
+  return;
+}
+
+/* CALLED FROM GENERATED CODE */
+/* DIRTY HELPER (reads guest state, writes guest state) */
+void spe_dirtyhelper_evmhesmf ( VexGuestPPC32State* gst,
+                                UInt rD_off,
+                                UInt rA_off,
+                                UInt rB_off)
+{
+#ifdef __SPE__
+
+  // evmhesmf (Vector Multiply Half Words, Even, Signed, Modulo, Fractional, SPEPEM p5-166)
+
+  register __ev64_opaque__ rA asm ("29");
+  register __ev64_opaque__ rB asm ("28");
+  register __ev64_opaque__ rD asm ("27");
+
+  vassert(rD_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+  vassert(rA_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+  vassert(rB_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
+
+  // Read rA, rB from the Guest State:
+  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
+  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
+
+  // rD[00:31] <- rA[00:15] Xsf rB[00:15]
+  // rD[32:63] <- rA[32:47] Xsf rB[32:47]
+  asm volatile ("evmhesmf %[t], %[a], %[b]" : [t] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
+
+  // Write rD to the Guest State:
+  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
+
+#endif // __SPE__
+  return;
+}
 
 /*----------------------------------------------*/
 /*--- The exported fns ..                    ---*/
diff --git a/VEX/priv/guest_ppc_toIR.c b/VEX/priv/guest_ppc_toIR.c
index 7ba382d..c1df7d7 100644
--- a/VEX/priv/guest_ppc_toIR.c
+++ b/VEX/priv/guest_ppc_toIR.c
@@ -14187,6 +14187,122 @@ static Bool dis_spe_ACC_based_fractional_multiply_insns ( UInt theInstr )
      return False;
   }
   switch (opc2) {
+  case 0x42b:
+     // evmhesmfa (Vector Multiply Half Words, Even, Signed, Modulo, Fractional (to Accumulator), SPEPEM p5-166)
+     args = mkIRExprVec_4 ( mkU32( ACC_off ),
+                            mkU32( rD_off ),
+                            mkU32( rA_off ),
+                            mkU32( rB_off ) );
+     d = unsafeIRDirty_0_N (0 /* regparms */,
+                            "spe_dirtyhelper_evmhesmfa",
+                            &spe_dirtyhelper_evmhesmfa,
+                            args);
+     DIP( "evmhesmfa r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
+     /* declare guest state effects */
+     d->needsBBP = True;
+     d->nFxState = 4;
+     vex_bzero(&d->fxState, sizeof(d->fxState));
+     d->fxState[0].fx     = Ifx_Write;
+     d->fxState[0].offset = ACC_off;
+     d->fxState[0].size   = sizeof(ULong);
+     d->fxState[1].fx     = Ifx_Write;
+     d->fxState[1].offset = rD_off;
+     d->fxState[1].size   = 2 * sizeof(UInt);
+     d->fxState[2].fx     = Ifx_Read;
+     d->fxState[2].offset = rA_off;
+     d->fxState[2].size   = 2 * sizeof(UInt);
+     d->fxState[3].fx     = Ifx_Read;
+     d->fxState[3].offset = rB_off;
+     d->fxState[3].size   = 2 * sizeof(UInt);
+
+     /* execute the dirty call, side-effecting guest state */
+     stmt( IRStmt_Dirty(d) );
+     break;
+  case 0x42f:
+     // evmhosmfa (Vector Multiply Half Words, Odd, Signed, Modulo, Fractional (to Accumulator), SPEPEM p5-166)
+     args = mkIRExprVec_4 ( mkU32( ACC_off ),
+                            mkU32( rD_off ),
+                            mkU32( rA_off ),
+                            mkU32( rB_off ) );
+     d = unsafeIRDirty_0_N (0 /* regparms */,
+                            "spe_dirtyhelper_evmhosmfa",
+                            &spe_dirtyhelper_evmhosmfa,
+                            args);
+     DIP( "evmhosmfa r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
+     /* declare guest state effects */
+     d->needsBBP = True;
+     d->nFxState = 4;
+     vex_bzero(&d->fxState, sizeof(d->fxState));
+     d->fxState[0].fx     = Ifx_Write;
+     d->fxState[0].offset = ACC_off;
+     d->fxState[0].size   = sizeof(ULong);
+     d->fxState[1].fx     = Ifx_Write;
+     d->fxState[1].offset = rD_off;
+     d->fxState[1].size   = 2 * sizeof(UInt);
+     d->fxState[2].fx     = Ifx_Read;
+     d->fxState[2].offset = rA_off;
+     d->fxState[2].size   = 2 * sizeof(UInt);
+     d->fxState[3].fx     = Ifx_Read;
+     d->fxState[3].offset = rB_off;
+     d->fxState[3].size   = 2 * sizeof(UInt);
+
+     /* execute the dirty call, side-effecting guest state */
+     stmt( IRStmt_Dirty(d) );
+     break;
+  case 0x40b:
+     // evmhesmf (Vector Multiply Half Words, Even, Signed, Modulo, Fractional, SPEPEM p5-166)
+     args = mkIRExprVec_3 ( mkU32( rD_off ),
+                            mkU32( rA_off ),
+                            mkU32( rB_off ) );
+     d = unsafeIRDirty_0_N (0 /* regparms */,
+                            "spe_dirtyhelper_evmhesmf",
+                            &spe_dirtyhelper_evmhesmf,
+                            args);
+     DIP( "evmhesmf r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
+     /* declare guest state effects */
+     d->needsBBP = True;
+     d->nFxState = 3;
+     vex_bzero(&d->fxState, sizeof(d->fxState));
+     d->fxState[0].fx     = Ifx_Write;
+     d->fxState[0].offset = rD_off;
+     d->fxState[0].size   = 2 * sizeof(UInt);
+     d->fxState[1].fx     = Ifx_Read;
+     d->fxState[1].offset = rA_off;
+     d->fxState[1].size   = 2 * sizeof(UInt);
+     d->fxState[2].fx     = Ifx_Read;
+     d->fxState[2].offset = rB_off;
+     d->fxState[2].size   = 2 * sizeof(UInt);
+
+     /* execute the dirty call, side-effecting guest state */
+     stmt( IRStmt_Dirty(d) );
+     break;
+  case 0x40f:
+     // evmhosmf (Vector Multiply Half Words, Odd, Signed, Modulo, Fractional, SPEPEM p5-166)
+     args = mkIRExprVec_3 ( mkU32( rD_off ),
+                            mkU32( rA_off ),
+                            mkU32( rB_off ) );
+     d = unsafeIRDirty_0_N (0 /* regparms */,
+                            "spe_dirtyhelper_evmhosmf",
+                            &spe_dirtyhelper_evmhosmf,
+                            args);
+     DIP( "evmhosmf r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
+     /* declare guest state effects */
+     d->needsBBP = True;
+     d->nFxState = 3;
+     vex_bzero(&d->fxState, sizeof(d->fxState));
+     d->fxState[0].fx     = Ifx_Write;
+     d->fxState[0].offset = rD_off;
+     d->fxState[0].size   = 2 * sizeof(UInt);
+     d->fxState[1].fx     = Ifx_Read;
+     d->fxState[1].offset = rA_off;
+     d->fxState[1].size   = 2 * sizeof(UInt);
+     d->fxState[2].fx     = Ifx_Read;
+     d->fxState[2].offset = rB_off;
+     d->fxState[2].size   = 2 * sizeof(UInt);
+
+     /* execute the dirty call, side-effecting guest state */
+     stmt( IRStmt_Dirty(d) );
+     break;
   case 0x44f:
      // evmwhsmf (Vector Multiply Word High Signed, Modulo, Fractional, SPEPEM p5-184)
      args = mkIRExprVec_3 ( mkU32( rD_off ),
@@ -14303,6 +14419,68 @@ static Bool dis_spe_ACC_based_fractional_multiply_insns ( UInt theInstr )
      /* execute the dirty call, side-effecting guest state */
      stmt( IRStmt_Dirty(d) );
      break;
+  case 0x50b:
+     // evmhesmfaaw (Vector Multiply Half Words, Even, Signed, Modulo, Fractional and Accumulate into Words, SPEPEM p5-167)
+     args = mkIRExprVec_4 ( mkU32( ACC_off ),
+                            mkU32( rD_off ),
+                            mkU32( rA_off ),
+                            mkU32( rB_off ) );
+     d = unsafeIRDirty_0_N (0 /* regparms */,
+                            "spe_dirtyhelper_evmhesmfaaw",
+                            &spe_dirtyhelper_evmhesmfaaw,
+                            args);
+     DIP( "evmhesmfaaw r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
+     /* declare guest state effects */
+     d->needsBBP = True;
+     d->nFxState = 4;
+     vex_bzero(&d->fxState, sizeof(d->fxState));
+     d->fxState[0].fx     = Ifx_Modify;
+     d->fxState[0].offset = ACC_off;
+     d->fxState[0].size   = sizeof(ULong);
+     d->fxState[1].fx     = Ifx_Write;
+     d->fxState[1].offset = rD_off;
+     d->fxState[1].size   = 2 * sizeof(UInt);
+     d->fxState[2].fx     = Ifx_Read;
+     d->fxState[2].offset = rA_off;
+     d->fxState[2].size   = 2 * sizeof(UInt);
+     d->fxState[3].fx     = Ifx_Read;
+     d->fxState[3].offset = rB_off;
+     d->fxState[3].size   = 2 * sizeof(UInt);
+
+     /* execute the dirty call, side-effecting guest state */
+     stmt( IRStmt_Dirty(d) );
+     break;
+  case 0x50f:
+     // evmhosmfaaw (Vector Multiply Half Words, Odd, Signed, Modulo, Fractional and Accumulate into Words, SPEPEM p5-167)
+     args = mkIRExprVec_4 ( mkU32( ACC_off ),
+                            mkU32( rD_off ),
+                            mkU32( rA_off ),
+                            mkU32( rB_off ) );
+     d = unsafeIRDirty_0_N (0 /* regparms */,
+                            "spe_dirtyhelper_evmhosmfaaw",
+                            &spe_dirtyhelper_evmhosmfaaw,
+                            args);
+     DIP( "evmhosmfaaw r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
+     /* declare guest state effects */
+     d->needsBBP = True;
+     d->nFxState = 4;
+     vex_bzero(&d->fxState, sizeof(d->fxState));
+     d->fxState[0].fx     = Ifx_Modify;
+     d->fxState[0].offset = ACC_off;
+     d->fxState[0].size   = sizeof(ULong);
+     d->fxState[1].fx     = Ifx_Write;
+     d->fxState[1].offset = rD_off;
+     d->fxState[1].size   = 2 * sizeof(UInt);
+     d->fxState[2].fx     = Ifx_Read;
+     d->fxState[2].offset = rA_off;
+     d->fxState[2].size   = 2 * sizeof(UInt);
+     d->fxState[3].fx     = Ifx_Read;
+     d->fxState[3].offset = rB_off;
+     d->fxState[3].size   = 2 * sizeof(UInt);
+
+     /* execute the dirty call, side-effecting guest state */
+     stmt( IRStmt_Dirty(d) );
+     break;
   case 0x55b:
      // evmwsmfaa (Vector Multiply Word Signed, Modulo, Fractional and Accumulate, SPEPEM p5-200)
      args = mkIRExprVec_4 ( mkU32( ACC_off ),
@@ -14334,6 +14512,68 @@ static Bool dis_spe_ACC_based_fractional_multiply_insns ( UInt theInstr )
      /* execute the dirty call, side-effecting guest state */
      stmt( IRStmt_Dirty(d) );
      break;
+  case 0x58b:
+     // evmhesmfanw (Vector Multiply Half Words, Even, Signed, Modulo, Fractional and Accumulate Negative into Words, SPEPEM p5-168)
+     args = mkIRExprVec_4 ( mkU32( ACC_off ),
+                            mkU32( rD_off ),
+                            mkU32( rA_off ),
+                            mkU32( rB_off ) );
+     d = unsafeIRDirty_0_N (0 /* regparms */,
+                            "spe_dirtyhelper_evmhesmfanw",
+                            &spe_dirtyhelper_evmhesmfanw,
+                            args);
+     DIP( "evmhesmfanw r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
+     /* declare guest state effects */
+     d->needsBBP = True;
+     d->nFxState = 4;
+     vex_bzero(&d->fxState, sizeof(d->fxState));
+     d->fxState[0].fx     = Ifx_Modify;
+     d->fxState[0].offset = ACC_off;
+     d->fxState[0].size   = sizeof(ULong);
+     d->fxState[1].fx     = Ifx_Write;
+     d->fxState[1].offset = rD_off;
+     d->fxState[1].size   = 2 * sizeof(UInt);
+     d->fxState[2].fx     = Ifx_Read;
+     d->fxState[2].offset = rA_off;
+     d->fxState[2].size   = 2 * sizeof(UInt);
+     d->fxState[3].fx     = Ifx_Read;
+     d->fxState[3].offset = rB_off;
+     d->fxState[3].size   = 2 * sizeof(UInt);
+
+     /* execute the dirty call, side-effecting guest state */
+     stmt( IRStmt_Dirty(d) );
+     break;
+  case 0x58f:
+     // evmhosmfanw (Vector Multiply Half Words, Odd, Signed, Modulo, Fractional and Accumulate Negative into Words, SPEPEM p5-168)
+     args = mkIRExprVec_4 ( mkU32( ACC_off ),
+                            mkU32( rD_off ),
+                            mkU32( rA_off ),
+                            mkU32( rB_off ) );
+     d = unsafeIRDirty_0_N (0 /* regparms */,
+                            "spe_dirtyhelper_evmhosmfanw",
+                            &spe_dirtyhelper_evmhosmfanw,
+                            args);
+     DIP( "evmhosmfanw r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
+     /* declare guest state effects */
+     d->needsBBP = True;
+     d->nFxState = 4;
+     vex_bzero(&d->fxState, sizeof(d->fxState));
+     d->fxState[0].fx     = Ifx_Modify;
+     d->fxState[0].offset = ACC_off;
+     d->fxState[0].size   = sizeof(ULong);
+     d->fxState[1].fx     = Ifx_Write;
+     d->fxState[1].offset = rD_off;
+     d->fxState[1].size   = 2 * sizeof(UInt);
+     d->fxState[2].fx     = Ifx_Read;
+     d->fxState[2].offset = rA_off;
+     d->fxState[2].size   = 2 * sizeof(UInt);
+     d->fxState[3].fx     = Ifx_Read;
+     d->fxState[3].offset = rB_off;
+     d->fxState[3].size   = 2 * sizeof(UInt);
+
+     /* execute the dirty call, side-effecting guest state */
+     stmt( IRStmt_Dirty(d) );
+     break;
   case 0x5db:
      // evmwsmfan (Vector Multiply Word Signed, Modulo, Fractional and Accumulate Negative, SPEPEM p5-201)
      args = mkIRExprVec_4 ( mkU32( ACC_off ),
@@ -20483,10 +20723,18 @@ DisResult disInstr_PPC_WRK (
          if (!allow_SPE) goto decode_noSPE;
          if (dis_spe_ACC_based_multiply_insns( theInstr )) goto decode_success;
          goto decode_failure;
+      case 0x40b: // evmhesmf
+      case 0x40f: // evmhosmf
+      case 0x42b: // evmhesmfa
+      case 0x42f: // evmhosmfa
       case 0x44f: // evmwhsmf
       case 0x46f: // evmwhsmfa
       case 0x45b: // evmwsmf
       case 0x47b: // evmwsmfa
+      case 0x50b: // evmhesmfaaw
+      case 0x50f: // evmhosmfaaw
+      case 0x58b: // evmhesmfanw
+      case 0x58f: // evmhosmfanw
       case 0x55b: // evmwsmfaa
       case 0x5db: // evmwsmfan
          if (!allow_SPE) goto decode_noSPE;
diff --git a/memcheck/tests/ppc32/test_spe.c b/memcheck/tests/ppc32/test_spe.c
index 881cfc4..cf7fa8c 100644
--- a/memcheck/tests/ppc32/test_spe.c
+++ b/memcheck/tests/ppc32/test_spe.c
@@ -10841,6 +10841,1880 @@ int evmwhsmfa_asm(void)
 }
 TEST_SPE_DECL(evmwhsmfa_asm, "evmwhsmfa");
 
+#ifdef __SPE__
+__ev64_s32__ evmhosmfanw_baseline[] = {
+
+  (__ev64_s32__) { 0x28604c58,  0x57aa7ba },
+  (__ev64_s32__) { 0x377e4004,  0xa1953b32 },
+  (__ev64_s32__) { 0xe4f39f28,  0xaac07b8a },
+  (__ev64_s32__) { 0x964ed94c,  0x8afec602 },
+  (__ev64_s32__) { 0x9033b51a,  0xd0241d72 },
+  (__ev64_s32__) { 0xd083b9a2,  0xe07d063e },
+  (__ev64_s32__) { 0xca21e2ea,  0xeb17951e },
+  (__ev64_s32__) { 0x8f6479ca,  0xf1c6db5e },
+  (__ev64_s32__) { 0x942ad7d2,  0xca87d8b8 },
+  (__ev64_s32__) { 0xb6234cda,  0xed104134 },
+  (__ev64_s32__) { 0xa6d2885c,  0xce1bf890 },
+  (__ev64_s32__) { 0xbd8c845e,  0xdd9d2584 },
+  (__ev64_s32__) { 0xaf8c0f1e,  0xdc38ceec },
+  (__ev64_s32__) { 0xb187f754,  0xd65a4468 },
+  (__ev64_s32__) { 0xab65d876,  0xcf8971d0 },
+  (__ev64_s32__) { 0xe24646ba,  0xc100bdf4 },
+  (__ev64_s32__) { 0xeb34ba3a,  0x81f388dc },
+  (__ev64_s32__) { 0xd68d9f9e,  0x346a56e0 },
+  (__ev64_s32__) { 0xfb758c44,  0xfab37bac },
+  (__ev64_s32__) { 0xec25b07c,  0xee9c83c4 },
+  (__ev64_s32__) { 0xd44b3a6c,  0xdab5ed08 },
+  (__ev64_s32__) { 0xd8356e8c,  0xe5117188 },
+  (__ev64_s32__) { 0xe89af88c,  0xe3b330ec },
+  (__ev64_s32__) { 0xf7e1f5b8,  0x2f998568 },
+  (__ev64_s32__) { 0x9cd24c4a,  0x1bc75f78 },
+  (__ev64_s32__) { 0x83584b12,  0x5d6ceb8c },
+  (__ev64_s32__) { 0x8a4e43f2,  0x373f86c },
+  (__ev64_s32__) { 0x8149afb2,  0x26fdfc68 },
+  (__ev64_s32__) { 0x94cc26ba,  0xf9e587c8 },
+  (__ev64_s32__) { 0xd067556e,  0x59335ca },
+  (__ev64_s32__) { 0x66e9136,  0x62476cca },
+  (__ev64_s32__) { 0x3b2dab8e,  0x8625147c },
+  (__ev64_s32__) { 0x4fbbc106,  0xba28d146 },
+  (__ev64_s32__) { 0x1949571a,  0xbd5e7f1a },
+  (__ev64_s32__) { 0xbeefe78,  0xe2f42d8a },
+  (__ev64_s32__) { 0x75eaba6,  0x86111922 },
+  (__ev64_s32__) { 0xe51a9d1e,  0x359f4996 },
+  (__ev64_s32__) { 0xec197f12,  0x6029cf42 },
+  (__ev64_s32__) { 0xee9dd86e,  0x3b637652 },
+  (__ev64_s32__) { 0xd72ea804,  0x7accf06e },
+  (__ev64_s32__) { 0x9381a6de,  0xb5d08d6e },
+  (__ev64_s32__) { 0x349c315e,  0xad18574a },
+  (__ev64_s32__) { 0x2a71ab5e,  0xe143f1da },
+  (__ev64_s32__) { 0x2af8eccc,  0x345b6ca },
+  (__ev64_s32__) { 0xfdf3ffac,  0xff1aba0a },
+  (__ev64_s32__) { 0x2a15c8e0,  0xfec2d61a },
+  (__ev64_s32__) { 0x12535978,  0xde29a8f6 },
+  (__ev64_s32__) { 0xf0c6fdfa,  0xa684fa22 },
+  (__ev64_s32__) { 0x28f5be72,  0x85c15164 },
+  (__ev64_s32__) { 0xeead7f8e,  0x819158b6 },
+  (__ev64_s32__) { 0xcbf5c85e,  0x5329e72e },
+  (__ev64_s32__) { 0x785a857e,  0x4c70d244 },
+  (__ev64_s32__) { 0x5468db4a,  0x7ca883d8 },
+  (__ev64_s32__) { 0x4fe334d4,  0x8a3a02ca },
+  (__ev64_s32__) { 0x576687d4,  0x9315efba },
+  (__ev64_s32__) { 0xefb43fb8,  0x7ec40cbe },
+  (__ev64_s32__) { 0xf2f1e4b0,  0xb8851672 },
+  (__ev64_s32__) { 0x1f79c020,  0xec95569a },
+  (__ev64_s32__) { 0x1600a084,  0x1004ac6a },
+  (__ev64_s32__) { 0x1f816f14,  0x30d0d752 },
+  (__ev64_s32__) { 0x25c1dcc4,  0x3189a462 },
+  (__ev64_s32__) { 0xff88cd9c,  0x50b51dba },
+  (__ev64_s32__) { 0xb7e3ff98,  0x6cf1813a },
+  (__ev64_s32__) { 0xddd0b100,  0xd5afc0b0 },
+  (__ev64_s32__) { 0xd74632a6,  0xd58ca59a },
+  (__ev64_s32__) { 0x77d89282,  0xf7e65046 },
+  (__ev64_s32__) { 0x3de13be2,  0xf94c59c6 },
+  (__ev64_s32__) { 0x64459f82,  0xf350fbb2 },
+  (__ev64_s32__) { 0x479f28a0,  0xf21e667e },
+  (__ev64_s32__) { 0x1881565e,  0xf01725ba },
+  (__ev64_s32__) { 0xf676d9a,  0xfbf5874a },
+  (__ev64_s32__) { 0xd15ef18a,  0x20f3b1ba },
+  (__ev64_s32__) { 0xd4b1a6b6,  0x3c658f44 },
+  (__ev64_s32__) { 0x1057611a,  0x3be3e3c0 },
+  (__ev64_s32__) { 0xf0f3cb6e,  0x1835f540 },
+  (__ev64_s32__) { 0xd2385228,  0xe35e81c0 },
+  (__ev64_s32__) { 0xc36e1bf4,  0xfa1c6000 },
+  (__ev64_s32__) { 0x79d92f44,  0x8d4f8080 },
+  (__ev64_s32__) { 0x465ab2dc,  0x960fd148 },
+  (__ev64_s32__) { 0xffeb2e9c,  0x7e0571c8 },
+  (__ev64_s32__) { 0xe419a16c,  0x863ab9be },
+  (__ev64_s32__) { 0x48181d88,  0x7203091e },
+  (__ev64_s32__) { 0x3be56534,  0x7b650806 },
+  (__ev64_s32__) { 0x633a2070,  0x88bb3a34 },
+  (__ev64_s32__) { 0x1f716398,  0xaae53104 },
+  (__ev64_s32__) { 0xcd50de90,  0xb141381c },
+  (__ev64_s32__) { 0xb722c390,  0x9dcdd464 },
+  (__ev64_s32__) { 0xb8589dfa,  0x88240ad4 },
+  (__ev64_s32__) { 0xa73c59d2,  0x5385e5cc },
+  (__ev64_s32__) { 0xf4eceae2,  0x1b6b4a1c },
+  (__ev64_s32__) { 0xef8cbd02,  0xf9d028dc },
+  (__ev64_s32__) { 0xdcfb2c82,  0x43fa3870 },
+  (__ev64_s32__) { 0x78cb9622,  0xe678ebf6 },
+  (__ev64_s32__) { 0x33fe53a6,  0xa6362752 },
+  (__ev64_s32__) { 0x1d31de56,  0xacc2c97a },
+  (__ev64_s32__) { 0xd3d88546,  0x90c7c892 },
+  (__ev64_s32__) { 0x76141272,  0x65ea3702 },
+  (__ev64_s32__) { 0x5aa99bce,  0x667d6102 },
+  (__ev64_s32__) { 0x425185aa,  0x3da90972 },
+  (__ev64_s32__) { 0x7685e08c,  0x29e7ba0a },
+  (__ev64_s32__) { 0x70211b64,  0xe7accc42 },
+  (__ev64_s32__) { 0x90f30cc4,  0xaa0e531a },
+  (__ev64_s32__) { 0x90924b44,  0x84ed22fa },
+  (__ev64_s32__) { 0x78729d48,  0x8265a0b8 },
+  (__ev64_s32__) { 0xdc5df24c,  0x7cdb67a8 },
+  (__ev64_s32__) { 0x86b611b6,  0xe413c682 },
+  (__ev64_s32__) { 0x91d18684,  0xc3fe06f2 },
+  (__ev64_s32__) { 0xcce9be68,  0xc3e4e82a },
+  (__ev64_s32__) { 0xbaf7c5ec,  0x982b4602 },
+  (__ev64_s32__) { 0xae42aee0,  0x8cc9ebba },
+  (__ev64_s32__) { 0xa9736378,  0x93cc4346 },
+  (__ev64_s32__) { 0xd516ec7c,  0xc69820da },
+  (__ev64_s32__) { 0xb4733dcc,  0xd69a9792 },
+  (__ev64_s32__) { 0xd4f5654a,  0xc7b2bad2 },
+  (__ev64_s32__) { 0x3b93ba14,  0xb7f05c2e },
+  (__ev64_s32__) { 0x6985d164,  0xbbe6fdc2 },
+  (__ev64_s32__) { 0xc2b567f4,  0xbc26ad32 },
+  (__ev64_s32__) { 0xbbcf439c,  0x97790332 },
+  (__ev64_s32__) { 0xc598f4c0,  0xe4f4587a },
+  (__ev64_s32__) { 0xee8f6e60,  0xf3ead792 },
+  (__ev64_s32__) { 0x2dd4b8c4,  0xcd0edd36 },
+  (__ev64_s32__) { 0xe69cec64,  0xf6777e4e },
+  (__ev64_s32__) { 0x523bb20c,  0xfb6de39c },
+  (__ev64_s32__) { 0x4d739efc,  0x15a7023c },
+  (__ev64_s32__) { 0x4eafec32,  0x15b02c48 },
+  (__ev64_s32__) { 0x5a80b832,  0x5aa3ea78 },
+  (__ev64_s32__) { 0x2c741dbc,  0x70a668fa },
+  (__ev64_s32__) { 0x22518ecc,  0x829ddbba },
+  (__ev64_s32__) { 0xddf9b002,  0x91b3e95c },
+  (__ev64_s32__) { 0xdcc6b22e,  0xcbb9add8 },
+  (__ev64_s32__) { 0x63876b2e,  0xafc44c20 },
+  (__ev64_s32__) { 0x69e534e2,  0x898b0e9c },
+  (__ev64_s32__) { 0x749e550a,  0x993100fc },
+  (__ev64_s32__) { 0xba17a416,  0xbe93cfa2 },
+  (__ev64_s32__) { 0xf62b9fd4,  0xc140214a },
+  (__ev64_s32__) { 0x10c248ce,  0xbb633b1a },
+  (__ev64_s32__) { 0xdda16180,  0xe550dbba },
+  (__ev64_s32__) { 0xe1139388,  0x2f9a251e },
+  (__ev64_s32__) { 0xdb6e32e8,  0x31a0cd20 },
+  (__ev64_s32__) { 0xd817f856,  0x384a5470 },
+  (__ev64_s32__) { 0xa3dec646,  0x9bc53fd0 },
+  (__ev64_s32__) { 0x758c4cc6,  0xcbadd224 },
+  (__ev64_s32__) { 0x844d3992,  0xc98369a4 },
+  (__ev64_s32__) { 0x74ec9db6,  0xc9f5c038 },
+  (__ev64_s32__) { 0x3298ee86,  0xa86369be },
+  (__ev64_s32__) { 0x1e7f052a,  0xaeebddbe },
+  (__ev64_s32__) { 0x58753356,  0xc0d6869a },
+  (__ev64_s32__) { 0x74e32900,  0xe1a7003a },
+  (__ev64_s32__) { 0x40856e0,  0xc4b944 },
+  (__ev64_s32__) { 0x2343a78c,  0x81fb54 },
+  (__ev64_s32__) { 0x6c317bfe,  0x6687340 },
+  (__ev64_s32__) { 0x5a96b3a0,  0xa630060 },
+  (__ev64_s32__) { 0x5110abe2,  0xff4a0606 },
+  (__ev64_s32__) { 0x9abe7722,  0x2e5304ae },
+  (__ev64_s32__) { 0xa7493914,  0x1f22855e },
+  (__ev64_s32__) { 0x8abf3d38,  0xe9439a1a },
+  (__ev64_s32__) { 0x89758fe0,  0xe3910312 },
+  (__ev64_s32__) { 0xe92f438e,  0xe2eca4fa },
+  (__ev64_s32__) { 0xcc94d42a,  0x1810c60a },
+  (__ev64_s32__) { 0x6697c4f6,  0xa95ed44 },
+  (__ev64_s32__) { 0x528244aa,  0xf9a793c },
+  (__ev64_s32__) { 0xe9e8cbfe,  0x26d795d8 },
+  (__ev64_s32__) { 0xb77c82e6,  0xacd03c4 },
+  (__ev64_s32__) { 0xb904ff4a,  0xe77784cc },
+  (__ev64_s32__) { 0x65161532,  0xfbd90018 },
+  (__ev64_s32__) { 0x6b106978,  0xd0a36cc },
+  (__ev64_s32__) { 0x714d98cc,  0xd04ae3c },
+  (__ev64_s32__) { 0x5c343064,  0xb4c9cadc },
+  (__ev64_s32__) { 0x4d531b58,  0x9df58ebc },
+  (__ev64_s32__) { 0x290c7b78,  0xa5ba582c },
+  (__ev64_s32__) { 0x36af51f4,  0xa506aa80 },
+  (__ev64_s32__) { 0x2f2156a4,  0x9c7b2c56 },
+  (__ev64_s32__) { 0x455f3580,  0xf0750596 },
+  (__ev64_s32__) { 0x50f55400,  0x1e32987e },
+  (__ev64_s32__) { 0x7f4af852,  0x59f0e9b6 },
+  (__ev64_s32__) { 0x8c57fb26,  0x6d66af36 },
+  (__ev64_s32__) { 0x932993e6,  0x3ae731fe },
+  (__ev64_s32__) { 0x8ff538fa,  0x13a19a26 },
+  (__ev64_s32__) { 0xd7534040,  0x13f74ccc },
+  (__ev64_s32__) { 0xb159a084,  0x42be8ec },
+  (__ev64_s32__) { 0xb809781a,  0xfea13b56 },
+  (__ev64_s32__) { 0xa30577ca,  0x203f19b6 },
+  (__ev64_s32__) { 0x8409c486,  0x19960930 },
+  (__ev64_s32__) { 0xb5966092,  0x362b0540 },
+  (__ev64_s32__) { 0xeba27be0,  0xe2dad2d8 },
+  (__ev64_s32__) { 0x13f9e854,  0x246d3e10 },
+  (__ev64_s32__) { 0xe830a8d4,  0x90daf44 },
+  (__ev64_s32__) { 0x34058818,  0x1470baac },
+  (__ev64_s32__) { 0xe0767bb2,  0xcf4f5e74 },
+  (__ev64_s32__) { 0xe2c8302e,  0xb5e5f308 },
+  (__ev64_s32__) { 0x7ad7b762,  0xa674991c },
+  (__ev64_s32__) { 0x85604776,  0xaafbe2d8 },
+  (__ev64_s32__) { 0x41d61d12,  0x74e39c7e },
+  (__ev64_s32__) { 0x261f4a62,  0x72f9683e },
+  (__ev64_s32__) { 0x43dd7d26,  0x7a08d336 },
+  (__ev64_s32__) { 0x4468ad7c,  0x799f77c0 },
+  (__ev64_s32__) { 0x3e7a5202,  0x79e96ab8 },
+  (__ev64_s32__) { 0xa826bd6c,  0x9ed8ca08 },
+  (__ev64_s32__) { 0xe9a82ddc,  0x4e62e298 },
+  (__ev64_s32__) { 0xed648adc,  0x4cab279a },
+  (__ev64_s32__) { 0x9209d080,  0x1e590130 },
+  (__ev64_s32__) { 0x92adc140,  0x358392e0 },
+  (__ev64_s32__) { 0x87c73740,  0x5574bbfc },
+  (__ev64_s32__) { 0x3df1aea2,  0x452acac2 },
+  (__ev64_s32__) { 0x73147444,  0x527acb6e },
+  (__ev64_s32__) { 0x795d4b78,  0x648f3b52 },
+  (__ev64_s32__) { 0x7898151a,  0xbffa5df0 },
+  (__ev64_s32__) { 0xa8c75ca0,  0xb3ffa3e4 },
+  (__ev64_s32__) { 0x9907fc6c,  0xe0fd0c84 },
+  (__ev64_s32__) { 0xa9394d14,  0x936c2acc },
+  (__ev64_s32__) { 0xda0864b4,  0x7d5b6ca2 },
+  (__ev64_s32__) { 0xdc0422b4,  0x7add6adc },
+  (__ev64_s32__) { 0xffe8226,  0x926b6ed8 },
+  (__ev64_s32__) { 0xed1e9be6,  0xaab5bc28 },
+  (__ev64_s32__) { 0xcc7976be,  0xe402b344 },
+  (__ev64_s32__) { 0x72dcc22a,  0xef6865b4 },
+  (__ev64_s32__) { 0x88504a0a,  0xf045f53a },
+  (__ev64_s32__) { 0x789ab852,  0xf0a5a19a },
+  (__ev64_s32__) { 0x8a00fa92,  0x14f3d672 },
+  (__ev64_s32__) { 0xafa0d0bc,  0xf9b924d6 },
+  (__ev64_s32__) { 0x913ac59c,  0x10672dfc },
+  (__ev64_s32__) { 0x8048582e,  0x5a970f46 },
+  (__ev64_s32__) { 0x86b17666,  0x5f7fb9f6 },
+  (__ev64_s32__) { 0xa371814c,  0xb01d3998 },
+  (__ev64_s32__) { 0x9edbd22c,  0xa4380a20 },
+  (__ev64_s32__) { 0x97bed032,  0xa94799fa },
+  (__ev64_s32__) { 0xab98c23e,  0xa5efc946 },
+  (__ev64_s32__) { 0x6d8c12c2,  0xb58738ce },
+  (__ev64_s32__) { 0x7198a236,  0xd60973ba },
+  (__ev64_s32__) { 0x738daaee,  0x18e1bbf2 },
+  (__ev64_s32__) { 0x832910ae,  0x1180f07a },
+  (__ev64_s32__) { 0xb4bcbb82,  0x15944a54 },
+  (__ev64_s32__) { 0x73cbd932,  0x91dc4b2 },
+  (__ev64_s32__) { 0x922f192a,  0xbc5d6d76 },
+  (__ev64_s32__) { 0x7bf3e6a8,  0xbf492ef6 },
+  (__ev64_s32__) { 0x7b01bc84,  0x8fa55e94 },
+  (__ev64_s32__) { 0x84c271b4,  0x924c09bc },
+  (__ev64_s32__) { 0x7d89b984,  0xb7934712 },
+  (__ev64_s32__) { 0x1dcce934,  0x95dd18b4 },
+  (__ev64_s32__) { 0x3cf68808,  0x62537542 },
+  (__ev64_s32__) { 0x2ba83dd2,  0x5d7ba6c8 },
+  (__ev64_s32__) { 0x252e8a96,  0x5bbb5ef0 },
+  (__ev64_s32__) { 0x93ca2374,  0x216f99c8 },
+  (__ev64_s32__) { 0x45cdf9f4,  0xefb99908 },
+  (__ev64_s32__) { 0x83bfa1d6,  0xe63f9862 },
+  (__ev64_s32__) { 0x897b7d02,  0xbca4fa22 },
+  (__ev64_s32__) { 0x5c1b17ce,  0x1790f972 },
+  (__ev64_s32__) { 0xa2f9625e,  0x173822f0 },
+  (__ev64_s32__) { 0x9d2de612,  0x169dcd8c },
+  (__ev64_s32__) { 0xa4e3a77a,  0xff10ad24 },
+  (__ev64_s32__) { 0xfd443d5e,  0x4fa4174 },
+  (__ev64_s32__) { 0xe9fb64ae,  0x3f4f80 },
+  (__ev64_s32__) { 0xc9e9297e,  0xd64b0bc2 },
+  (__ev64_s32__) { 0x83d718be,  0xb3b86d70 },
+  (__ev64_s32__) { 0x71c8715e,  0xb4bfd066 },
+  (__ev64_s32__) { 0xd87b375e,  0xd7b77a62 },
+
+};
+#endif // __SPE__
+
+int evmhosmfanw_asm(void)
+{
+  int failures = 0;
+
+#ifdef __SPE__
+  register __ev64_s16__ regA asm ("30");
+  register __ev64_s16__ regB asm ("29");
+  register __ev64_s32__ regD asm ("28");
+
+  // Initialize the ACC.
+  regA = (__ev64_s16__) { 0x0, 0x0, 0x0, 0x0 };
+  asm volatile ("evmra %[d], %[a]" : [d] "=r" (regD) : [a] "r" (regA));
+  VERIFY(regD[0] == 0x0);
+  VERIFY(regD[1] == 0x0);
+
+  int32_t i;
+
+  for (i = 0; i < NELTS(rA4s16); i++) {
+
+    regA = rA4s16[i];
+    regB = rB4s16[i];
+
+    asm volatile ("evmhosmfanw %[d], %[a], %[b]" : [d] "=r" (regD) : [a] "r" (regA), [b] "r" (regB));
+#ifdef GEN_BASELINE
+    printf ("  (__ev64_s32__) { 0x%x,  0x%x },\n", regD[0], regD[1]);
+#else
+    VERIFY(regD[0] == evmhosmfanw_baseline[i][0]);
+    VERIFY(regD[1] == evmhosmfanw_baseline[i][1]);
+#endif
+  }
+#endif // __SPE__
+  return failures;
+}
+TEST_SPE_DECL(evmhosmfanw_asm, "evmhosmfanw");
+
+#ifdef __SPE__
+__ev64_s32__ evmhosmfaaw_baseline[] = {
+
+  (__ev64_s32__) { 0xd79fb3a8, 0xfa855846 },
+  (__ev64_s32__) { 0xc881bffc, 0x5e6ac4ce },
+  (__ev64_s32__) { 0x1b0c60d8, 0x553f8476 },
+  (__ev64_s32__) { 0x69b126b4, 0x750139fe },
+  (__ev64_s32__) { 0x6fcc4ae6, 0x2fdbe28e },
+  (__ev64_s32__) { 0x2f7c465e, 0x1f82f9c2 },
+  (__ev64_s32__) { 0x35de1d16, 0x14e86ae2 },
+  (__ev64_s32__) { 0x709b8636, 0xe3924a2 },
+  (__ev64_s32__) { 0x6bd5282e, 0x35782748 },
+  (__ev64_s32__) { 0x49dcb326, 0x12efbecc },
+  (__ev64_s32__) { 0x592d77a4, 0x31e40770 },
+  (__ev64_s32__) { 0x42737ba2, 0x2262da7c },
+  (__ev64_s32__) { 0x5073f0e2, 0x23c73114 },
+  (__ev64_s32__) { 0x4e7808ac, 0x29a5bb98 },
+  (__ev64_s32__) { 0x549a278a, 0x30768e30 },
+  (__ev64_s32__) { 0x1db9b946, 0x3eff420c },
+  (__ev64_s32__) { 0x14cb45c6, 0x7e0c7724 },
+  (__ev64_s32__) { 0x29726062, 0xcb95a920 },
+  (__ev64_s32__) { 0x48a73bc, 0x54c8454 },
+  (__ev64_s32__) { 0x13da4f84, 0x11637c3c },
+  (__ev64_s32__) { 0x2bb4c594, 0x254a12f8 },
+  (__ev64_s32__) { 0x27ca9174, 0x1aee8e78 },
+  (__ev64_s32__) { 0x17650774, 0x1c4ccf14 },
+  (__ev64_s32__) { 0x81e0a48, 0xd0667a98 },
+  (__ev64_s32__) { 0x632db3b6, 0xe438a088 },
+  (__ev64_s32__) { 0x7ca7b4ee, 0xa2931474 },
+  (__ev64_s32__) { 0x75b1bc0e, 0xfc8c0794 },
+  (__ev64_s32__) { 0x7eb6504e, 0xd9020398 },
+  (__ev64_s32__) { 0x6b33d946, 0x61a7838 },
+  (__ev64_s32__) { 0x2f98aa92, 0xfa6cca36 },
+  (__ev64_s32__) { 0xf9916eca, 0x9db89336 },
+  (__ev64_s32__) { 0xc4d25472, 0x79daeb84 },
+  (__ev64_s32__) { 0xb0443efa, 0x45d72eba },
+  (__ev64_s32__) { 0xe6b6a8e6, 0x42a180e6 },
+  (__ev64_s32__) { 0xf4110188, 0x1d0bd276 },
+  (__ev64_s32__) { 0xf8a1545a, 0x79eee6de },
+  (__ev64_s32__) { 0x1ae562e2, 0xca60b66a },
+  (__ev64_s32__) { 0x13e680ee, 0x9fd630be },
+  (__ev64_s32__) { 0x11622792, 0xc49c89ae },
+  (__ev64_s32__) { 0x28d157fc, 0x85330f92 },
+  (__ev64_s32__) { 0x6c7e5922, 0x4a2f7292 },
+  (__ev64_s32__) { 0xcb63cea2, 0x52e7a8b6 },
+  (__ev64_s32__) { 0xd58e54a2, 0x1ebc0e26 },
+  (__ev64_s32__) { 0xd5071334, 0xfcba4936 },
+  (__ev64_s32__) { 0x20c0054, 0xe545f6 },
+  (__ev64_s32__) { 0xd5ea3720, 0x13d29e6 },
+  (__ev64_s32__) { 0xedaca688, 0x21d6570a },
+  (__ev64_s32__) { 0xf390206, 0x597b05de },
+  (__ev64_s32__) { 0xd70a418e, 0x7a3eae9c },
+  (__ev64_s32__) { 0x11528072, 0x7e6ea74a },
+  (__ev64_s32__) { 0x340a37a2, 0xacd618d2 },
+  (__ev64_s32__) { 0x87a57a82, 0xb38f2dbc },
+  (__ev64_s32__) { 0xab9724b6, 0x83577c28 },
+  (__ev64_s32__) { 0xb01ccb2c, 0x75c5fd36 },
+  (__ev64_s32__) { 0xa899782c, 0x6cea1046 },
+  (__ev64_s32__) { 0x104bc048, 0x813bf342 },
+  (__ev64_s32__) { 0xd0e1b50, 0x477ae98e },
+  (__ev64_s32__) { 0xe0863fe0, 0x136aa966 },
+  (__ev64_s32__) { 0xe9ff5f7c, 0xeffb5396 },
+  (__ev64_s32__) { 0xe07e90ec, 0xcf2f28ae },
+  (__ev64_s32__) { 0xda3e233c, 0xce765b9e },
+  (__ev64_s32__) { 0x773264, 0xaf4ae246 },
+  (__ev64_s32__) { 0x481c0068, 0x930e7ec6 },
+  (__ev64_s32__) { 0x222f4f00, 0x2a503f50 },
+  (__ev64_s32__) { 0x28b9cd5a, 0x2a735a66 },
+  (__ev64_s32__) { 0x88276d7e, 0x819afba },
+  (__ev64_s32__) { 0xc21ec41e, 0x6b3a63a },
+  (__ev64_s32__) { 0x9bba607e, 0xcaf044e },
+  (__ev64_s32__) { 0xb860d760, 0xde19982 },
+  (__ev64_s32__) { 0xe77ea9a2, 0xfe8da46 },
+  (__ev64_s32__) { 0xf0989266, 0x40a78b6 },
+  (__ev64_s32__) { 0x2ea10e76, 0xdf0c4e46 },
+  (__ev64_s32__) { 0x2b4e594a, 0xc39a70bc },
+  (__ev64_s32__) { 0xefa89ee6, 0xc41c1c40 },
+  (__ev64_s32__) { 0xf0c3492, 0xe7ca0ac0 },
+  (__ev64_s32__) { 0x2dc7add8, 0x1ca17e40 },
+  (__ev64_s32__) { 0x3c91e40c, 0x5e3a000 },
+  (__ev64_s32__) { 0x8626d0bc, 0x72b07f80 },
+  (__ev64_s32__) { 0xb9a54d24, 0x69f02eb8 },
+  (__ev64_s32__) { 0x14d164, 0x81fa8e38 },
+  (__ev64_s32__) { 0x1be65e94, 0x79c54642 },
+  (__ev64_s32__) { 0xb7e7e278, 0x8dfcf6e2 },
+  (__ev64_s32__) { 0xc41a9acc, 0x849af7fa },
+  (__ev64_s32__) { 0x9cc5df90, 0x7744c5cc },
+  (__ev64_s32__) { 0xe08e9c68, 0x551acefc },
+  (__ev64_s32__) { 0x32af2170, 0x4ebec7e4 },
+  (__ev64_s32__) { 0x48dd3c70, 0x62322b9c },
+  (__ev64_s32__) { 0x47a76206, 0x77dbf52c },
+  (__ev64_s32__) { 0x58c3a62e, 0xac7a1a34 },
+  (__ev64_s32__) { 0xb13151e, 0xe494b5e4 },
+  (__ev64_s32__) { 0x107342fe, 0x62fd724 },
+  (__ev64_s32__) { 0x2304d37e, 0xbc05c790 },
+  (__ev64_s32__) { 0x873469de, 0x1987140a },
+  (__ev64_s32__) { 0xcc01ac5a, 0x59c9d8ae },
+  (__ev64_s32__) { 0xe2ce21aa, 0x533d3686 },
+  (__ev64_s32__) { 0x2c277aba, 0x6f38376e },
+  (__ev64_s32__) { 0x89ebed8e, 0x9a15c8fe },
+  (__ev64_s32__) { 0xa5566432, 0x99829efe },
+  (__ev64_s32__) { 0xbdae7a56, 0xc256f68e },
+  (__ev64_s32__) { 0x897a1f74, 0xd61845f6 },
+  (__ev64_s32__) { 0x8fdee49c, 0x185333be },
+  (__ev64_s32__) { 0x6f0cf33c, 0x55f1ace6 },
+  (__ev64_s32__) { 0x6f6db4bc, 0x7b12dd06 },
+  (__ev64_s32__) { 0x878d62b8, 0x7d9a5f48 },
+  (__ev64_s32__) { 0x23a20db4, 0x83249858 },
+  (__ev64_s32__) { 0x7949ee4a, 0x1bec397e },
+  (__ev64_s32__) { 0x6e2e797c, 0x3c01f90e },
+  (__ev64_s32__) { 0x33164198, 0x3c1b17d6 },
+  (__ev64_s32__) { 0x45083a14, 0x67d4b9fe },
+  (__ev64_s32__) { 0x51bd5120, 0x73361446 },
+  (__ev64_s32__) { 0x568c9c88, 0x6c33bcba },
+  (__ev64_s32__) { 0x2ae91384, 0x3967df26 },
+  (__ev64_s32__) { 0x4b8cc234, 0x2965686e },
+  (__ev64_s32__) { 0x2b0a9ab6, 0x384d452e },
+  (__ev64_s32__) { 0xc46c45ec, 0x480fa3d2 },
+  (__ev64_s32__) { 0x967a2e9c, 0x4419023e },
+  (__ev64_s32__) { 0x3d4a980c, 0x43d952ce },
+  (__ev64_s32__) { 0x4430bc64, 0x6886fcce },
+  (__ev64_s32__) { 0x3a670b40, 0x1b0ba786 },
+  (__ev64_s32__) { 0x117091a0, 0xc15286e },
+  (__ev64_s32__) { 0xd22b473c, 0x32f122ca },
+  (__ev64_s32__) { 0x1963139c, 0x98881b2 },
+  (__ev64_s32__) { 0xadc44df4, 0x4921c64 },
+  (__ev64_s32__) { 0xb28c6104, 0xea58fdc4 },
+  (__ev64_s32__) { 0xb15013ce, 0xea4fd3b8 },
+  (__ev64_s32__) { 0xa57f47ce, 0xa55c1588 },
+  (__ev64_s32__) { 0xd38be244, 0x8f599706 },
+  (__ev64_s32__) { 0xddae7134, 0x7d622446 },
+  (__ev64_s32__) { 0x22064ffe, 0x6e4c16a4 },
+  (__ev64_s32__) { 0x23394dd2, 0x34465228 },
+  (__ev64_s32__) { 0x9c7894d2, 0x503bb3e0 },
+  (__ev64_s32__) { 0x961acb1e, 0x7674f164 },
+  (__ev64_s32__) { 0x8b61aaf6, 0x66ceff04 },
+  (__ev64_s32__) { 0x45e85bea, 0x416c305e },
+  (__ev64_s32__) { 0x9d4602c, 0x3ebfdeb6 },
+  (__ev64_s32__) { 0xef3db732, 0x449cc4e6 },
+  (__ev64_s32__) { 0x225e9e80, 0x1aaf2446 },
+  (__ev64_s32__) { 0x1eec6c78, 0xd065dae2 },
+  (__ev64_s32__) { 0x2491cd18, 0xce5f32e0 },
+  (__ev64_s32__) { 0x27e807aa, 0xc7b5ab90 },
+  (__ev64_s32__) { 0x5c2139ba, 0x643ac030 },
+  (__ev64_s32__) { 0x8a73b33a, 0x34522ddc },
+  (__ev64_s32__) { 0x7bb2c66e, 0x367c965c },
+  (__ev64_s32__) { 0x8b13624a, 0x360a3fc8 },
+  (__ev64_s32__) { 0xcd67117a, 0x579c9642 },
+  (__ev64_s32__) { 0xe180fad6, 0x51142242 },
+  (__ev64_s32__) { 0xa78accaa, 0x3f297966 },
+  (__ev64_s32__) { 0x8b1cd700, 0x1e58ffc6 },
+  (__ev64_s32__) { 0xfbf7a920, 0xff3b46bc },
+  (__ev64_s32__) { 0xdcbc5874, 0xff7e04ac },
+  (__ev64_s32__) { 0x93ce8402, 0xf9978cc0 },
+  (__ev64_s32__) { 0xa5694c60, 0xf59cffa0 },
+  (__ev64_s32__) { 0xaeef541e, 0xb5f9fa },
+  (__ev64_s32__) { 0x654188de, 0xd1acfb52 },
+  (__ev64_s32__) { 0x58b6c6ec, 0xe0dd7aa2 },
+  (__ev64_s32__) { 0x7540c2c8, 0x16bc65e6 },
+  (__ev64_s32__) { 0x768a7020, 0x1c6efcee },
+  (__ev64_s32__) { 0x16d0bc72, 0x1d135b06 },
+  (__ev64_s32__) { 0x336b2bd6, 0xe7ef39f6 },
+  (__ev64_s32__) { 0x99683b0a, 0xf56a12bc },
+  (__ev64_s32__) { 0xad7dbb56, 0xf06586c4 },
+  (__ev64_s32__) { 0x16173402, 0xd9286a28 },
+  (__ev64_s32__) { 0x48837d1a, 0xf532fc3c },
+  (__ev64_s32__) { 0x46fb00b6, 0x18887b34 },
+  (__ev64_s32__) { 0x9ae9eace, 0x426ffe8 },
+  (__ev64_s32__) { 0x94ef9688, 0xf2f5c934 },
+  (__ev64_s32__) { 0x8eb26734, 0xf2fb51c4 },
+  (__ev64_s32__) { 0xa3cbcf9c, 0x4b363524 },
+  (__ev64_s32__) { 0xb2ace4a8, 0x620a7144 },
+  (__ev64_s32__) { 0xd6f38488, 0x5a45a7d4 },
+  (__ev64_s32__) { 0xc950ae0c, 0x5af95580 },
+  (__ev64_s32__) { 0xd0dea95c, 0x6384d3aa },
+  (__ev64_s32__) { 0xbaa0ca80, 0xf8afa6a },
+  (__ev64_s32__) { 0xaf0aac00, 0xe1cd6782 },
+  (__ev64_s32__) { 0x80b507ae, 0xa60f164a },
+  (__ev64_s32__) { 0x73a804da, 0x929950ca },
+  (__ev64_s32__) { 0x6cd66c1a, 0xc518ce02 },
+  (__ev64_s32__) { 0x700ac706, 0xec5e65da },
+  (__ev64_s32__) { 0x28acbfc0, 0xec08b334 },
+  (__ev64_s32__) { 0x4ea65f7c, 0xfbd41714 },
+  (__ev64_s32__) { 0x47f687e6, 0x15ec4aa },
+  (__ev64_s32__) { 0x5cfa8836, 0xdfc0e64a },
+  (__ev64_s32__) { 0x7bf63b7a, 0xe669f6d0 },
+  (__ev64_s32__) { 0x4a699f6e, 0xc9d4fac0 },
+  (__ev64_s32__) { 0x145d8420, 0x1d252d28 },
+  (__ev64_s32__) { 0xec0617ac, 0xdb92c1f0 },
+  (__ev64_s32__) { 0x17cf572c, 0xf6f250bc },
+  (__ev64_s32__) { 0xcbfa77e8, 0xeb8f4554 },
+  (__ev64_s32__) { 0x1f89844e, 0x30b0a18c },
+  (__ev64_s32__) { 0x1d37cfd2, 0x4a1a0cf8 },
+  (__ev64_s32__) { 0x8528489e, 0x598b66e4 },
+  (__ev64_s32__) { 0x7a9fb88a, 0x55041d28 },
+  (__ev64_s32__) { 0xbe29e2ee, 0x8b1c6382 },
+  (__ev64_s32__) { 0xd9e0b59e, 0x8d0697c2 },
+  (__ev64_s32__) { 0xbc2282da, 0x85f72cca },
+  (__ev64_s32__) { 0xbb975284, 0x86608840 },
+  (__ev64_s32__) { 0xc185adfe, 0x86169548 },
+  (__ev64_s32__) { 0x57d94294, 0x612735f8 },
+  (__ev64_s32__) { 0x1657d224, 0xb19d1d68 },
+  (__ev64_s32__) { 0x129b7524, 0xb354d866 },
+  (__ev64_s32__) { 0x6df62f80, 0xe1a6fed0 },
+  (__ev64_s32__) { 0x6d523ec0, 0xca7c6d20 },
+  (__ev64_s32__) { 0x7838c8c0, 0xaa8b4404 },
+  (__ev64_s32__) { 0xc20e515e, 0xbad5353e },
+  (__ev64_s32__) { 0x8ceb8bbc, 0xad853492 },
+  (__ev64_s32__) { 0x86a2b488, 0x9b70c4ae },
+  (__ev64_s32__) { 0x8767eae6, 0x4005a210 },
+  (__ev64_s32__) { 0x5738a360, 0x4c005c1c },
+  (__ev64_s32__) { 0x66f80394, 0x1f02f37c },
+  (__ev64_s32__) { 0x56c6b2ec, 0x6c93d534 },
+  (__ev64_s32__) { 0x25f79b4c, 0x82a4935e },
+  (__ev64_s32__) { 0x23fbdd4c, 0x85229524 },
+  (__ev64_s32__) { 0xf0017dda, 0x6d949128 },
+  (__ev64_s32__) { 0x12e1641a, 0x554a43d8 },
+  (__ev64_s32__) { 0x33868942, 0x1bfd4cbc },
+  (__ev64_s32__) { 0x8d233dd6, 0x10979a4c },
+  (__ev64_s32__) { 0x77afb5f6, 0xfba0ac6 },
+  (__ev64_s32__) { 0x876547ae, 0xf5a5e66 },
+  (__ev64_s32__) { 0x75ff056e, 0xeb0c298e },
+  (__ev64_s32__) { 0x505f2f44, 0x646db2a },
+  (__ev64_s32__) { 0x6ec53a64, 0xef98d204 },
+  (__ev64_s32__) { 0x7fb7a7d2, 0xa568f0ba },
+  (__ev64_s32__) { 0x794e899a, 0xa080460a },
+  (__ev64_s32__) { 0x5c8e7eb4, 0x4fe2c668 },
+  (__ev64_s32__) { 0x61242dd4, 0x5bc7f5e0 },
+  (__ev64_s32__) { 0x68412fce, 0x56b86606 },
+  (__ev64_s32__) { 0x54673dc2, 0x5a1036ba },
+  (__ev64_s32__) { 0x9273ed3e, 0x4a78c732 },
+  (__ev64_s32__) { 0x8e675dca, 0x29f68c46 },
+  (__ev64_s32__) { 0x8c725512, 0xe71e440e },
+  (__ev64_s32__) { 0x7cd6ef52, 0xee7f0f86 },
+  (__ev64_s32__) { 0x4b43447e, 0xea6bb5ac },
+  (__ev64_s32__) { 0x8c3426ce, 0xf6e23b4e },
+  (__ev64_s32__) { 0x6dd0e6d6, 0x43a2928a },
+  (__ev64_s32__) { 0x840c1958, 0x40b6d10a },
+  (__ev64_s32__) { 0x84fe437c, 0x705aa16c },
+  (__ev64_s32__) { 0x7b3d8e4c, 0x6db3f644 },
+  (__ev64_s32__) { 0x8276467c, 0x486cb8ee },
+  (__ev64_s32__) { 0xe23316cc, 0x6a22e74c },
+  (__ev64_s32__) { 0xc30977f8, 0x9dac8abe },
+  (__ev64_s32__) { 0xd457c22e, 0xa2845938 },
+  (__ev64_s32__) { 0xdad1756a, 0xa444a110 },
+  (__ev64_s32__) { 0x6c35dc8c, 0xde906638 },
+  (__ev64_s32__) { 0xba32060c, 0x104666f8 },
+  (__ev64_s32__) { 0x7c405e2a, 0x19c0679e },
+  (__ev64_s32__) { 0x768482fe, 0x435b05de },
+  (__ev64_s32__) { 0xa3e4e832, 0xe86f068e },
+  (__ev64_s32__) { 0x5d069da2, 0xe8c7dd10 },
+  (__ev64_s32__) { 0x62d219ee, 0xe9623274 },
+  (__ev64_s32__) { 0x5b1c5886, 0xef52dc },
+  (__ev64_s32__) { 0x2bbc2a2, 0xfb05be8c },
+  (__ev64_s32__) { 0x16049b52, 0xffc0b080 },
+  (__ev64_s32__) { 0x3616d682, 0x29b4f43e },
+  (__ev64_s32__) { 0x7c28e742, 0x4c479290 },
+  (__ev64_s32__) { 0x8e378ea2, 0x4b402f9a },
+  (__ev64_s32__) { 0x2784c8a2, 0x2848859e },
+
+};
+#endif // __SPE__
+
+int evmhosmfaaw_asm(void)
+{
+  int failures = 0;
+
+#ifdef __SPE__
+  register __ev64_s16__ regA asm ("30");
+  register __ev64_s16__ regB asm ("29");
+  register __ev64_s32__ regD asm ("28");
+
+  // Initialize the ACC.
+  regA = (__ev64_s16__) { 0x0, 0x0, 0x0, 0x0 };
+  asm volatile ("evmra %[d], %[a]" : [d] "=r" (regD) : [a] "r" (regA));
+  VERIFY(regD[0] == 0x0);
+  VERIFY(regD[1] == 0x0);
+
+  int32_t i;
+
+  for (i = 0; i < NELTS(rA4s16); i++) {
+
+    regA = rA4s16[i];
+    regB = rB4s16[i];
+
+    asm volatile ("evmhosmfaaw %[d], %[a], %[b]" : [d] "=r" (regD) : [a] "r" (regA), [b] "r" (regB));
+#ifdef GEN_BASELINE
+    printf ("  (__ev64_s32__) { 0x%x, 0x%x },\n", regD[0], regD[1]);
+#else
+    VERIFY(regD[0] == evmhosmfaaw_baseline[i][0]);
+    VERIFY(regD[1] == evmhosmfaaw_baseline[i][1]);
+#endif
+
+  }
+
+#endif // __SPE__
+  return failures;
+}
+TEST_SPE_DECL(evmhosmfaaw_asm, "evmhosmfaaw");
+
+#ifdef __SPE__
+__ev64_s32__ evmhosmf_baseline[] = {
+
+  (__ev64_s32__) { 0xd79fb3a8, 0xfa855846 },
+  (__ev64_s32__) { 0xf0e20c54, 0x63e56c88 },
+  (__ev64_s32__) { 0x528aa0dc, 0xf6d4bfa8 },
+  (__ev64_s32__) { 0x4ea4c5dc, 0x1fc1b588 },
+  (__ev64_s32__) { 0x61b2432, 0xbadaa890 },
+  (__ev64_s32__) { 0xbfaffb78, 0xefa71734 },
+  (__ev64_s32__) { 0x661d6b8, 0xf5657120 },
+  (__ev64_s32__) { 0x3abd6920, 0xf950b9c0 },
+  (__ev64_s32__) { 0xfb39a1f8, 0x273f02a6 },
+  (__ev64_s32__) { 0xde078af8, 0xdd779784 },
+  (__ev64_s32__) { 0xf50c47e, 0x1ef448a4 },
+  (__ev64_s32__) { 0xe94603fe, 0xf07ed30c },
+  (__ev64_s32__) { 0xe007540, 0x1645698 },
+  (__ev64_s32__) { 0xfe0417ca, 0x5de8a84 },
+  (__ev64_s32__) { 0x6221ede, 0x6d0d298 },
+  (__ev64_s32__) { 0xc91f91bc, 0xe88b3dc },
+  (__ev64_s32__) { 0xf7118c80, 0x3f0d3518 },
+  (__ev64_s32__) { 0x14a71a9c, 0x4d8931fc },
+  (__ev64_s32__) { 0xdb18135a, 0x39b6db34 },
+  (__ev64_s32__) { 0xf4fdbc8, 0xc16f7e8 },
+  (__ev64_s32__) { 0x17da7610, 0x13e696bc },
+  (__ev64_s32__) { 0xfc15cbe0, 0xf5a47b80 },
+  (__ev64_s32__) { 0xef9a7600, 0x15e409c },
+  (__ev64_s32__) { 0xf0b902d4, 0xb419ab84 },
+  (__ev64_s32__) { 0x5b0fa96e, 0x13d225f0 },
+  (__ev64_s32__) { 0x197a0138, 0xbe5a73ec },
+  (__ev64_s32__) { 0xf90a0720, 0x59f8f320 },
+  (__ev64_s32__) { 0x9049440, 0xdc75fc04 },
+  (__ev64_s32__) { 0xec7d88f8, 0x2d1874a0 },
+  (__ev64_s32__) { 0xc464d14c, 0xf45251fe },
+  (__ev64_s32__) { 0xc9f8c438, 0xa34bc900 },
+  (__ev64_s32__) { 0xcb40e5a8, 0xdc22584e },
+  (__ev64_s32__) { 0xeb71ea88, 0xcbfc4336 },
+  (__ev64_s32__) { 0x367269ec, 0xfcca522c },
+  (__ev64_s32__) { 0xd5a58a2, 0xda6a5190 },
+  (__ev64_s32__) { 0x49052d2, 0x5ce31468 },
+  (__ev64_s32__) { 0x22440e88, 0x5071cf8c },
+  (__ev64_s32__) { 0xf9011e0c, 0xd5757a54 },
+  (__ev64_s32__) { 0xfd7ba6a4, 0x24c658f0 },
+  (__ev64_s32__) { 0x176f306a, 0xc09685e4 },
+  (__ev64_s32__) { 0x43ad0126, 0xc4fc6300 },
+  (__ev64_s32__) { 0x5ee57580, 0x8b83624 },
+  (__ev64_s32__) { 0xa2a8600, 0xcbd46570 },
+  (__ev64_s32__) { 0xff78be92, 0xddfe3b10 },
+  (__ev64_s32__) { 0x2d04ed20, 0x42afcc0 },
+  (__ev64_s32__) { 0xd3de36cc, 0x57e3f0 },
+  (__ev64_s32__) { 0x17c26f68, 0x20992d24 },
+  (__ev64_s32__) { 0x218c5b7e, 0x37a4aed4 },
+  (__ev64_s32__) { 0xc7d13f88, 0x20c3a8be },
+  (__ev64_s32__) { 0x3a483ee4, 0x42ff8ae },
+  (__ev64_s32__) { 0x22b7b730, 0x2e677188 },
+  (__ev64_s32__) { 0x539b42e0, 0x6b914ea },
+  (__ev64_s32__) { 0x23f1aa34, 0xcfc84e6c },
+  (__ev64_s32__) { 0x485a676, 0xf26e810e },
+  (__ev64_s32__) { 0xf87cad00, 0xf7241310 },
+  (__ev64_s32__) { 0x67b2481c, 0x1451e2fc },
+  (__ev64_s32__) { 0xfcc25b08, 0xc63ef64c },
+  (__ev64_s32__) { 0xd3782490, 0xcbefbfd8 },
+  (__ev64_s32__) { 0x9791f9c, 0xdc90aa30 },
+  (__ev64_s32__) { 0xf67f3170, 0xdf33d518 },
+  (__ev64_s32__) { 0xf9bf9250, 0xff4732f0 },
+  (__ev64_s32__) { 0x26390f28, 0xe0d486a8 },
+  (__ev64_s32__) { 0x47a4ce04, 0xe3c39c80 },
+  (__ev64_s32__) { 0xda134e98, 0x9741c08a },
+  (__ev64_s32__) { 0x68a7e5a, 0x231b16 },
+  (__ev64_s32__) { 0x5f6da024, 0xdda65554 },
+  (__ev64_s32__) { 0x39f756a0, 0xfe99f680 },
+  (__ev64_s32__) { 0xd99b9c60, 0x5fb5e14 },
+  (__ev64_s32__) { 0x1ca676e2, 0x1329534 },
+  (__ev64_s32__) { 0x2f1dd242, 0x20740c4 },
+  (__ev64_s32__) { 0x919e8c4, 0xf4219e70 },
+  (__ev64_s32__) { 0x3e087c10, 0xdb01d590 },
+  (__ev64_s32__) { 0xfcad4ad4, 0xe48e2276 },
+  (__ev64_s32__) { 0xc45a459c, 0x81ab84 },
+  (__ev64_s32__) { 0x1f6395ac, 0x23adee80 },
+  (__ev64_s32__) { 0x1ebb7946, 0x34d77380 },
+  (__ev64_s32__) { 0xeca3634, 0xe94221c0 },
+  (__ev64_s32__) { 0x4994ecb0, 0x6cccdf80 },
+  (__ev64_s32__) { 0x337e7c68, 0xf73faf38 },
+  (__ev64_s32__) { 0x466f8440, 0x180a5f80 },
+  (__ev64_s32__) { 0x1bd18d30, 0xf7cab80a },
+  (__ev64_s32__) { 0x9c0183e4, 0x1437b0a0 },
+  (__ev64_s32__) { 0xc32b854, 0xf69e0118 },
+  (__ev64_s32__) { 0xd8ab44c4, 0xf2a9cdd2 },
+  (__ev64_s32__) { 0x43c8bcd8, 0xddd60930 },
+  (__ev64_s32__) { 0x52208508, 0xf9a3f8e8 },
+  (__ev64_s32__) { 0x162e1b00, 0x137363b8 },
+  (__ev64_s32__) { 0xfeca2596, 0x15a9c990 },
+  (__ev64_s32__) { 0x111c4428, 0x349e2508 },
+  (__ev64_s32__) { 0xb24f6ef0, 0x381a9bb0 },
+  (__ev64_s32__) { 0x5602de0, 0x219b2140 },
+  (__ev64_s32__) { 0x12919080, 0xb5d5f06c },
+  (__ev64_s32__) { 0x642f9660, 0x5d814c7a },
+  (__ev64_s32__) { 0x44cd427c, 0x4042c4a4 },
+  (__ev64_s32__) { 0x16cc7550, 0xf9735dd8 },
+  (__ev64_s32__) { 0x49595910, 0x1bfb00e8 },
+  (__ev64_s32__) { 0x5dc472d4, 0x2add9190 },
+  (__ev64_s32__) { 0x1b6a76a4, 0xff6cd600 },
+  (__ev64_s32__) { 0x18581624, 0x28d45790 },
+  (__ev64_s32__) { 0xcbcba51e, 0x13c14f68 },
+  (__ev64_s32__) { 0x664c528, 0x423aedc8 },
+  (__ev64_s32__) { 0xdf2e0ea0, 0x3d9e7928 },
+  (__ev64_s32__) { 0x60c180, 0x25213020 },
+  (__ev64_s32__) { 0x181fadfc, 0x2878242 },
+  (__ev64_s32__) { 0x9c14aafc, 0x58a3910 },
+  (__ev64_s32__) { 0x55a7e096, 0x98c7a126 },
+  (__ev64_s32__) { 0xf4e48b32, 0x2015bf90 },
+  (__ev64_s32__) { 0xc4e7c81c, 0x191ec8 },
+  (__ev64_s32__) { 0x11f1f87c, 0x2bb9a228 },
+  (__ev64_s32__) { 0xcb5170c, 0xb615a48 },
+  (__ev64_s32__) { 0x4cf4b68, 0xf8fda874 },
+  (__ev64_s32__) { 0xd45c76fc, 0xcd34226c },
+  (__ev64_s32__) { 0x20a3aeb0, 0xeffd8948 },
+  (__ev64_s32__) { 0xdf7dd882, 0xee7dcc0 },
+  (__ev64_s32__) { 0x9961ab36, 0xfc25ea4 },
+  (__ev64_s32__) { 0xd20de8b0, 0xfc095e6c },
+  (__ev64_s32__) { 0xa6d06970, 0xffc05090 },
+  (__ev64_s32__) { 0x6e62458, 0x24adaa00 },
+  (__ev64_s32__) { 0xf6364edc, 0xb284aab8 },
+  (__ev64_s32__) { 0xd7098660, 0xf10980e8 },
+  (__ev64_s32__) { 0xc0bab59c, 0x26dbfa5c },
+  (__ev64_s32__) { 0x4737cc60, 0xd6975ee8 },
+  (__ev64_s32__) { 0x94613a58, 0xfb099ab2 },
+  (__ev64_s32__) { 0x4c81310, 0xe5c6e160 },
+  (__ev64_s32__) { 0xfec3b2ca, 0xfff6d5f4 },
+  (__ev64_s32__) { 0xf42f3400, 0xbb0c41d0 },
+  (__ev64_s32__) { 0x2e0c9a76, 0xe9fd817e },
+  (__ev64_s32__) { 0xa228ef0, 0xee088d40 },
+  (__ev64_s32__) { 0x4457deca, 0xf0e9f25e },
+  (__ev64_s32__) { 0x132fdd4, 0xc5fa3b84 },
+  (__ev64_s32__) { 0x793f4700, 0x1bf561b8 },
+  (__ev64_s32__) { 0xf9a2364c, 0x26393d84 },
+  (__ev64_s32__) { 0xf546dfd8, 0xf05a0da0 },
+  (__ev64_s32__) { 0xba86b0f4, 0xda9d315a },
+  (__ev64_s32__) { 0xc3ec0442, 0xfd53ae58 },
+  (__ev64_s32__) { 0xe5695706, 0x5dce630 },
+  (__ev64_s32__) { 0x3320e74e, 0xd6125f60 },
+  (__ev64_s32__) { 0xfc8dcdf8, 0xb5b6b69c },
+  (__ev64_s32__) { 0x5a560a0, 0xfdf957fe },
+  (__ev64_s32__) { 0x3563a92, 0xf95678b0 },
+  (__ev64_s32__) { 0x34393210, 0x9c8514a0 },
+  (__ev64_s32__) { 0x2e527980, 0xd0176dac },
+  (__ev64_s32__) { 0xf13f1334, 0x22a6880 },
+  (__ev64_s32__) { 0xf609bdc, 0xff8da96c },
+  (__ev64_s32__) { 0x4253af30, 0x2192567a },
+  (__ev64_s32__) { 0x1419e95c, 0xf9778c00 },
+  (__ev64_s32__) { 0xc609d1d4, 0xee155724 },
+  (__ev64_s32__) { 0xe3920a56, 0xdf2f8660 },
+  (__ev64_s32__) { 0x70dad220, 0xe0e246f6 },
+  (__ev64_s32__) { 0xe0c4af54, 0x42bdf0 },
+  (__ev64_s32__) { 0xb7122b8e, 0xfa198814 },
+  (__ev64_s32__) { 0x119ac85e, 0xfc0572e0 },
+  (__ev64_s32__) { 0x98607be, 0xb18fa5a },
+  (__ev64_s32__) { 0xb65234c0, 0xd0f70158 },
+  (__ev64_s32__) { 0xf3753e0e, 0xf307f50 },
+  (__ev64_s32__) { 0x1c89fbdc, 0x35deeb44 },
+  (__ev64_s32__) { 0x149ad58, 0x5b29708 },
+  (__ev64_s32__) { 0xa0464c52, 0xa45e18 },
+  (__ev64_s32__) { 0x1c9a6f64, 0xcadbdef0 },
+  (__ev64_s32__) { 0x65fd0f34, 0xd7ad8c6 },
+  (__ev64_s32__) { 0x1415804c, 0xfafb7408 },
+  (__ev64_s32__) { 0x689978ac, 0xe8c2e364 },
+  (__ev64_s32__) { 0x326c4918, 0x1c0a9214 },
+  (__ev64_s32__) { 0xfe77839c, 0x23557ef8 },
+  (__ev64_s32__) { 0x53eeea18, 0xeb9e84b4 },
+  (__ev64_s32__) { 0xfa05abba, 0xeecec94c },
+  (__ev64_s32__) { 0xf9c2d0ac, 0x58890 },
+  (__ev64_s32__) { 0x15196868, 0x583ae360 },
+  (__ev64_s32__) { 0xee1150c, 0x16d43c20 },
+  (__ev64_s32__) { 0x24469fe0, 0xf83b3690 },
+  (__ev64_s32__) { 0xf25d2984, 0xb3adac },
+  (__ev64_s32__) { 0x78dfb50, 0x88b7e2a },
+  (__ev64_s32__) { 0xe9c22124, 0xac0626c0 },
+  (__ev64_s32__) { 0xf469e180, 0xd2426d18 },
+  (__ev64_s32__) { 0xd1aa5bae, 0xc441aec8 },
+  (__ev64_s32__) { 0xf2f2fd2c, 0xec8a3a80 },
+  (__ev64_s32__) { 0xf92e6740, 0x327f7d38 },
+  (__ev64_s32__) { 0x3345aec, 0x274597d8 },
+  (__ev64_s32__) { 0xb8a1f8ba, 0xffaa4d5a },
+  (__ev64_s32__) { 0x25f99fbc, 0xfcb63e0 },
+  (__ev64_s32__) { 0xf950286a, 0x58aad96 },
+  (__ev64_s32__) { 0x15040050, 0xde6221a0 },
+  (__ev64_s32__) { 0x1efbb344, 0x6a91086 },
+  (__ev64_s32__) { 0xce7363f4, 0xe36b03f0 },
+  (__ev64_s32__) { 0xc9f3e4b2, 0x53503268 },
+  (__ev64_s32__) { 0xd7a8938c, 0xbe6d94c8 },
+  (__ev64_s32__) { 0x2bc93f80, 0x1b5f8ecc },
+  (__ev64_s32__) { 0xb42b20bc, 0xf49cf498 },
+  (__ev64_s32__) { 0x538f0c66, 0x45215c38 },
+  (__ev64_s32__) { 0xfdae4b84, 0x19696b6c },
+  (__ev64_s32__) { 0x67f078cc, 0xf7159ec },
+  (__ev64_s32__) { 0xf5776fec, 0xfb78b644 },
+  (__ev64_s32__) { 0x438a2a64, 0x3618465a },
+  (__ev64_s32__) { 0x1bb6d2b0, 0x1ea3440 },
+  (__ev64_s32__) { 0xe241cd3c, 0xf8f09508 },
+  (__ev64_s32__) { 0xff74cfaa, 0x695b76 },
+  (__ev64_s32__) { 0x5ee5b7a, 0xffb60d08 },
+  (__ev64_s32__) { 0x96539496, 0xdb10a0b0 },
+  (__ev64_s32__) { 0xbe7e8f90, 0x5075e770 },
+  (__ev64_s32__) { 0xfc43a300, 0x1b7bafe },
+  (__ev64_s32__) { 0x5b5aba5c, 0x2e52266a },
+  (__ev64_s32__) { 0xff5c0f40, 0xe8d56e50 },
+  (__ev64_s32__) { 0xae68a00, 0xe00ed6e4 },
+  (__ev64_s32__) { 0x49d5889e, 0x1049f13a },
+  (__ev64_s32__) { 0xcadd3a5e, 0xf2afff54 },
+  (__ev64_s32__) { 0xf9b728cc, 0xedeb901c },
+  (__ev64_s32__) { 0xc5365e, 0xa494dd62 },
+  (__ev64_s32__) { 0xcfd0b87a, 0xbfaba0c },
+  (__ev64_s32__) { 0xfbf6034, 0xd3029760 },
+  (__ev64_s32__) { 0xefceaf58, 0x4d90e1b8 },
+  (__ev64_s32__) { 0xcf30e860, 0x1610be2a },
+  (__ev64_s32__) { 0xfe044200, 0x27e01c6 },
+  (__ev64_s32__) { 0xcc05a08e, 0xe871fc04 },
+  (__ev64_s32__) { 0x22dfe640, 0xe7b5b2b0 },
+  (__ev64_s32__) { 0x20a52528, 0xc6b308e4 },
+  (__ev64_s32__) { 0x599cb494, 0xf49a4d90 },
+  (__ev64_s32__) { 0xea8c7820, 0xff22707a },
+  (__ev64_s32__) { 0xfb591b8, 0xffa053a0 },
+  (__ev64_s32__) { 0xee99bdc0, 0xdbb1cb28 },
+  (__ev64_s32__) { 0xda6029d6, 0x1b3ab19c },
+  (__ev64_s32__) { 0x1e660b20, 0xe951f6da },
+  (__ev64_s32__) { 0x10f26d6e, 0xb5d01eb6 },
+  (__ev64_s32__) { 0xf996e1c8, 0xfb175550 },
+  (__ev64_s32__) { 0xe33ff51a, 0xaf62805e },
+  (__ev64_s32__) { 0x495af20, 0xbe52f78 },
+  (__ev64_s32__) { 0x71d01fa, 0xfaf07026 },
+  (__ev64_s32__) { 0xec260df4, 0x357d0b4 },
+  (__ev64_s32__) { 0x3e0caf7c, 0xf0689078 },
+  (__ev64_s32__) { 0xfbf3708c, 0xdf7dc514 },
+  (__ev64_s32__) { 0xfe0af748, 0xbd27b7c8 },
+  (__ev64_s32__) { 0xf0649a40, 0x760cb78 },
+  (__ev64_s32__) { 0xce6c552c, 0xfbeca626 },
+  (__ev64_s32__) { 0x40f0e250, 0xc7685a2 },
+  (__ev64_s32__) { 0xe19cc008, 0x4cc0573c },
+  (__ev64_s32__) { 0x163b3282, 0xfd143e80 },
+  (__ev64_s32__) { 0xf22a24, 0x2fa3d062 },
+  (__ev64_s32__) { 0xf63f4ad0, 0xfd5954d8 },
+  (__ev64_s32__) { 0x738b830, 0xdab8c2aa },
+  (__ev64_s32__) { 0x5fbcd050, 0x21b62e5e },
+  (__ev64_s32__) { 0xe0d6612c, 0x3389a372 },
+  (__ev64_s32__) { 0x114e4a36, 0x4d7ce7a },
+  (__ev64_s32__) { 0x679b33c, 0x1c047d8 },
+  (__ev64_s32__) { 0x91646722, 0x3a4bc528 },
+  (__ev64_s32__) { 0x4dfc2980, 0x31b600c0 },
+  (__ev64_s32__) { 0xc20e581e, 0x97a00a6 },
+  (__ev64_s32__) { 0xfa4424d4, 0x299a9e40 },
+  (__ev64_s32__) { 0x2d606534, 0xa51400b0 },
+  (__ev64_s32__) { 0xb921b570, 0x58d682 },
+  (__ev64_s32__) { 0x5cb7c4c, 0x9a5564 },
+  (__ev64_s32__) { 0xf84a3e98, 0x178d2068 },
+  (__ev64_s32__) { 0xa79f6a1c, 0xfa166bb0 },
+  (__ev64_s32__) { 0x1348d8b0, 0x4baf1f4 },
+  (__ev64_s32__) { 0x20123b30, 0x29f443be },
+  (__ev64_s32__) { 0x461210c0, 0x22929e52 },
+  (__ev64_s32__) { 0x120ea760, 0xfef89d0a },
+  (__ev64_s32__) { 0x994d3a00, 0xdd085604 },
+
+};
+#endif // __SPE__
+
+int evmhosmf_asm(void)
+{
+  int failures = 0;
+
+#ifdef __SPE__
+  register __ev64_s16__ regA asm ("30");
+  register __ev64_s16__ regB asm ("29");
+  register __ev64_s32__ regD asm ("28");
+
+  int32_t i;
+
+  for (i = 0; i < NELTS(rA4s16); i++) {
+
+    regA = rA4s16[i];
+    regB = rB4s16[i];
+
+    asm volatile ("evmhosmf %[d], %[a], %[b]" : [d] "=r" (regD) : [a] "r" (regA), [b] "r" (regB));
+#ifdef GEN_BASELINE
+    printf ("  (__ev64_s32__) { 0x%x, 0x%x },\n", regD[0], regD[1]);
+#else
+    VERIFY(regD[0] == (evmhosmf_baseline[i][0]));
+    VERIFY(regD[1] == (evmhosmf_baseline[i][1]));
+#endif
+  }
+#endif // __SPE__
+  return failures;
+}
+TEST_SPE_DECL(evmhosmf_asm, "evmhosmf");
+
+#ifdef __SPE__
+__ev64_s32__ *evmhosmfa_baseline = evmhosmf_baseline;
+#endif // __SPE__
+
+int evmhosmfa_asm(void)
+{
+  int failures = 0;
+
+#ifdef __SPE__
+  register __ev64_s16__ regA asm ("30");
+  register __ev64_s16__ regB asm ("29");
+  register __ev64_s32__ regD asm ("28");
+
+  int32_t i;
+
+  for (i = 0; i < NELTS(rA4s16); i++) {
+
+    // Initialize the ACC.
+    regA = (__ev64_s16__) { 0x0, 0x0, 0x0, 0x0 };
+    asm volatile ("evmra %[d], %[a]" : [d] "=r" (regD) : [a] "r" (regA));
+    VERIFY(regD[0] == 0x0);
+    VERIFY(regD[1] == 0x0);
+
+    regA = rA4s16[i];
+    regB = rB4s16[i];
+
+    asm volatile ("evmhosmfa %[d], %[a], %[b]" : [d] "=r" (regD) : [a] "r" (regA), [b] "r" (regB));
+#ifdef GEN_BASELINE
+    printf ("  (__ev64_s32__) { 0x%x, 0x%x },\n", regD[0], regD[1]);
+#else
+    VERIFY(regD[0] == evmhosmfa_baseline[i][0]);
+    VERIFY(regD[1] == evmhosmfa_baseline[i][1]);
+#endif
+    // Verify that evmhosmfa wrote into the ACC:
+    regD = (__ev64_s32__) { 0x0, 0x0 };
+    asm volatile ("evaddumiaaw %[d], %[a]"   : [d] "=r" (regD) : [a] "r" (regD));
+#ifndef GEN_BASELINE
+    VERIFY(regD[0] == evmhosmfa_baseline[i][0]);
+    VERIFY(regD[1] == evmhosmfa_baseline[i][1]);
+#endif
+  }
+
+#endif // __SPE__
+  return failures;
+}
+TEST_SPE_DECL(evmhosmfa_asm, "evmhosmfa");
+
+#ifdef __SPE__
+__ev64_s32__ evmhesmfanw_baseline[] = {
+
+  (__ev64_s32__) { 0x18bc2d08,  0x5baab9ae },
+  (__ev64_s32__) { 0x1e9fc0c2,  0x6f3759a2 },
+  (__ev64_s32__) { 0xcbddda4a,  0x426c8730 },
+  (__ev64_s32__) { 0xdb1825fa,  0x27ace390 },
+  (__ev64_s32__) { 0xb49b609a,  0xf8377f58 },
+  (__ev64_s32__) { 0xfdec497a,  0xb338f84 },
+  (__ev64_s32__) { 0xb25da11a,  0x9bc9a04 },
+  (__ev64_s32__) { 0xb6df8d16,  0xa93d502 },
+  (__ev64_s32__) { 0xbce6d7ca,  0x1cd156d6 },
+  (__ev64_s32__) { 0xb9d59f62,  0x4d814ee2 },
+  (__ev64_s32__) { 0xef98cee2,  0xdcf67a },
+  (__ev64_s32__) { 0xd9c6cbfa,  0x56cf18d0 },
+  (__ev64_s32__) { 0x9995971e,  0x52490088 },
+  (__ev64_s32__) { 0xa0817cea,  0x99625f68 },
+  (__ev64_s32__) { 0x9d7b1332,  0xa31d4d3c },
+  (__ev64_s32__) { 0xaeb4cc68,  0x98672562 },
+  (__ev64_s32__) { 0xbc2b4b68,  0xa99c5262 },
+  (__ev64_s32__) { 0xf86d64b0,  0x1a221a62 },
+  (__ev64_s32__) { 0xc3332e56,  0x70732eba },
+  (__ev64_s32__) { 0xf6537ce6,  0x8cc1722a },
+  (__ev64_s32__) { 0x165f81ba,  0x8ca7bb28 },
+  (__ev64_s32__) { 0x4fd9d6aa,  0x9499a274 },
+  (__ev64_s32__) { 0x3e7fd76a,  0xd1021f04 },
+  (__ev64_s32__) { 0x368e50da,  0xc2a63530 },
+  (__ev64_s32__) { 0x24c4f5aa,  0x971212c8 },
+  (__ev64_s32__) { 0x3dbbfe1a,  0xa0d9c9c8 },
+  (__ev64_s32__) { 0xb5980e60,  0x9b4bbbd8 },
+  (__ev64_s32__) { 0x73350ca0,  0x9a378fc0 },
+  (__ev64_s32__) { 0x762f5080,  0x9d3d07d6 },
+  (__ev64_s32__) { 0x747ddac6,  0x6759ccec },
+  (__ev64_s32__) { 0x5f5a62a4,  0x119d7f64 },
+  (__ev64_s32__) { 0x62b4af24,  0x2077f97a },
+  (__ev64_s32__) { 0x523905c4,  0xd29962ca },
+  (__ev64_s32__) { 0x155d303a,  0x4217a7a },
+  (__ev64_s32__) { 0x6eabdba,  0x4782c3a },
+  (__ev64_s32__) { 0x770993a,  0x3e7a52a },
+  (__ev64_s32__) { 0x1723fcba,  0x4440802 },
+  (__ev64_s32__) { 0xba9fbe,  0xe337e6ea },
+  (__ev64_s32__) { 0x25d4b11e,  0xd855cf3e },
+  (__ev64_s32__) { 0x247d23cc,  0xc60c8fa8 },
+  (__ev64_s32__) { 0x4f63d80,  0xcd70e95c },
+  (__ev64_s32__) { 0x1d0fb860,  0x2568c194 },
+  (__ev64_s32__) { 0x213581fc,  0x2053f660 },
+  (__ev64_s32__) { 0x11b856dc,  0x2619e686 },
+  (__ev64_s32__) { 0xf8d7db06,  0x340feae6 },
+  (__ev64_s32__) { 0x29447406,  0x3d3c3008 },
+  (__ev64_s32__) { 0x19bcc696,  0x3bf9f46c },
+  (__ev64_s32__) { 0x477627ae,  0x4c445494 },
+  (__ev64_s32__) { 0x3ca5beae,  0xb961a0f2 },
+  (__ev64_s32__) { 0x94afe44e,  0xbeeb9f64 },
+  (__ev64_s32__) { 0x8fd31e4a,  0xef8be4d4 },
+  (__ev64_s32__) { 0xd337111e,  0x7457d2e },
+  (__ev64_s32__) { 0xd50fe60a,  0x186ae642 },
+  (__ev64_s32__) { 0x763ca7b6,  0x25c6f0dc },
+  (__ev64_s32__) { 0x781b911a,  0x1877583c },
+  (__ev64_s32__) { 0x22492c66,  0x1a390fd0 },
+  (__ev64_s32__) { 0x542367ce,  0x3910cdee },
+  (__ev64_s32__) { 0x3da3b66a,  0x11cb9dce },
+  (__ev64_s32__) { 0x18a437da,  0xcf01c18a },
+  (__ev64_s32__) { 0x1652b916,  0xccc5a71c },
+  (__ev64_s32__) { 0xf30ed016,  0x11887fc },
+  (__ev64_s32__) { 0x9e9119d6,  0xfff64c },
+  (__ev64_s32__) { 0xe9b87c7e,  0xeb48c88c },
+  (__ev64_s32__) { 0xfc74bb6c,  0xf8f75672 },
+  (__ev64_s32__) { 0x35c5b038,  0xf8d5941a },
+  (__ev64_s32__) { 0x4f17549a,  0x3f80f0fe },
+  (__ev64_s32__) { 0x3e5188f8,  0x14e067fe },
+  (__ev64_s32__) { 0xf26bb378,  0x494cf04 },
+  (__ev64_s32__) { 0xc4184d6c,  0x820abd4 },
+  (__ev64_s32__) { 0xdcf96a20,  0x2bb784f0 },
+  (__ev64_s32__) { 0xf80c20a2,  0x4ab1fb60 },
+  (__ev64_s32__) { 0x8afd2698,  0x1d137360 },
+  (__ev64_s32__) { 0x6ab043c4,  0xc1685e4 },
+  (__ev64_s32__) { 0x85efd1a8,  0x10889324 },
+  (__ev64_s32__) { 0x4169fdc4,  0xe94d62e4 },
+  (__ev64_s32__) { 0x699bb150,  0xede582a4 },
+  (__ev64_s32__) { 0x67f3f65c,  0xf0230990 },
+  (__ev64_s32__) { 0x680f1234,  0xf29ed590 },
+  (__ev64_s32__) { 0x8680017c,  0x18f8b992 },
+  (__ev64_s32__) { 0x5be12044,  0xdfd5cafe },
+  (__ev64_s32__) { 0xab1fb53c,  0xcf26477e },
+  (__ev64_s32__) { 0x3debda94,  0xd0b7b206 },
+  (__ev64_s32__) { 0x2fceb52c,  0xb1cb0a86 },
+  (__ev64_s32__) { 0x1ff349ec,  0x1f6e5b72 },
+  (__ev64_s32__) { 0x282c2908,  0x206648e6 },
+  (__ev64_s32__) { 0x8577b6d8,  0x59b532e6 },
+  (__ev64_s32__) { 0x98badc48,  0x59e195cc },
+  (__ev64_s32__) { 0x2e218682,  0x589e6208 },
+  (__ev64_s32__) { 0x13f1e1be,  0x4d65bbe8 },
+  (__ev64_s32__) { 0x13a46b06,  0x4dcf5a28 },
+  (__ev64_s32__) { 0x798911e6,  0xe0eb346c },
+  (__ev64_s32__) { 0x709aa59e,  0x70e7b26c },
+  (__ev64_s32__) { 0x94fcaa76,  0x572bdb5e },
+  (__ev64_s32__) { 0x9b2a4ffe,  0x43601aa4 },
+  (__ev64_s32__) { 0xa1d54dd6,  0x4df21860 },
+  (__ev64_s32__) { 0x8aba360e,  0x63b4f64c },
+  (__ev64_s32__) { 0xa255f6d4,  0x7228e5a8 },
+  (__ev64_s32__) { 0xb2f64342,  0x8d8726b4 },
+  (__ev64_s32__) { 0xc0cd39a0,  0xacbec3fc },
+  (__ev64_s32__) { 0xdd54aa60,  0x724a0ddc },
+  (__ev64_s32__) { 0xe45e50b8,  0x3ae2644c },
+  (__ev64_s32__) { 0xd91230c0,  0x28ff4fe8 },
+  (__ev64_s32__) { 0xcaa95b52,  0xd28f4cf8 },
+  (__ev64_s32__) { 0xe07ef344,  0xdb7c13c8 },
+  (__ev64_s32__) { 0xc1ec5a16,  0xd6686788 },
+  (__ev64_s32__) { 0xc0b4f660,  0xe1706eba },
+  (__ev64_s32__) { 0xce3cc984,  0xe9ab4b7c },
+  (__ev64_s32__) { 0xd948d300,  0xc63a8c0c },
+  (__ev64_s32__) { 0xd2b530c0,  0xe3b20cd0 },
+  (__ev64_s32__) { 0x3ac7dc,  0xed2df6d8 },
+  (__ev64_s32__) { 0xa55a7cf6,  0xf1bc7918 },
+  (__ev64_s32__) { 0xa12c2bb6,  0x22a914a4 },
+  (__ev64_s32__) { 0xf16cf4c2,  0x3d56f016 },
+  (__ev64_s32__) { 0x9a6d5552,  0x45b5cb0c },
+  (__ev64_s32__) { 0xafc53a92,  0x426f4f38 },
+  (__ev64_s32__) { 0xade7d178,  0x2a987038 },
+  (__ev64_s32__) { 0x769e50f4,  0x81f19554 },
+  (__ev64_s32__) { 0x7446c71a,  0xc71fb132 },
+  (__ev64_s32__) { 0x10a61f9a,  0x10c79f52 },
+  (__ev64_s32__) { 0xf9cb9ea0,  0x214dc64c },
+  (__ev64_s32__) { 0xefe86ba2,  0x51b50c6c },
+  (__ev64_s32__) { 0x840119a6,  0x5e3124fc },
+  (__ev64_s32__) { 0xb27d717c,  0x10df8810 },
+  (__ev64_s32__) { 0xd759f19e,  0xd8c703e8 },
+  (__ev64_s32__) { 0xccf5d964,  0xdf3e6fa8 },
+  (__ev64_s32__) { 0x699ed59e,  0xdda283a8 },
+  (__ev64_s32__) { 0x37eade0e,  0xb5f1dd78 },
+  (__ev64_s32__) { 0x58fb8436,  0xa2863d4c },
+  (__ev64_s32__) { 0x83532602,  0xd8fad584 },
+  (__ev64_s32__) { 0x7538086c,  0xd43323e4 },
+  (__ev64_s32__) { 0xadaf5b90,  0xd6d15af6 },
+  (__ev64_s32__) { 0xab5f9290,  0xa8f7e5a6 },
+  (__ev64_s32__) { 0xdf1ecfe8,  0x8fdce82a },
+  (__ev64_s32__) { 0x3f2925d2,  0x904c4e86 },
+  (__ev64_s32__) { 0x2df62bf2,  0x5d444dda },
+  (__ev64_s32__) { 0x2f9623c2,  0x42e22b1a },
+  (__ev64_s32__) { 0x4c997dc0,  0x74121f2a },
+  (__ev64_s32__) { 0xfd457bd6,  0x89d8d93e },
+  (__ev64_s32__) { 0xffa1bd92,  0x47b57bcc },
+  (__ev64_s32__) { 0xff7fda9e,  0x2d114a12 },
+  (__ev64_s32__) { 0x8ecde8e,  0x21449212 },
+  (__ev64_s32__) { 0x2c3de04e,  0x17c0b13e },
+  (__ev64_s32__) { 0x2cdee2b8,  0xaf7e5842 },
+  (__ev64_s32__) { 0x261a84c0,  0xbe9663ac },
+  (__ev64_s32__) { 0xa1ea552c,  0xb3fa2c54 },
+  (__ev64_s32__) { 0xa1d2d956,  0x9a7d5fde },
+  (__ev64_s32__) { 0x8c109fc0,  0x852f48d8 },
+  (__ev64_s32__) { 0x5d1bfd80,  0x7cd902e0 },
+  (__ev64_s32__) { 0x5bc1e6b0,  0x65ee4880 },
+  (__ev64_s32__) { 0xb54a936c,  0x3e172200 },
+  (__ev64_s32__) { 0x525ceb40,  0xef147f22 },
+  (__ev64_s32__) { 0x43d6eb98,  0x159589e },
+  (__ev64_s32__) { 0x5c0d320c,  0x9fd42c2e },
+  (__ev64_s32__) { 0x17d4434c,  0xa88b234c },
+  (__ev64_s32__) { 0x43da29b4,  0xa8a410ac },
+  (__ev64_s32__) { 0x4c78a600,  0x814c73ac },
+  (__ev64_s32__) { 0xf3711f8,  0xa58342ac },
+  (__ev64_s32__) { 0xe2880b30,  0xaaf27528 },
+  (__ev64_s32__) { 0xc2791fda,  0x6054959a },
+  (__ev64_s32__) { 0xcddb073a,  0x615cad8a },
+  (__ev64_s32__) { 0xd453284a,  0x3c35ab4a },
+  (__ev64_s32__) { 0xd3a5b2aa,  0x38fcb6b2 },
+  (__ev64_s32__) { 0xff7d1d2a,  0x37c05e96 },
+  (__ev64_s32__) { 0xaa5c3c2,  0xfb7ad646 },
+  (__ev64_s32__) { 0xa372ea2,  0x26a6cc26 },
+  (__ev64_s32__) { 0xdf8d7c92,  0x73a242e },
+  (__ev64_s32__) { 0xdb149e54,  0x19f6d6a8 },
+  (__ev64_s32__) { 0x22b75004,  0x21a3d2e6 },
+  (__ev64_s32__) { 0xd40876e2,  0x8370a12 },
+  (__ev64_s32__) { 0xc23d6c7c,  0x41029de },
+  (__ev64_s32__) { 0xccae8a74,  0x9ad4299c },
+  (__ev64_s32__) { 0x9d2afcf4,  0x869b0cfc },
+  (__ev64_s32__) { 0x75603194,  0xa6ff804c },
+  (__ev64_s32__) { 0x6dee78d2,  0x98b94734 },
+  (__ev64_s32__) { 0x171f054e,  0x9780be24 },
+  (__ev64_s32__) { 0x3c4c724e,  0x99be6c28 },
+  (__ev64_s32__) { 0x2009d24e,  0xa8617f90 },
+  (__ev64_s32__) { 0xec6e6c0e,  0x9eb413e6 },
+  (__ev64_s32__) { 0xeee8f928,  0xa6f91a0e },
+  (__ev64_s32__) { 0xe9aa286c,  0xa5e58c8e },
+  (__ev64_s32__) { 0x3393ac00,  0xbf1fccee },
+  (__ev64_s32__) { 0x1d23f50,  0xb948b5a6 },
+  (__ev64_s32__) { 0x2479b510,  0x6ae01114 },
+  (__ev64_s32__) { 0x27995818,  0x946ba5b4 },
+  (__ev64_s32__) { 0x4c1e8802,  0x32498bbc },
+  (__ev64_s32__) { 0xfba5570c,  0x42246f54 },
+  (__ev64_s32__) { 0x35cbcc2c,  0xff292f16 },
+  (__ev64_s32__) { 0xdc50dcc8,  0xbd6c613e },
+  (__ev64_s32__) { 0x9c5dc3c,  0xcc2d171c },
+  (__ev64_s32__) { 0x825a37fa,  0xc36e1a54 },
+  (__ev64_s32__) { 0x647f4086,  0xbc4ce5f4 },
+  (__ev64_s32__) { 0x6cbb9f02,  0x193a5d26 },
+  (__ev64_s32__) { 0x5bdd92ee,  0x3e80a906 },
+  (__ev64_s32__) { 0x4a7938ac,  0x4a1b2cae },
+  (__ev64_s32__) { 0xab53c9dc,  0x367a033e },
+  (__ev64_s32__) { 0xb69d0538,  0x43e7c260 },
+  (__ev64_s32__) { 0xbbe6ef40,  0xa54f660 },
+  (__ev64_s32__) { 0xb79e9600,  0x5013b1c2 },
+  (__ev64_s32__) { 0x4bd19abc,  0x407d9a10 },
+  (__ev64_s32__) { 0x57b71280,  0x566a1460 },
+  (__ev64_s32__) { 0x1c0a9234,  0x4f114670 },
+  (__ev64_s32__) { 0xfd3551f0,  0x57087bb4 },
+  (__ev64_s32__) { 0x42c745c0,  0x5967f0e2 },
+  (__ev64_s32__) { 0x6cf4bdc0,  0xf9fd6bda },
+  (__ev64_s32__) { 0x6dee18c0,  0x4b1d02b2 },
+  (__ev64_s32__) { 0x42c771ce,  0xbc00b0a },
+  (__ev64_s32__) { 0x43619886,  0xa9952f4 },
+  (__ev64_s32__) { 0x2d678d9e,  0xfceb3a32 },
+  (__ev64_s32__) { 0x2ba54af6,  0x1073508 },
+  (__ev64_s32__) { 0x5320fd2e,  0x1a837a0e },
+  (__ev64_s32__) { 0xd9ed0d74,  0x5546bfe2 },
+  (__ev64_s32__) { 0xef1394f0,  0x38c0e0e },
+  (__ev64_s32__) { 0x1c56ddf4,  0x14b209b6 },
+  (__ev64_s32__) { 0xc8ac3b44,  0x16fc67a2 },
+  (__ev64_s32__) { 0xdf4d49c8,  0x4516b484 },
+  (__ev64_s32__) { 0xbb83f384,  0x39ac0aec },
+  (__ev64_s32__) { 0x776b0b96,  0x3b370e5c },
+  (__ev64_s32__) { 0x2789caf6,  0x89145ecc },
+  (__ev64_s32__) { 0x42815c66,  0x7e0bc454 },
+  (__ev64_s32__) { 0x1f188aa6,  0xb476735c },
+  (__ev64_s32__) { 0x26edbc8e,  0x852d5a88 },
+  (__ev64_s32__) { 0x6c8b08a4,  0x8a1e16f0 },
+  (__ev64_s32__) { 0x60683b78,  0xbd2432fe },
+  (__ev64_s32__) { 0x59bfab84,  0x7f342862 },
+  (__ev64_s32__) { 0x533dc9f4,  0x7ceb7af4 },
+  (__ev64_s32__) { 0x37198f84,  0x724bd3b4 },
+  (__ev64_s32__) { 0x661fdc8c,  0x85593f4c },
+  (__ev64_s32__) { 0x73a14648,  0xa548b9ce },
+  (__ev64_s32__) { 0x9497cede,  0xe856a85e },
+  (__ev64_s32__) { 0x697d575a,  0xe028c66a },
+  (__ev64_s32__) { 0x873b44ea,  0xe0ae4506 },
+  (__ev64_s32__) { 0x956befee,  0x1c76c3d6 },
+  (__ev64_s32__) { 0x7886b3a6,  0x4191b16c },
+  (__ev64_s32__) { 0x5e8ad5b8,  0x22b629bc },
+  (__ev64_s32__) { 0x505f1904,  0xfce16282 },
+  (__ev64_s32__) { 0x551e70d4,  0x1315797a },
+  (__ev64_s32__) { 0xb43e00e8,  0x2d0b8594 },
+  (__ev64_s32__) { 0xde211168,  0x36a196f0 },
+  (__ev64_s32__) { 0xc19171da,  0x315e60b8 },
+  (__ev64_s32__) { 0xb998b902,  0x3f83390c },
+  (__ev64_s32__) { 0xc31f07c0,  0x729da376 },
+  (__ev64_s32__) { 0xc46fced4,  0x847eb7f0 },
+  (__ev64_s32__) { 0xb2d92c22,  0x805d1c08 },
+  (__ev64_s32__) { 0xd122cc36,  0x70382dfa },
+  (__ev64_s32__) { 0xd1ad3ad6,  0x778e4ff6 },
+  (__ev64_s32__) { 0x8d59b15e,  0x3b831740 },
+  (__ev64_s32__) { 0xaea339fe,  0x5de6a198 },
+  (__ev64_s32__) { 0x931261f6,  0x704326d8 },
+  (__ev64_s32__) { 0xb76c5572,  0x6dd389c0 },
+  (__ev64_s32__) { 0xae7218e4,  0x762b28f8 },
+  (__ev64_s32__) { 0xd9e12042,  0x3d8311fc },
+  (__ev64_s32__) { 0xa0d54622,  0xf0f525e },
+  (__ev64_s32__) { 0xe36d092a,  0x37831070 },
+  (__ev64_s32__) { 0x23bc40ca,  0x565c5d44 },
+  (__ev64_s32__) { 0xe7973ee8,  0x7274929c },
+  (__ev64_s32__) { 0x2ced5228,  0x3cd0adb0 },
+
+};
+#endif // __SPE__
+
+int evmhesmfanw_asm(void)
+{
+  int failures = 0;
+
+#ifdef __SPE__
+  register __ev64_s16__ regA asm ("30");
+  register __ev64_s16__ regB asm ("29");
+  register __ev64_s32__ regD asm ("28");
+
+  // Initialize the ACC.
+  regA = (__ev64_s16__) { 0x0, 0x0, 0x0, 0x0 };
+  asm volatile ("evmra %[d], %[a]" : [d] "=r" (regD) : [a] "r" (regA));
+  VERIFY(regD[0] == 0x0);
+  VERIFY(regD[1] == 0x0);
+
+  int32_t i;
+
+  for (i = 0; i < NELTS(rA4s16); i++) {
+
+    regA = rA4s16[i];
+    regB = rB4s16[i];
+
+    asm volatile ("evmhesmfanw %[d], %[a], %[b]" : [d] "=r" (regD) : [a] "r" (regA), [b] "r" (regB));
+#ifdef GEN_BASELINE
+    printf ("  (__ev64_s32__) { 0x%x,  0x%x },\n", regD[0], regD[1]);
+#else
+    VERIFY(regD[0] == evmhesmfanw_baseline[i][0]);
+    VERIFY(regD[1] == evmhesmfanw_baseline[i][1]);
+#endif
+  }
+#endif // __SPE__
+  return failures;
+}
+TEST_SPE_DECL(evmhesmfanw_asm, "evmhesmfanw");
+
+#ifdef __SPE__
+__ev64_s32__ evmhesmfaaw_baseline[] = {
+
+  (__ev64_s32__) { 0xe743d2f8, 0xa4554652 },
+  (__ev64_s32__) { 0xe1603f3e, 0x90c8a65e },
+  (__ev64_s32__) { 0x342225b6, 0xbd9378d0 },
+  (__ev64_s32__) { 0x24e7da06, 0xd8531c70 },
+  (__ev64_s32__) { 0x4b649f66, 0x7c880a8 },
+  (__ev64_s32__) { 0x213b686, 0xf4cc707c },
+  (__ev64_s32__) { 0x4da25ee6, 0xf64365fc },
+  (__ev64_s32__) { 0x492072ea, 0xf56c2afe },
+  (__ev64_s32__) { 0x43192836, 0xe32ea92a },
+  (__ev64_s32__) { 0x462a609e, 0xb27eb11e },
+  (__ev64_s32__) { 0x1067311e, 0xff230986 },
+  (__ev64_s32__) { 0x26393406, 0xa930e730 },
+  (__ev64_s32__) { 0x666a68e2, 0xadb6ff78 },
+  (__ev64_s32__) { 0x5f7e8316, 0x669da098 },
+  (__ev64_s32__) { 0x6284ecce, 0x5ce2b2c4 },
+  (__ev64_s32__) { 0x514b3398, 0x6798da9e },
+  (__ev64_s32__) { 0x43d4b498, 0x5663ad9e },
+  (__ev64_s32__) { 0x7929b50, 0xe5dde59e },
+  (__ev64_s32__) { 0x3cccd1aa, 0x8f8cd146 },
+  (__ev64_s32__) { 0x9ac831a, 0x733e8dd6 },
+  (__ev64_s32__) { 0xe9a07e46, 0x735844d8 },
+  (__ev64_s32__) { 0xb0262956, 0x6b665d8c },
+  (__ev64_s32__) { 0xc1802896, 0x2efde0fc },
+  (__ev64_s32__) { 0xc971af26, 0x3d59cad0 },
+  (__ev64_s32__) { 0xdb3b0a56, 0x68eded38 },
+  (__ev64_s32__) { 0xc24401e6, 0x5f263638 },
+  (__ev64_s32__) { 0x4a67f1a0, 0x64b44428 },
+  (__ev64_s32__) { 0x8ccaf360, 0x65c87040 },
+  (__ev64_s32__) { 0x89d0af80, 0x62c2f82a },
+  (__ev64_s32__) { 0x8b82253a, 0x98a63314 },
+  (__ev64_s32__) { 0xa0a59d5c, 0xee62809c },
+  (__ev64_s32__) { 0x9d4b50dc, 0xdf880686 },
+  (__ev64_s32__) { 0xadc6fa3c, 0x2d669d36 },
+  (__ev64_s32__) { 0xeaa2cfc6, 0xfbde8586 },
+  (__ev64_s32__) { 0xf9154246, 0xfb87d3c6 },
+  (__ev64_s32__) { 0xf88f66c6, 0xfc185ad6 },
+  (__ev64_s32__) { 0xe8dc0346, 0xfbbbf7fe },
+  (__ev64_s32__) { 0xff456042, 0x1cc81916 },
+  (__ev64_s32__) { 0xda2b4ee2, 0x27aa30c2 },
+  (__ev64_s32__) { 0xdb82dc34, 0x39f37058 },
+  (__ev64_s32__) { 0xfb09c280, 0x328f16a4 },
+  (__ev64_s32__) { 0xe2f047a0, 0xda973e6c },
+  (__ev64_s32__) { 0xdeca7e04, 0xdfac09a0 },
+  (__ev64_s32__) { 0xee47a924, 0xd9e6197a },
+  (__ev64_s32__) { 0x72824fa, 0xcbf0151a },
+  (__ev64_s32__) { 0xd6bb8bfa, 0xc2c3cff8 },
+  (__ev64_s32__) { 0xe643396a, 0xc4060b94 },
+  (__ev64_s32__) { 0xb889d852, 0xb3bbab6c },
+  (__ev64_s32__) { 0xc35a4152, 0x469e5f0e },
+  (__ev64_s32__) { 0x6b501bb2, 0x4114609c },
+  (__ev64_s32__) { 0x702ce1b6, 0x10741b2c },
+  (__ev64_s32__) { 0x2cc8eee2, 0xf8ba82d2 },
+  (__ev64_s32__) { 0x2af019f6, 0xe79519be },
+  (__ev64_s32__) { 0x89c3584a, 0xda390f24 },
+  (__ev64_s32__) { 0x87e46ee6, 0xe788a7c4 },
+  (__ev64_s32__) { 0xddb6d39a, 0xe5c6f030 },
+  (__ev64_s32__) { 0xabdc9832, 0xc6ef3212 },
+  (__ev64_s32__) { 0xc25c4996, 0xee346232 },
+  (__ev64_s32__) { 0xe75bc826, 0x30fe3e76 },
+  (__ev64_s32__) { 0xe9ad46ea, 0x333a58e4 },
+  (__ev64_s32__) { 0xcf12fea, 0xfee77804 },
+  (__ev64_s32__) { 0x616ee62a, 0xff0009b4 },
+  (__ev64_s32__) { 0x16478382, 0x14b73774 },
+  (__ev64_s32__) { 0x38b4494, 0x708a98e },
+  (__ev64_s32__) { 0xca3a4fc8, 0x72a6be6 },
+  (__ev64_s32__) { 0xb0e8ab66, 0xc07f0f02 },
+  (__ev64_s32__) { 0xc1ae7708, 0xeb1f9802 },
+  (__ev64_s32__) { 0xd944c88, 0xfb6b30fc },
+  (__ev64_s32__) { 0x3be7b294, 0xf7df542c },
+  (__ev64_s32__) { 0x230695e0, 0xd4487b10 },
+  (__ev64_s32__) { 0x7f3df5e, 0xb54e04a0 },
+  (__ev64_s32__) { 0x7502d968, 0xe2ec8ca0 },
+  (__ev64_s32__) { 0x954fbc3c, 0xf3e97a1c },
+  (__ev64_s32__) { 0x7a102e58, 0xef776cdc },
+  (__ev64_s32__) { 0xbe96023c, 0x16b29d1c },
+  (__ev64_s32__) { 0x96644eb0, 0x121a7d5c },
+  (__ev64_s32__) { 0x980c09a4, 0xfdcf670 },
+  (__ev64_s32__) { 0x97f0edcc, 0xd612a70 },
+  (__ev64_s32__) { 0x797ffe84, 0xe707466e },
+  (__ev64_s32__) { 0xa41edfbc, 0x202a3502 },
+  (__ev64_s32__) { 0x54e04ac4, 0x30d9b882 },
+  (__ev64_s32__) { 0xc214256c, 0x2f484dfa },
+  (__ev64_s32__) { 0xd0314ad4, 0x4e34f57a },
+  (__ev64_s32__) { 0xe00cb614, 0xe091a48e },
+  (__ev64_s32__) { 0xd7d3d6f8, 0xdf99b71a },
+  (__ev64_s32__) { 0x7a884928, 0xa64acd1a },
+  (__ev64_s32__) { 0x674523b8, 0xa61e6a34 },
+  (__ev64_s32__) { 0xd1de797e, 0xa7619df8 },
+  (__ev64_s32__) { 0xec0e1e42, 0xb29a4418 },
+  (__ev64_s32__) { 0xec5b94fa, 0xb230a5d8 },
+  (__ev64_s32__) { 0x8676ee1a, 0x1f14cb94 },
+  (__ev64_s32__) { 0x8f655a62, 0x8f184d94 },
+  (__ev64_s32__) { 0x6b03558a, 0xa8d424a2 },
+  (__ev64_s32__) { 0x64d5b002, 0xbc9fe55c },
+  (__ev64_s32__) { 0x5e2ab22a, 0xb20de7a0 },
+  (__ev64_s32__) { 0x7545c9f2, 0x9c4b09b4 },
+  (__ev64_s32__) { 0x5daa092c, 0x8dd71a58 },
+  (__ev64_s32__) { 0x4d09bcbe, 0x7278d94c },
+  (__ev64_s32__) { 0x3f32c660, 0x53413c04 },
+  (__ev64_s32__) { 0x22ab55a0, 0x8db5f224 },
+  (__ev64_s32__) { 0x1ba1af48, 0xc51d9bb4 },
+  (__ev64_s32__) { 0x26edcf40, 0xd700b018 },
+  (__ev64_s32__) { 0x3556a4ae, 0x2d70b308 },
+  (__ev64_s32__) { 0x1f810cbc, 0x2483ec38 },
+  (__ev64_s32__) { 0x3e13a5ea, 0x29979878 },
+  (__ev64_s32__) { 0x3f4b09a0, 0x1e8f9146 },
+  (__ev64_s32__) { 0x31c3367c, 0x1654b484 },
+  (__ev64_s32__) { 0x26b72d00, 0x39c573f4 },
+  (__ev64_s32__) { 0x2d4acf40, 0x1c4df330 },
+  (__ev64_s32__) { 0xffc53824, 0x12d20928 },
+  (__ev64_s32__) { 0x5aa5830a, 0xe4386e8 },
+  (__ev64_s32__) { 0x5ed3d44a, 0xdd56eb5c },
+  (__ev64_s32__) { 0xe930b3e, 0xc2a90fea },
+  (__ev64_s32__) { 0x6592aaae, 0xba4a34f4 },
+  (__ev64_s32__) { 0x503ac56e, 0xbd90b0c8 },
+  (__ev64_s32__) { 0x52182e88, 0xd5678fc8 },
+  (__ev64_s32__) { 0x8961af0c, 0x7e0e6aac },
+  (__ev64_s32__) { 0x8bb938e6, 0x38e04ece },
+  (__ev64_s32__) { 0xef59e066, 0xef3860ae },
+  (__ev64_s32__) { 0x6346160, 0xdeb239b4 },
+  (__ev64_s32__) { 0x1017945e, 0xae4af394 },
+  (__ev64_s32__) { 0x7bfee65a, 0xa1cedb04 },
+  (__ev64_s32__) { 0x4d828e84, 0xef2077f0 },
+  (__ev64_s32__) { 0x28a60e62, 0x2738fc18 },
+  (__ev64_s32__) { 0x330a269c, 0x20c19058 },
+  (__ev64_s32__) { 0x96612a62, 0x225d7c58 },
+  (__ev64_s32__) { 0xc81521f2, 0x4a0e2288 },
+  (__ev64_s32__) { 0xa7047bca, 0x5d79c2b4 },
+  (__ev64_s32__) { 0x7cacd9fe, 0x27052a7c },
+  (__ev64_s32__) { 0x8ac7f794, 0x2bccdc1c },
+  (__ev64_s32__) { 0x5250a470, 0x292ea50a },
+  (__ev64_s32__) { 0x54a06d70, 0x57081a5a },
+  (__ev64_s32__) { 0x20e13018, 0x702317d6 },
+  (__ev64_s32__) { 0xc0d6da2e, 0x6fb3b17a },
+  (__ev64_s32__) { 0xd209d40e, 0xa2bbb226 },
+  (__ev64_s32__) { 0xd069dc3e, 0xbd1dd4e6 },
+  (__ev64_s32__) { 0xb3668240, 0x8bede0d6 },
+  (__ev64_s32__) { 0x2ba842a, 0x762726c2 },
+  (__ev64_s32__) { 0x5e426e, 0xb84a8434 },
+  (__ev64_s32__) { 0x802562, 0xd2eeb5ee },
+  (__ev64_s32__) { 0xf7132172, 0xdebb6dee },
+  (__ev64_s32__) { 0xd3c21fb2, 0xe83f4ec2 },
+  (__ev64_s32__) { 0xd3211d48, 0x5081a7be },
+  (__ev64_s32__) { 0xd9e57b40, 0x41699c54 },
+  (__ev64_s32__) { 0x5e15aad4, 0x4c05d3ac },
+  (__ev64_s32__) { 0x5e2d26aa, 0x6582a022 },
+  (__ev64_s32__) { 0x73ef6040, 0x7ad0b728 },
+  (__ev64_s32__) { 0xa2e40280, 0x8326fd20 },
+  (__ev64_s32__) { 0xa43e1950, 0x9a11b780 },
+  (__ev64_s32__) { 0x4ab56c94, 0xc1e8de00 },
+  (__ev64_s32__) { 0xada314c0, 0x10eb80de },
+  (__ev64_s32__) { 0xbc291468, 0xfea6a762 },
+  (__ev64_s32__) { 0xa3f2cdf4, 0x602bd3d2 },
+  (__ev64_s32__) { 0xe82bbcb4, 0x5774dcb4 },
+  (__ev64_s32__) { 0xbc25d64c, 0x575bef54 },
+  (__ev64_s32__) { 0xb3875a00, 0x7eb38c54 },
+  (__ev64_s32__) { 0xf0c8ee08, 0x5a7cbd54 },
+  (__ev64_s32__) { 0x1d77f4d0, 0x550d8ad8 },
+  (__ev64_s32__) { 0x3d86e026, 0x9fab6a66 },
+  (__ev64_s32__) { 0x3224f8c6, 0x9ea35276 },
+  (__ev64_s32__) { 0x2bacd7b6, 0xc3ca54b6 },
+  (__ev64_s32__) { 0x2c5a4d56, 0xc703494e },
+  (__ev64_s32__) { 0x82e2d6, 0xc83fa16a },
+  (__ev64_s32__) { 0xf55a3c3e, 0x48529ba },
+  (__ev64_s32__) { 0xf5c8d15e, 0xd95933da },
+  (__ev64_s32__) { 0x2072836e, 0xf8c5dbd2 },
+  (__ev64_s32__) { 0x24eb61ac, 0xe6092958 },
+  (__ev64_s32__) { 0xdd48affc, 0xde5c2d1a },
+  (__ev64_s32__) { 0x2bf7891e, 0xf7c8f5ee },
+  (__ev64_s32__) { 0x3dc29384, 0xfbefd622 },
+  (__ev64_s32__) { 0x3351758c, 0x652bd664 },
+  (__ev64_s32__) { 0x62d5030c, 0x7964f304 },
+  (__ev64_s32__) { 0x8a9fce6c, 0x59007fb4 },
+  (__ev64_s32__) { 0x9211872e, 0x6746b8cc },
+  (__ev64_s32__) { 0xe8e0fab2, 0x687f41dc },
+  (__ev64_s32__) { 0xc3b38db2, 0x664193d8 },
+  (__ev64_s32__) { 0xdff62db2, 0x579e8070 },
+  (__ev64_s32__) { 0x139193f2, 0x614bec1a },
+  (__ev64_s32__) { 0x111706d8, 0x5906e5f2 },
+  (__ev64_s32__) { 0x1655d794, 0x5a1a7372 },
+  (__ev64_s32__) { 0xcc6c5400, 0x40e03312 },
+  (__ev64_s32__) { 0xfe2dc0b0, 0x46b74a5a },
+  (__ev64_s32__) { 0xdb864af0, 0x951feeec },
+  (__ev64_s32__) { 0xd866a7e8, 0x6b945a4c },
+  (__ev64_s32__) { 0xb3e177fe, 0xcdb67444 },
+  (__ev64_s32__) { 0x45aa8f4, 0xbddb90ac },
+  (__ev64_s32__) { 0xca3433d4, 0xd6d0ea },
+  (__ev64_s32__) { 0x23af2338, 0x42939ec2 },
+  (__ev64_s32__) { 0xf63a23c4, 0x33d2e8e4 },
+  (__ev64_s32__) { 0x7da5c806, 0x3c91e5ac },
+  (__ev64_s32__) { 0x9b80bf7a, 0x43b31a0c },
+  (__ev64_s32__) { 0x934460fe, 0xe6c5a2da },
+  (__ev64_s32__) { 0xa4226d12, 0xc17f56fa },
+  (__ev64_s32__) { 0xb586c754, 0xb5e4d352 },
+  (__ev64_s32__) { 0x54ac3624, 0xc985fcc2 },
+  (__ev64_s32__) { 0x4962fac8, 0xbc183da0 },
+  (__ev64_s32__) { 0x441910c0, 0xf5ab09a0 },
+  (__ev64_s32__) { 0x48616a00, 0xafec4e3e },
+  (__ev64_s32__) { 0xb42e6544, 0xbf8265f0 },
+  (__ev64_s32__) { 0xa848ed80, 0xa995eba0 },
+  (__ev64_s32__) { 0xe3f56dcc, 0xb0eeb990 },
+  (__ev64_s32__) { 0x2caae10, 0xa8f7844c },
+  (__ev64_s32__) { 0xbd38ba40, 0xa6980f1e },
+  (__ev64_s32__) { 0x930b4240, 0x6029426 },
+  (__ev64_s32__) { 0x9211e740, 0xb4e2fd4e },
+  (__ev64_s32__) { 0xbd388e32, 0xf43ff4f6 },
+  (__ev64_s32__) { 0xbc9e677a, 0xf566ad0c },
+  (__ev64_s32__) { 0xd2987262, 0x314c5ce },
+  (__ev64_s32__) { 0xd45ab50a, 0xfef8caf8 },
+  (__ev64_s32__) { 0xacdf02d2, 0xe57c85f2 },
+  (__ev64_s32__) { 0x2612f28c, 0xaab9401e },
+  (__ev64_s32__) { 0x10ec6b10, 0xfc73f1f2 },
+  (__ev64_s32__) { 0xe3a9220c, 0xeb4df64a },
+  (__ev64_s32__) { 0x3753c4bc, 0xe903985e },
+  (__ev64_s32__) { 0x20b2b638, 0xbae94b7c },
+  (__ev64_s32__) { 0x447c0c7c, 0xc653f514 },
+  (__ev64_s32__) { 0x8894f46a, 0xc4c8f1a4 },
+  (__ev64_s32__) { 0xd876350a, 0x76eba134 },
+  (__ev64_s32__) { 0xbd7ea39a, 0x81f43bac },
+  (__ev64_s32__) { 0xe0e7755a, 0x4b898ca4 },
+  (__ev64_s32__) { 0xd9124372, 0x7ad2a578 },
+  (__ev64_s32__) { 0x9374f75c, 0x75e1e910 },
+  (__ev64_s32__) { 0x9f97c488, 0x42dbcd02 },
+  (__ev64_s32__) { 0xa640547c, 0x80cbd79e },
+  (__ev64_s32__) { 0xacc2360c, 0x8314850c },
+  (__ev64_s32__) { 0xc8e6707c, 0x8db42c4c },
+  (__ev64_s32__) { 0x99e02374, 0x7aa6c0b4 },
+  (__ev64_s32__) { 0x8c5eb9b8, 0x5ab74632 },
+  (__ev64_s32__) { 0x6b683122, 0x17a957a2 },
+  (__ev64_s32__) { 0x9682a8a6, 0x1fd73996 },
+  (__ev64_s32__) { 0x78c4bb16, 0x1f51bafa },
+  (__ev64_s32__) { 0x6a941012, 0xe3893c2a },
+  (__ev64_s32__) { 0x87794c5a, 0xbe6e4e94 },
+  (__ev64_s32__) { 0xa1752a48, 0xdd49d644 },
+  (__ev64_s32__) { 0xafa0e6fc, 0x31e9d7e },
+  (__ev64_s32__) { 0xaae18f2c, 0xecea8686 },
+  (__ev64_s32__) { 0x4bc1ff18, 0xd2f47a6c },
+  (__ev64_s32__) { 0x21deee98, 0xc95e6910 },
+  (__ev64_s32__) { 0x3e6e8e26, 0xcea19f48 },
+  (__ev64_s32__) { 0x466746fe, 0xc07cc6f4 },
+  (__ev64_s32__) { 0x3ce0f840, 0x8d625c8a },
+  (__ev64_s32__) { 0x3b90312c, 0x7b814810 },
+  (__ev64_s32__) { 0x4d26d3de, 0x7fa2e3f8 },
+  (__ev64_s32__) { 0x2edd33ca, 0x8fc7d206 },
+  (__ev64_s32__) { 0x2e52c52a, 0x8871b00a },
+  (__ev64_s32__) { 0x72a64ea2, 0xc47ce8c0 },
+  (__ev64_s32__) { 0x515cc602, 0xa2195e68 },
+  (__ev64_s32__) { 0x6ced9e0a, 0x8fbcd928 },
+  (__ev64_s32__) { 0x4893aa8e, 0x922c7640 },
+  (__ev64_s32__) { 0x518de71c, 0x89d4d708 },
+  (__ev64_s32__) { 0x261edfbe, 0xc27cee04 },
+  (__ev64_s32__) { 0x5f2ab9de, 0xf0f0ada2 },
+  (__ev64_s32__) { 0x1c92f6d6, 0xc87cef90 },
+  (__ev64_s32__) { 0xdc43bf36, 0xa9a3a2bc },
+  (__ev64_s32__) { 0x1868c118, 0x8d8b6d64 },
+  (__ev64_s32__) { 0xd312add8, 0xc32f5250 },
+
+};
+#endif // __SPE__
+
+int evmhesmfaaw_asm(void)
+{
+  int failures = 0;
+
+#ifdef __SPE__
+  register __ev64_s16__ regA asm ("30");
+  register __ev64_s16__ regB asm ("29");
+  register __ev64_s32__ regD asm ("28");
+
+  // Initialize the ACC.
+  regA = (__ev64_s16__) { 0x0, 0x0, 0x0, 0x0 };
+  asm volatile ("evmra %[d], %[a]" : [d] "=r" (regD) : [a] "r" (regA));
+  VERIFY(regD[0] == 0x0);
+  VERIFY(regD[1] == 0x0);
+
+  int32_t i;
+
+  for (i = 0; i < NELTS(rA4s16); i++) {
+
+    regA = rA4s16[i];
+    regB = rB4s16[i];
+
+    asm volatile ("evmhesmfaaw %[d], %[a], %[b]" : [d] "=r" (regD) : [a] "r" (regA), [b] "r" (regB));
+#ifdef GEN_BASELINE
+    printf ("  (__ev64_s32__) { 0x%x, 0x%x },\n", regD[0], regD[1]);
+#else
+    VERIFY(regD[0] == evmhesmfaaw_baseline[i][0]);
+    VERIFY(regD[1] == evmhesmfaaw_baseline[i][1]);
+#endif
+
+  }
+
+#endif // __SPE__
+  return failures;
+}
+TEST_SPE_DECL(evmhesmfaaw_asm, "evmhesmfaaw");
+
+#ifdef __SPE__
+__ev64_s32__ evmhesmf_baseline[] = {
+
+  (__ev64_s32__) { 0xe743d2f8, 0xa4554652 },
+  (__ev64_s32__) { 0xfa1c6c46, 0xec73600c },
+  (__ev64_s32__) { 0x52c1e678, 0x2ccad272 },
+  (__ev64_s32__) { 0xf0c5b450, 0x1abfa3a0 },
+  (__ev64_s32__) { 0x267cc560, 0x2f756438 },
+  (__ev64_s32__) { 0xb6af1720, 0xed03efd4 },
+  (__ev64_s32__) { 0x4b8ea860, 0x176f580 },
+  (__ev64_s32__) { 0xfb7e1404, 0xff28c502 },
+  (__ev64_s32__) { 0xf9f8b54c, 0xedc27e2c },
+  (__ev64_s32__) { 0x3113868, 0xcf5007f4 },
+  (__ev64_s32__) { 0xca3cd080, 0x4ca45868 },
+  (__ev64_s32__) { 0x15d202e8, 0xaa0dddaa },
+  (__ev64_s32__) { 0x403134dc, 0x4861848 },
+  (__ev64_s32__) { 0xf9141a34, 0xb8e6a120 },
+  (__ev64_s32__) { 0x30669b8, 0xf645122c },
+  (__ev64_s32__) { 0xeec646ca, 0xab627da },
+  (__ev64_s32__) { 0xf2898100, 0xeecad300 },
+  (__ev64_s32__) { 0xc3bde6b8, 0x8f7a3800 },
+  (__ev64_s32__) { 0x353a365a, 0xa9aeeba8 },
+  (__ev64_s32__) { 0xccdfb170, 0xe3b1bc90 },
+  (__ev64_s32__) { 0xdff3fb2c, 0x19b702 },
+  (__ev64_s32__) { 0xc685ab10, 0xf80e18b4 },
+  (__ev64_s32__) { 0x1159ff40, 0xc3978370 },
+  (__ev64_s32__) { 0x7f18690, 0xe5be9d4 },
+  (__ev64_s32__) { 0x11c95b30, 0x2b942268 },
+  (__ev64_s32__) { 0xe708f790, 0xf6384900 },
+  (__ev64_s32__) { 0x8823efba, 0x58e0df0 },
+  (__ev64_s32__) { 0x426301c0, 0x1142c18 },
+  (__ev64_s32__) { 0xfd05bc20, 0xfcfa87ea },
+  (__ev64_s32__) { 0x1b175ba, 0x35e33aea },
+  (__ev64_s32__) { 0x15237822, 0x55bc4d88 },
+  (__ev64_s32__) { 0xfca5b380, 0xf12585ea },
+  (__ev64_s32__) { 0x107ba960, 0x4dde96b0 },
+  (__ev64_s32__) { 0x3cdbd58a, 0xce77e850 },
+  (__ev64_s32__) { 0xe727280, 0xffa94e40 },
+  (__ev64_s32__) { 0xff7a2480, 0x908710 },
+  (__ev64_s32__) { 0xf04c9c80, 0xffa39d28 },
+  (__ev64_s32__) { 0x16695cfc, 0x210c2118 },
+  (__ev64_s32__) { 0xdae5eea0, 0xae217ac },
+  (__ev64_s32__) { 0x1578d52, 0x12493f96 },
+  (__ev64_s32__) { 0x1f86e64c, 0xf89ba64c },
+  (__ev64_s32__) { 0xe7e68520, 0xa80827c8 },
+  (__ev64_s32__) { 0xfbda3664, 0x514cb34 },
+  (__ev64_s32__) { 0xf7d2b20, 0xfa3a0fda },
+  (__ev64_s32__) { 0x18e07bd6, 0xf209fba0 },
+  (__ev64_s32__) { 0xcf936700, 0xf6d3bade },
+  (__ev64_s32__) { 0xf87ad70, 0x1423b9c },
+  (__ev64_s32__) { 0xd2469ee8, 0xefb59fd8 },
+  (__ev64_s32__) { 0xad06900, 0x92e2b3a2 },
+  (__ev64_s32__) { 0xa7f5da60, 0xfa76018e },
+  (__ev64_s32__) { 0x4dcc604, 0xcf5fba90 },
+  (__ev64_s32__) { 0xbc9c0d2c, 0xe84667a6 },
+  (__ev64_s32__) { 0xfe272b14, 0xeeda96ec },
+  (__ev64_s32__) { 0x5ed33e54, 0xf2a3f566 },
+  (__ev64_s32__) { 0xfe21169c, 0xd4f98a0 },
+  (__ev64_s32__) { 0x55d264b4, 0xfe3e486c },
+  (__ev64_s32__) { 0xce25c498, 0xe12841e2 },
+  (__ev64_s32__) { 0x167fb164, 0x27453020 },
+  (__ev64_s32__) { 0x24ff7e90, 0x42c9dc44 },
+  (__ev64_s32__) { 0x2517ec4, 0x23c1a6e },
+  (__ev64_s32__) { 0x2343e900, 0xcbad1f20 },
+  (__ev64_s32__) { 0x547db640, 0x1891b0 },
+  (__ev64_s32__) { 0xb4d89d58, 0x15b72dc0 },
+  (__ev64_s32__) { 0xed43c112, 0xf251721a },
+  (__ev64_s32__) { 0xc6af0b34, 0x21c258 },
+  (__ev64_s32__) { 0xe6ae5b9e, 0xb954a31c },
+  (__ev64_s32__) { 0x10c5cba2, 0x2aa08900 },
+  (__ev64_s32__) { 0x4be5d580, 0x104b98fa },
+  (__ev64_s32__) { 0x2e53660c, 0xfc742330 },
+  (__ev64_s32__) { 0xe71ee34c, 0xdc6926e4 },
+  (__ev64_s32__) { 0xe4ed497e, 0xe1058990 },
+  (__ev64_s32__) { 0x6d0efa0a, 0x2d9e8800 },
+  (__ev64_s32__) { 0x204ce2d4, 0x10fced7c },
+  (__ev64_s32__) { 0xe4c0721c, 0xfb8df2c0 },
+  (__ev64_s32__) { 0x4485d3e4, 0x273b3040 },
+  (__ev64_s32__) { 0xd7ce4c74, 0xfb67e040 },
+  (__ev64_s32__) { 0x1a7baf4, 0xfdc27914 },
+  (__ev64_s32__) { 0xffe4e428, 0xfd843400 },
+  (__ev64_s32__) { 0xe18f10b8, 0xd9a61bfe },
+  (__ev64_s32__) { 0x2a9ee138, 0x3922ee94 },
+  (__ev64_s32__) { 0xb0c16b08, 0x10af8380 },
+  (__ev64_s32__) { 0x6d33daa8, 0xfe6e9578 },
+  (__ev64_s32__) { 0xe1d2568, 0x1eeca780 },
+  (__ev64_s32__) { 0xfdb6b40, 0x925caf14 },
+  (__ev64_s32__) { 0xf7c720e4, 0xff08128c },
+  (__ev64_s32__) { 0xa2b47230, 0xc6b11600 },
+  (__ev64_s32__) { 0xecbcda90, 0xffd39d1a },
+  (__ev64_s32__) { 0x6a9955c6, 0x14333c4 },
+  (__ev64_s32__) { 0x1a2fa4c4, 0xb38a620 },
+  (__ev64_s32__) { 0x4d76b8, 0xff9661c0 },
+  (__ev64_s32__) { 0x9a1b5920, 0x6ce425bc },
+  (__ev64_s32__) { 0x8ee6c48, 0x70038200 },
+  (__ev64_s32__) { 0xdb9dfb28, 0x19bbd70e },
+  (__ev64_s32__) { 0xf9d25a78, 0x13cbc0ba },
+  (__ev64_s32__) { 0xf9550228, 0xf56e0244 },
+  (__ev64_s32__) { 0x171b17c8, 0xea3d2214 },
+  (__ev64_s32__) { 0xe8643f3a, 0xf18c10a4 },
+  (__ev64_s32__) { 0xef5fb392, 0xe4a1bef4 },
+  (__ev64_s32__) { 0xf22909a2, 0xe0c862b8 },
+  (__ev64_s32__) { 0xe3788f40, 0x3a74b620 },
+  (__ev64_s32__) { 0xf8f659a8, 0x3767a990 },
+  (__ev64_s32__) { 0xb4c1ff8, 0x11e31464 },
+  (__ev64_s32__) { 0xe68d56e, 0x567002f0 },
+  (__ev64_s32__) { 0xea2a680e, 0xf7133930 },
+  (__ev64_s32__) { 0x1e92992e, 0x513ac40 },
+  (__ev64_s32__) { 0x13763b6, 0xf4f7f8ce },
+  (__ev64_s32__) { 0xf2782cdc, 0xf7c5233e },
+  (__ev64_s32__) { 0xf4f3f684, 0x2370bf70 },
+  (__ev64_s32__) { 0x693a240, 0xe2887f3c },
+  (__ev64_s32__) { 0xd27a68e4, 0xf68415f8 },
+  (__ev64_s32__) { 0x5ae04ae6, 0xfb717dc0 },
+  (__ev64_s32__) { 0x42e5140, 0xcf136474 },
+  (__ev64_s32__) { 0xafbf36f4, 0xe552248e },
+  (__ev64_s32__) { 0x56ff9f70, 0xf7a1250a },
+  (__ev64_s32__) { 0xeaa81ac0, 0x3467bd4 },
+  (__ev64_s32__) { 0x1dd691a, 0x17d6df00 },
+  (__ev64_s32__) { 0x37498084, 0xa8a6dae4 },
+  (__ev64_s32__) { 0x25789da, 0xbad1e422 },
+  (__ev64_s32__) { 0x63a0a780, 0xb65811e0 },
+  (__ev64_s32__) { 0x16da80fa, 0xef79d906 },
+  (__ev64_s32__) { 0x9e332fe, 0xcf98b9e0 },
+  (__ev64_s32__) { 0x6be751fc, 0xf383e770 },
+  (__ev64_s32__) { 0xd183a82a, 0x4d519cec },
+  (__ev64_s32__) { 0xdb237fde, 0x38188428 },
+  (__ev64_s32__) { 0xa64183a, 0xf9889440 },
+  (__ev64_s32__) { 0x635703c6, 0x19bec00 },
+  (__ev64_s32__) { 0x31b3f790, 0x27b0a630 },
+  (__ev64_s32__) { 0xdeef59d8, 0x136ba02c },
+  (__ev64_s32__) { 0xd5a85e34, 0xc98b67c8 },
+  (__ev64_s32__) { 0xe1b1d96, 0x4c7b1a0 },
+  (__ev64_s32__) { 0xc788acdc, 0xfd61c8ee },
+  (__ev64_s32__) { 0x24fc900, 0x2dd97550 },
+  (__ev64_s32__) { 0xcc40c2a8, 0x191afd7c },
+  (__ev64_s32__) { 0x9ff5aa16, 0xff9099a4 },
+  (__ev64_s32__) { 0x1132f9e0, 0x330800ac },
+  (__ev64_s32__) { 0xfe600830, 0x1a6222c0 },
+  (__ev64_s32__) { 0xe2fca602, 0xced00bf0 },
+  (__ev64_s32__) { 0x4f5401ea, 0xea3945ec },
+  (__ev64_s32__) { 0xfda3be44, 0x42235d72 },
+  (__ev64_s32__) { 0x21e2f4, 0x1aa431ba },
+  (__ev64_s32__) { 0xf692fc10, 0xbccb800 },
+  (__ev64_s32__) { 0xdcaefe40, 0x983e0d4 },
+  (__ev64_s32__) { 0xff5efd96, 0x684258fc },
+  (__ev64_s32__) { 0x6c45df8, 0xf0e7f496 },
+  (__ev64_s32__) { 0x84302f94, 0xa9c3758 },
+  (__ev64_s32__) { 0x177bd6, 0x197ccc76 },
+  (__ev64_s32__) { 0x15c23996, 0x154e1706 },
+  (__ev64_s32__) { 0x2ef4a240, 0x85645f8 },
+  (__ev64_s32__) { 0x15a16d0, 0x16eaba60 },
+  (__ev64_s32__) { 0xa6775344, 0x27d72680 },
+  (__ev64_s32__) { 0x62eda82c, 0x4f02a2de },
+  (__ev64_s32__) { 0xe85ffa8, 0xedbb2684 },
+  (__ev64_s32__) { 0xe7c9b98c, 0x61852c70 },
+  (__ev64_s32__) { 0x4438eec0, 0xf74908e2 },
+  (__ev64_s32__) { 0xd3fa1998, 0xffe712a0 },
+  (__ev64_s32__) { 0xf76183b4, 0x27579d00 },
+  (__ev64_s32__) { 0x3d419408, 0xdbc93100 },
+  (__ev64_s32__) { 0x2caf06c8, 0xfa90cd84 },
+  (__ev64_s32__) { 0x200eeb56, 0x4a9ddf8e },
+  (__ev64_s32__) { 0xf49e18a0, 0xfef7e810 },
+  (__ev64_s32__) { 0xf987def0, 0x25270240 },
+  (__ev64_s32__) { 0xad75a0, 0x338f498 },
+  (__ev64_s32__) { 0xd4289580, 0x13c581c },
+  (__ev64_s32__) { 0xf4d75968, 0x3c458850 },
+  (__ev64_s32__) { 0x6e9520, 0xd4d40a20 },
+  (__ev64_s32__) { 0x2aa9b210, 0x1f6ca7f8 },
+  (__ev64_s32__) { 0x478de3e, 0xed434d86 },
+  (__ev64_s32__) { 0xb85d4e50, 0xf85303c2 },
+  (__ev64_s32__) { 0x4eaed922, 0x196cc8d4 },
+  (__ev64_s32__) { 0x11cb0a66, 0x426e034 },
+  (__ev64_s32__) { 0xf58ee208, 0x693c0042 },
+  (__ev64_s32__) { 0x2f838d80, 0x14391ca0 },
+  (__ev64_s32__) { 0x27cacb60, 0xdf9b8cb0 },
+  (__ev64_s32__) { 0x771b8c2, 0xe463918 },
+  (__ev64_s32__) { 0x56cf7384, 0x1388910 },
+  (__ev64_s32__) { 0xdad29300, 0xfdc251fc },
+  (__ev64_s32__) { 0x1c42a000, 0xf15cec98 },
+  (__ev64_s32__) { 0x339b6640, 0x9ad6baa },
+  (__ev64_s32__) { 0xfd8572e6, 0xf7baf9d8 },
+  (__ev64_s32__) { 0x53ed0bc, 0x1138d80 },
+  (__ev64_s32__) { 0xb6167c6c, 0xe6c5bfa0 },
+  (__ev64_s32__) { 0x31c16cb0, 0x5d71748 },
+  (__ev64_s32__) { 0xdd588a40, 0x4e68a492 },
+  (__ev64_s32__) { 0xfce05cf8, 0xd6746b60 },
+  (__ev64_s32__) { 0xdb7ad016, 0x622219f8 },
+  (__ev64_s32__) { 0x507930f6, 0xf0251c68 },
+  (__ev64_s32__) { 0xc5d98ae0, 0x42fb403e },
+  (__ev64_s32__) { 0x597aef64, 0x41bccdd8 },
+  (__ev64_s32__) { 0xd28b008c, 0xf13f4a22 },
+  (__ev64_s32__) { 0x876ba442, 0x8befcc8 },
+  (__ev64_s32__) { 0x1ddaf774, 0x7213460 },
+  (__ev64_s32__) { 0xf7c3a184, 0xa31288ce },
+  (__ev64_s32__) { 0x10de0c14, 0xdab9b420 },
+  (__ev64_s32__) { 0x11645a42, 0xf4657c58 },
+  (__ev64_s32__) { 0x9f256ed0, 0x13a12970 },
+  (__ev64_s32__) { 0xf4b6c4a4, 0xf29240de },
+  (__ev64_s32__) { 0xfab615f8, 0x3992cc00 },
+  (__ev64_s32__) { 0x4485940, 0xba41449e },
+  (__ev64_s32__) { 0x6bccfb44, 0xf9617b2 },
+  (__ev64_s32__) { 0xf41a883c, 0xea1385b0 },
+  (__ev64_s32__) { 0x3bac804c, 0x758cdf0 },
+  (__ev64_s32__) { 0x1ed54044, 0xf808cabc },
+  (__ev64_s32__) { 0xba6e0c30, 0xfda08ad2 },
+  (__ev64_s32__) { 0xd5d28800, 0x5f6a8508 },
+  (__ev64_s32__) { 0xff06a500, 0xaee06928 },
+  (__ev64_s32__) { 0x2b26a6f2, 0x3f5cf7a8 },
+  (__ev64_s32__) { 0xff65d948, 0x126b816 },
+  (__ev64_s32__) { 0x15fa0ae8, 0xdae18c2 },
+  (__ev64_s32__) { 0x1c242a8, 0xfbe4052a },
+  (__ev64_s32__) { 0xd8844dc8, 0xe683bafa },
+  (__ev64_s32__) { 0x7933efba, 0xc53cba2c },
+  (__ev64_s32__) { 0xead97884, 0x51bab1d4 },
+  (__ev64_s32__) { 0xd2bcb6fc, 0xeeda0458 },
+  (__ev64_s32__) { 0x53aaa2b0, 0xfdb5a214 },
+  (__ev64_s32__) { 0xe95ef17c, 0xd1e5b31e },
+  (__ev64_s32__) { 0x23c95644, 0xb6aa998 },
+  (__ev64_s32__) { 0x4418e7ee, 0xfe74fc90 },
+  (__ev64_s32__) { 0x4fe140a0, 0xb222af90 },
+  (__ev64_s32__) { 0xe5086e90, 0xb089a78 },
+  (__ev64_s32__) { 0x2368d1c0, 0xc99550f8 },
+  (__ev64_s32__) { 0xf82ace18, 0x2f4918d4 },
+  (__ev64_s32__) { 0xba62b3ea, 0xfb0f4398 },
+  (__ev64_s32__) { 0xc22cd2c, 0xccf9e3f2 },
+  (__ev64_s32__) { 0x6a88ff4, 0x3df00a9c },
+  (__ev64_s32__) { 0x681e190, 0x248ad6e },
+  (__ev64_s32__) { 0x1c243a70, 0xa9fa740 },
+  (__ev64_s32__) { 0xd0f9b2f8, 0xecf29468 },
+  (__ev64_s32__) { 0xf27e9644, 0xe010857e },
+  (__ev64_s32__) { 0xdf09776a, 0xbcf21170 },
+  (__ev64_s32__) { 0x2b1a7784, 0x82de1f4 },
+  (__ev64_s32__) { 0xe2421270, 0xff7a8164 },
+  (__ev64_s32__) { 0xf1cf54fc, 0xc4378130 },
+  (__ev64_s32__) { 0x1ce53c48, 0xdae5126a },
+  (__ev64_s32__) { 0x19fbddee, 0x1edb87b0 },
+  (__ev64_s32__) { 0xe2bbcb4, 0x25d4c73a },
+  (__ev64_s32__) { 0xfb40a830, 0xe9cbe908 },
+  (__ev64_s32__) { 0xa0e06fec, 0xe609f3e6 },
+  (__ev64_s32__) { 0xd61cef80, 0xf669eea4 },
+  (__ev64_s32__) { 0x1c8f9f8e, 0x5433638 },
+  (__ev64_s32__) { 0x7f8b8d8, 0xf1db27ac },
+  (__ev64_s32__) { 0xf679b142, 0xcce59596 },
+  (__ev64_s32__) { 0xfeaf38ec, 0xee1eeb86 },
+  (__ev64_s32__) { 0x1196a2b2, 0x4219be8 },
+  (__ev64_s32__) { 0xe1b65fec, 0x1024ee0e },
+  (__ev64_s32__) { 0xff759160, 0xf8a9de04 },
+  (__ev64_s32__) { 0x44538978, 0x3c0b38b6 },
+  (__ev64_s32__) { 0xdeb67760, 0xdd9c75a8 },
+  (__ev64_s32__) { 0x1b90d808, 0xeda37ac0 },
+  (__ev64_s32__) { 0xdba60c84, 0x26f9d18 },
+  (__ev64_s32__) { 0x8fa3c8e, 0xf7a860c8 },
+  (__ev64_s32__) { 0xd490f8a2, 0x38a816fc },
+  (__ev64_s32__) { 0x390bda20, 0x2e73bf9e },
+  (__ev64_s32__) { 0xbd683cf8, 0xd78c41ee },
+  (__ev64_s32__) { 0xbfb0c860, 0xe126b32c },
+  (__ev64_s32__) { 0x3c2501e2, 0xe3e7caa8 },
+  (__ev64_s32__) { 0xbaa9ecc0, 0x35a3e4ec },
+
+};
+#endif // __SPE__
+
+int evmhesmf_asm(void)
+{
+  int failures = 0;
+
+#ifdef __SPE__
+  register __ev64_s16__ regA asm ("30");
+  register __ev64_s16__ regB asm ("29");
+  register __ev64_s32__ regD asm ("28");
+
+  int32_t i;
+
+  for (i = 0; i < NELTS(rA4s16); i++) {
+
+    regA = rA4s16[i];
+    regB = rB4s16[i];
+
+    asm volatile ("evmhesmf %[d], %[a], %[b]" : [d] "=r" (regD) : [a] "r" (regA), [b] "r" (regB));
+#ifdef GEN_BASELINE
+    printf ("  (__ev64_s32__) { 0x%x, 0x%x },\n", regD[0], regD[1]);
+#else
+    VERIFY(regD[0] == evmhesmf_baseline[i][0]);
+    VERIFY(regD[1] == evmhesmf_baseline[i][1]);
+#endif
+  }
+#endif // __SPE__
+  return failures;
+}
+TEST_SPE_DECL(evmhesmf_asm, "evmhesmf");
+
+#ifdef __SPE__
+__ev64_s32__ *evmhesmfa_baseline = evmhesmf_baseline;
+#endif // __SPE__
+
+int evmhesmfa_asm(void)
+{
+  int failures = 0;
+
+#ifdef __SPE__
+  register __ev64_s16__ regA asm ("30");
+  register __ev64_s16__ regB asm ("29");
+  register __ev64_s32__ regD asm ("28");
+
+  int32_t i;
+
+  for (i = 0; i < NELTS(rA4s16); i++) {
+
+    // Initialize the ACC.
+    regA = (__ev64_s16__) { 0x0, 0x0, 0x0, 0x0 };
+    asm volatile ("evmra %[d], %[a]" : [d] "=r" (regD) : [a] "r" (regA));
+    VERIFY(regD[0] == 0x0);
+    VERIFY(regD[1] == 0x0);
+
+    regA = rA4s16[i];
+    regB = rB4s16[i];
+
+    asm volatile ("evmhesmfa %[d], %[a], %[b]" : [d] "=r" (regD) : [a] "r" (regA), [b] "r" (regB));
+#ifdef GEN_BASELINE
+    printf ("  (__ev64_s32__) { 0x%x, 0x%x },\n", regD[0], regD[1]);
+#else
+    VERIFY(regD[0] == evmhesmfa_baseline[i][0]);
+    VERIFY(regD[1] == evmhesmfa_baseline[i][1]);
+#endif
+    // Verify that evmhesmfa wrote into the ACC:
+    regD = (__ev64_s32__) { 0x0, 0x0 };
+    asm volatile ("evaddumiaaw %[d], %[a]"   : [d] "=r" (regD) : [a] "r" (regD));
+#ifndef GEN_BASELINE
+    VERIFY(regD[0] == evmhesmfa_baseline[i][0]);
+    VERIFY(regD[1] == evmhesmfa_baseline[i][1]);
+#endif
+  }
+
+#endif // __SPE__
+  return failures;
+}
+TEST_SPE_DECL(evmhesmfa_asm, "evmhesmfa");
+
 /* NOTE: To avoid having to remaster the .exp files entirely, add
  *       new test functions /just above/ this comment.
  *       That way, you only need to worry about the test that you
@@ -11087,6 +12961,14 @@ test_t spe_isa_ACC_based_fractional_multiply_insns_test_table = {
     F(evmwsmfa_asm),
     F(evmwhsmf_asm),
     F(evmwhsmfa_asm),
+    F(evmhosmfanw_asm),
+    F(evmhosmfaaw_asm),
+    F(evmhosmf_asm),
+    F(evmhosmfa_asm),
+    F(evmhesmfanw_asm),
+    F(evmhesmfaaw_asm),
+    F(evmhesmf_asm),
+    F(evmhesmfa_asm),
     NULL
   }
 };
diff --git a/memcheck/tests/ppc32/test_spe.stderr.exp b/memcheck/tests/ppc32/test_spe.stderr.exp
index c8239d1..f7acf19 100644
--- a/memcheck/tests/ppc32/test_spe.stderr.exp
+++ b/memcheck/tests/ppc32/test_spe.stderr.exp
@@ -5,7 +5,7 @@ Invalid write of size 4
    by 0x........: run (test_spe.h:43)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
  Address 0x........ is 0 bytes after a block of size 40 alloc'd
    at 0x........: malloc (vg_replace_malloc.c:...)
    by 0x........: vg_quick_start_guide_aux (test_spe.c:26)
@@ -13,7 +13,7 @@ Invalid write of size 4
    by 0x........: run (test_spe.h:43)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
 
 Invalid write of size 8
    at 0x........: evmwsmfan_asm (test_spe.c:9376)
@@ -22,7 +22,7 @@ Invalid write of size 8
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
  Address 0x........ is not stack'd, malloc'd or (recently) free'd
 
 Invalid read of size 8
@@ -32,14 +32,14 @@ Invalid read of size 8
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
  Address 0x........ is 184 bytes inside a block of size 256 free'd
    at 0x........: free (vg_replace_malloc.c:...)
    by 0x........: simple_loop (test_spe.c:333)
    by 0x........: run (test_spe.h:43)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
 
 Invalid write of size 8
    at 0x........: evmwsmfaa_asm (test_spe.c:9750)
@@ -48,7 +48,7 @@ Invalid write of size 8
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
  Address 0x........ is not stack'd, malloc'd or (recently) free'd
 
 Invalid read of size 8
@@ -58,7 +58,7 @@ Invalid read of size 8
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
  Address 0x........ is 8 bytes before a block of size 64 alloc'd
    at 0x........: calloc (vg_replace_malloc.c:...)
    by 0x........: evmwsmfan_asm (test_spe.c:9349)
@@ -67,7 +67,7 @@ Invalid read of size 8
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
 
 Invalid write of size 8
    at 0x........: evmwsmf_asm (test_spe.c:10136)
@@ -76,7 +76,7 @@ Invalid write of size 8
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
  Address 0x........ is not stack'd, malloc'd or (recently) free'd
 
 Invalid read of size 8
@@ -86,7 +86,7 @@ Invalid read of size 8
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
  Address 0x........ is 8 bytes before a block of size 64 alloc'd
    at 0x........: calloc (vg_replace_malloc.c:...)
    by 0x........: evmwsmfaa_asm (test_spe.c:9723)
@@ -95,7 +95,7 @@ Invalid read of size 8
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
 
 Invalid write of size 8
    at 0x........: evmwsmfa_asm (test_spe.c:10267)
@@ -104,7 +104,7 @@ Invalid write of size 8
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
  Address 0x........ is not stack'd, malloc'd or (recently) free'd
 
 Invalid read of size 8
@@ -114,7 +114,7 @@ Invalid read of size 8
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
  Address 0x........ is 8 bytes before a block of size 64 alloc'd
    at 0x........: calloc (vg_replace_malloc.c:...)
    by 0x........: evmwsmf_asm (test_spe.c:10109)
@@ -123,7 +123,7 @@ Invalid read of size 8
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
 
 Invalid write of size 8
    at 0x........: evmwhsmf_asm (test_spe.c:10656)
@@ -132,7 +132,7 @@ Invalid write of size 8
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
  Address 0x........ is not stack'd, malloc'd or (recently) free'd
 
 Invalid read of size 8
@@ -142,7 +142,7 @@ Invalid read of size 8
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
  Address 0x........ is 8 bytes before a block of size 64 alloc'd
    at 0x........: calloc (vg_replace_malloc.c:...)
    by 0x........: evmwsmfa_asm (test_spe.c:10229)
@@ -151,7 +151,7 @@ Invalid read of size 8
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
 
 Invalid write of size 8
    at 0x........: evmwhsmfa_asm (test_spe.c:10784)
@@ -160,7 +160,7 @@ Invalid write of size 8
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
  Address 0x........ is not stack'd, malloc'd or (recently) free'd
 
 Invalid read of size 8
@@ -170,7 +170,7 @@ Invalid read of size 8
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
  Address 0x........ is 8 bytes before a block of size 64 alloc'd
    at 0x........: calloc (vg_replace_malloc.c:...)
    by 0x........: evmwhsmf_asm (test_spe.c:10628)
@@ -179,7 +179,7 @@ Invalid read of size 8
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
 
 
 HEAP SUMMARY:
@@ -193,7 +193,7 @@ HEAP SUMMARY:
    by 0x........: run (test_spe.h:43)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
 
 16,384 bytes in 256 blocks are definitely lost in loss record ... of ...
    at 0x........: calloc (vg_replace_malloc.c:...)
@@ -203,7 +203,7 @@ HEAP SUMMARY:
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
 
 16,384 bytes in 256 blocks are definitely lost in loss record ... of ...
    at 0x........: calloc (vg_replace_malloc.c:...)
@@ -213,7 +213,7 @@ HEAP SUMMARY:
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
 
 16,384 bytes in 256 blocks are definitely lost in loss record ... of ...
    at 0x........: calloc (vg_replace_malloc.c:...)
@@ -223,7 +223,7 @@ HEAP SUMMARY:
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
 
 16,384 bytes in 256 blocks are definitely lost in loss record ... of ...
    at 0x........: calloc (vg_replace_malloc.c:...)
@@ -233,7 +233,7 @@ HEAP SUMMARY:
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
 
 16,384 bytes in 256 blocks are definitely lost in loss record ... of ...
    at 0x........: calloc (vg_replace_malloc.c:...)
@@ -243,7 +243,7 @@ HEAP SUMMARY:
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
 
 16,384 bytes in 256 blocks are definitely lost in loss record ... of ...
    at 0x........: calloc (vg_replace_malloc.c:...)
@@ -253,7 +253,7 @@ HEAP SUMMARY:
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
    by 0x........: run (test_spe.h:49)
-   by 0x........: main (test_spe.c:11299)
+   by 0x........: main (test_spe.c:13181)
 
 LEAK SUMMARY:
    definitely lost: 98,344 bytes in 1,537 blocks
diff --git a/memcheck/tests/ppc32/test_spe.stdout.exp b/memcheck/tests/ppc32/test_spe.stdout.exp
index 3696198..11ff10e 100644
--- a/memcheck/tests/ppc32/test_spe.stdout.exp
+++ b/memcheck/tests/ppc32/test_spe.stdout.exp
@@ -145,6 +145,14 @@ SPE Regression Tests: PASS
 ....evmwsmfa: PASS
 ....evmwhsmf: PASS
 ....evmwhsmfa: PASS
+....evmhosmfanw: PASS
+....evmhosmfaaw: PASS
+....evmhosmf: PASS
+....evmhosmfa: PASS
+....evmhesmfanw: PASS
+....evmhesmfaaw: PASS
+....evmhesmf: PASS
+....evmhesmfa: PASS
 ..SPE2PIM Tests: PASS
 ...Chapter 2: High-Level Language Interface: PASS
 ...Chapter 5: Programming Interface Examples: PASS
diff --git a/regtest-power7-64.log b/regtest-power7-64.log
index ccd0bb1..74fb3cb 100644
--- a/regtest-power7-64.log
+++ b/regtest-power7-64.log
@@ -461,7 +461,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -gdwarf-4 -fdebug-types-section -Wno-long-lo
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests'
-make[5]: Warning: File `.deps/xml1.Po' has modification time 73 s in the future
+make[5]: Warning: File `.deps/xml1.Po' has modification time 75 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -484,7 +484,7 @@ gcc -Winline -Wall -Wshadow -g -Wno-long-long  -Wno-pointer-sign -fno-stack-prot
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests/ppc32'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests/ppc32'
-make[5]: Warning: File `.deps/test_spe.Po' has modification time 79 s in the future
+make[5]: Warning: File `.deps/test_spe.Po' has modification time 80 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -504,7 +504,7 @@ gcc -Winline -Wall -Wshadow -g  -Winline -Wall -Wshadow -g -I../../../include -m
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests/ppc64'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/memcheck/tests/ppc64'
-make[5]: Warning: File `.deps/power_ISA2_05-power_ISA2_05.Po' has modification time 79 s in the future
+make[5]: Warning: File `.deps/power_ISA2_05-power_ISA2_05.Po' has modification time 80 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -605,7 +605,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -fPIC -Wno-long-long  -Wno-pointer-sign -fno
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/cachegrind/tests'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/cachegrind/tests'
-make[5]: Warning: File `.deps/myprint_so-myprint.Po' has modification time 79 s in the future
+make[5]: Warning: File `.deps/myprint_so-myprint.Po' has modification time 80 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -656,7 +656,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/callgrind/tests'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/callgrind/tests'
-make[5]: Warning: File `.deps/threads.Po' has modification time 79 s in the future
+make[5]: Warning: File `.deps/threads.Po' has modification time 80 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -764,7 +764,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[4]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/massif/tests'
 make  check-local
 make[4]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/massif/tests'
-make[4]: Warning: File `.deps/zero.Po' has modification time 79 s in the future
+make[4]: Warning: File `.deps/zero.Po' has modification time 80 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1226,7 +1226,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Winline -Wall -O -lm -g -mregnames -DHAS_DF
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests/ppc64'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests/ppc64'
-make[5]: Warning: File `.deps/twi_tdi.Po' has modification time 72 s in the future
+make[5]: Warning: File `.deps/twi_tdi.Po' has modification time 77 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1255,7 +1255,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests/linux'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/none/tests/linux'
-make[5]: Warning: File `.deps/mremap3.Po' has modification time 79 s in the future
+make[5]: Warning: File `.deps/mremap3.Po' has modification time 80 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1628,7 +1628,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wextra -Wno-inline -Wno-unused-parameter -W
 make[4]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/drd/tests'
 make  check-local
 make[4]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/drd/tests'
-make[4]: Warning: File `.deps/unit_vc-unit_vc.Po' has modification time 73 s in the future
+make[4]: Warning: File `.deps/unit_vc-unit_vc.Po' has modification time 74 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1689,7 +1689,7 @@ gcc -Winline -Wall -Wshadow -g -m64 -Wno-long-long  -Wno-pointer-sign -fno-stack
 make[4]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/exp-sgcheck/tests'
 make  check-local
 make[4]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/exp-sgcheck/tests'
-make[4]: Warning: File `.deps/stackerr.Po' has modification time 79 s in the future
+make[4]: Warning: File `.deps/stackerr.Po' has modification time 80 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1759,7 +1759,7 @@ gcc -Winline -Wall -Wshadow -g -Wno-long-long  -Wno-pointer-sign -fno-stack-prot
 make[5]: Leaving directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/exp-bbv/tests/ppc32-linux'
 make  check-local
 make[5]: Entering directory `/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/exp-bbv/tests/ppc32-linux'
-make[5]: Warning: File `.deps/million.Po' has modification time 79 s in the future
+make[5]: Warning: File `.deps/million.Po' has modification time 80 s in the future
 for f in ; do \
   if [ ! -e $f.dSYM  -o  $f -nt $f.dSYM ] ; then \
       echo "dsymutil $f"; \
@@ -1980,7 +1980,7 @@ badfree-2trace:  valgrind   --num-callers=2 -q ./badfree
 badfree:         valgrind   -q ./badfree 
 badfree3:        valgrind   -q --fullpath-after=/proj/ppc/DT/labhome/anmol/valgrind-3.8.1/ ./badfree 
 badjump:         valgrind   ./badjump 
-sh: line 1: 29767 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck ./badjump > badjump.stdout.out 2> badjump.stderr.out
+sh: line 1:  2712 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck ./badjump > badjump.stdout.out 2> badjump.stderr.out
 badjump2:        valgrind   -q ./badjump2 
 badloop:         valgrind   -q ./badloop 
 badpoll:         valgrind   -q ./badpoll 
@@ -1997,7 +1997,7 @@ clo_redzone_default: valgrind   --leak-check=no -q ./clo_redzone
 custom-overlap:  valgrind   --leak-check=summary -q ./custom-overlap 
 custom_alloc:    valgrind   -q ./custom_alloc 
 deep-backtrace:  valgrind   -q --num-callers=500 ./deep-backtrace 
-sh: line 1: 30327 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --num-callers=500 ./deep-backtrace > deep-backtrace.stdout.out 2> deep-backtrace.stderr.out
+sh: line 1: 13444 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --num-callers=500 ./deep-backtrace > deep-backtrace.stdout.out 2> deep-backtrace.stderr.out
 deep_templates:  valgrind   -q ./deep_templates 
 describe-block:  valgrind   ./describe-block 
 doublefree:      valgrind   -q ./doublefree 
@@ -2110,7 +2110,7 @@ supp-dir:        valgrind   --suppressions=x86/ ./../../tests/true
 supp1:           valgrind   --suppressions=supp.supp -q ./supp1 
 supp2:           valgrind   --suppressions=supp.supp -q ./supp2 
 supp_unknown:    valgrind   -q --suppressions=supp_unknown.supp ./badjump 
-sh: line 1:  2745 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --suppressions=supp_unknown.supp ./badjump > supp_unknown.stdout.out 2> supp_unknown.stderr.out
+sh: line 1: 32662 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --suppressions=supp_unknown.supp ./badjump > supp_unknown.stdout.out 2> supp_unknown.stderr.out
 *** supp_unknown failed (stderr) ***
 suppfree:        valgrind   --suppressions=suppfree.supp -q ./suppfree 
 test-plo-no:     valgrind   -q ./test-plo 
@@ -2246,7 +2246,7 @@ gxx304:          valgrind   ./gxx304
 ifunc:           (skipping, prereq failed: test -e ifunc)
 -- Running  tests in none/tests/linux ----------------------------------
 blockfault:      valgrind   ./blockfault 
-sh: line 1:  7227 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=none ./blockfault > blockfault.stdout.out 2> blockfault.stderr.out
+sh: line 1:  4523 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=none ./blockfault > blockfault.stdout.out 2> blockfault.stderr.out
 mremap:          valgrind   ./mremap 
 mremap2:         valgrind   ./mremap2 
 mremap3:         valgrind   ./mremap3 
@@ -2412,7 +2412,7 @@ tc20_verifywrap: valgrind   --read-var-info=yes ./tc20_verifywrap
 *** tc20_verifywrap failed (stderr) ***
 tc21_pthonce:    valgrind   --read-var-info=yes ./tc21_pthonce 
 tc22_exit_w_lock: valgrind   ./tc22_exit_w_lock 
-sh: line 1: 24642 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=helgrind ./tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
+sh: line 1: 12611 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=helgrind ./tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
 tc23_bogus_condwait: valgrind   ./tc23_bogus_condwait 
 tc24_nonzero_sem: valgrind   --hg-sanity-flags=111111 ./tc24_nonzero_sem 
 -- Finished tests in helgrind/tests ------------------------------------
@@ -2531,7 +2531,7 @@ tc18_semabuse:   valgrind   ./../../helgrind/tests/tc18_semabuse
 tc19_shadowmem:  valgrind   --error-limit=no --read-var-info=yes --show-confl-seg=no --num-callers=3 ./../../helgrind/tests/tc19_shadowmem 
 tc21_pthonce:    valgrind   --num-callers=3 ./../../helgrind/tests/tc21_pthonce 
 tc22_exit_w_lock: valgrind   --num-callers=3 ./../../helgrind/tests/tc22_exit_w_lock 
-sh: line 1: 29997 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=drd --num-callers=3 ./../../helgrind/tests/tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
+sh: line 1: 18032 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=drd --num-callers=3 ./../../helgrind/tests/tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
 tc23_bogus_condwait: valgrind   --num-callers=3 ./../../helgrind/tests/tc23_bogus_condwait 
 tc24_nonzero_sem: valgrind   --read-var-info=yes ./../../helgrind/tests/tc24_nonzero_sem 
 thread_name:     valgrind   --read-var-info=yes --check-stack-var=yes --num-callers=3 ./thread_name 
-- 
1.7.3.4

