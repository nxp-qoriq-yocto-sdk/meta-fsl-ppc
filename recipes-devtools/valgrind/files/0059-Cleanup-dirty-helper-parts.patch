From 79afad85eb3af80e507ac27ccd69f3637da8eb31 Mon Sep 17 00:00:00 2001
From: Anmol P. Paralkar <anmol@freescale.com>
Date: Tue, 14 May 2013 13:42:13 -0700
Subject: [PATCH 59/65] Cleanup dirty helper parts.

---
 VEX/priv/guest_ppc_defs.h           |  159 +----
 VEX/priv/guest_ppc_helpers.c        | 1437 ++++-------------------------------
 VEX/priv/guest_ppc_toIR.c           |  738 +-----------------
 regtest-power7-64.default-build.log |   12 +-
 regtest-power7-64.log               |   12 +-
 5 files changed, 207 insertions(+), 2151 deletions(-)

diff --git a/VEX/priv/guest_ppc_defs.h b/VEX/priv/guest_ppc_defs.h
index b21c49f..a9fbd16 100644
--- a/VEX/priv/guest_ppc_defs.h
+++ b/VEX/priv/guest_ppc_defs.h
@@ -157,137 +157,6 @@ extern void ppc64g_dirtyhelper_LVS ( VexGuestPPC64State* gst,
                                      UInt vD_idx, UInt sh,
                                      UInt shift_right );
 
-extern void spe_dirtyhelper_evmwsmfan ( VexGuestPPC32State* gst,
-                                        UInt ACC_off,
-                                        UInt rD_off,
-                                        UInt rA_off,
-                                        UInt rB_off);
-extern void spe_dirtyhelper_evmwsmfaa ( VexGuestPPC32State* gst,
-                                        UInt ACC_off,
-                                        UInt rD_off,
-                                        UInt rA_off,
-                                        UInt rB_off);
-extern void spe_dirtyhelper_evmwsmfa ( VexGuestPPC32State* gst,
-                                       UInt ACC_off,
-                                       UInt rD_off,
-                                       UInt rA_off,
-                                       UInt rB_off);
-extern void spe_dirtyhelper_evmwsmf ( VexGuestPPC32State* gst,
-                                      UInt rD_off,
-                                      UInt rA_off,
-                                      UInt rB_off);
-extern void spe_dirtyhelper_evmwhsmfa ( VexGuestPPC32State* gst,
-                                        UInt ACC_off,
-                                        UInt rD_off,
-                                        UInt rA_off,
-                                        UInt rB_off);
-extern void spe_dirtyhelper_evmwhsmf ( VexGuestPPC32State* gst,
-                                       UInt rD_off,
-                                       UInt rA_off,
-                                       UInt rB_off);
-extern void spe_dirtyhelper_evmhosmfanw ( VexGuestPPC32State* gst,
-                                          UInt ACC_off,
-                                          UInt rD_off,
-                                          UInt rA_off,
-                                          UInt rB_off);
-extern void spe_dirtyhelper_evmhosmfaaw ( VexGuestPPC32State* gst,
-                                          UInt ACC_off,
-                                          UInt rD_off,
-                                          UInt rA_off,
-                                          UInt rB_off);
-extern void spe_dirtyhelper_evmhosmfa ( VexGuestPPC32State* gst,
-                                        UInt ACC_off,
-                                        UInt rD_off,
-                                        UInt rA_off,
-                                        UInt rB_off);
-extern void spe_dirtyhelper_evmhosmf ( VexGuestPPC32State* gst,
-                                       UInt rD_off,
-                                       UInt rA_off,
-                                       UInt rB_off);
-extern void spe_dirtyhelper_evmhesmfanw ( VexGuestPPC32State* gst,
-                                          UInt ACC_off,
-                                          UInt rD_off,
-                                          UInt rA_off,
-                                          UInt rB_off);
-extern void spe_dirtyhelper_evmhesmfaaw ( VexGuestPPC32State* gst,
-                                          UInt ACC_off,
-                                          UInt rD_off,
-                                          UInt rA_off,
-                                          UInt rB_off);
-extern void spe_dirtyhelper_evmhesmfa ( VexGuestPPC32State* gst,
-                                        UInt ACC_off,
-                                        UInt rD_off,
-                                        UInt rA_off,
-                                        UInt rB_off);
-extern void spe_dirtyhelper_evmhesmf ( VexGuestPPC32State* gst,
-                                       UInt rD_off,
-                                       UInt rA_off,
-                                       UInt rB_off);
-extern void spe_dirtyhelper_evmhogsmfan ( VexGuestPPC32State* gst,
-                                          UInt ACC_off,
-                                          UInt rD_off,
-                                          UInt rA_off,
-                                          UInt rB_off);
-extern void spe_dirtyhelper_evmhogsmfaa ( VexGuestPPC32State* gst,
-                                          UInt ACC_off,
-                                          UInt rD_off,
-                                          UInt rA_off,
-                                          UInt rB_off);
-extern void spe_dirtyhelper_evmhegsmfan ( VexGuestPPC32State* gst,
-                                          UInt ACC_off,
-                                          UInt rD_off,
-                                          UInt rA_off,
-                                          UInt rB_off);
-extern void spe_dirtyhelper_evmhegsmfaa ( VexGuestPPC32State* gst,
-                                          UInt ACC_off,
-                                          UInt rD_off,
-                                          UInt rA_off,
-                                          UInt rB_off);
-extern void spe_dirtyhelper_evmhegsmiaa ( VexGuestPPC32State* gst,
-                                          UInt ACC_off,
-                                          UInt rD_off,
-                                          UInt rA_off,
-                                          UInt rB_off);
-extern void spe_dirtyhelper_evmhegsmian ( VexGuestPPC32State* gst,
-                                          UInt ACC_off,
-                                          UInt rD_off,
-                                          UInt rA_off,
-                                          UInt rB_off);
-extern void spe_dirtyhelper_evmhegumiaa ( VexGuestPPC32State* gst,
-                                          UInt ACC_off,
-                                          UInt rD_off,
-                                          UInt rA_off,
-                                          UInt rB_off);
-extern void spe_dirtyhelper_evmhegumian ( VexGuestPPC32State* gst,
-                                          UInt ACC_off,
-                                          UInt rD_off,
-                                          UInt rA_off,
-                                          UInt rB_off);
-extern void spe_dirtyhelper_evmhogsmiaa ( VexGuestPPC32State* gst,
-                                          UInt ACC_off,
-                                          UInt rD_off,
-                                          UInt rA_off,
-                                          UInt rB_off);
-extern void spe_dirtyhelper_evmhogsmian ( VexGuestPPC32State* gst,
-                                          UInt ACC_off,
-                                          UInt rD_off,
-                                          UInt rA_off,
-                                          UInt rB_off);
-extern void spe_dirtyhelper_evmhogumiaa ( VexGuestPPC32State* gst,
-                                          UInt ACC_off,
-                                          UInt rD_off,
-                                          UInt rA_off,
-                                          UInt rB_off);
-extern void spe_dirtyhelper_evmhogumian ( VexGuestPPC32State* gst,
-                                          UInt ACC_off,
-                                          UInt rD_off,
-                                          UInt rA_off,
-                                          UInt rB_off);
-extern void spe_dirtyhelper_mfspefscr ( VexGuestPPC32State* gst,
-                                        UInt rD_off );
-extern void spe_dirtyhelper_mtspefscr ( VexGuestPPC32State* gst,
-                                        UInt rD_off );
-
 #define SPE_DIRTY_HELPER_DECL_crfDrArB(insn) \
 extern UInt spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt rA_off, UInt rB_off );
 
@@ -306,6 +175,32 @@ extern void spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt ACC_off, UInt
 #define SPE_DIRTY_HELPER_DECL_ACCrDrA(insn) \
 extern void spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt ACC_off, UInt rD_off, UInt rA_off);
 
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmwsmfan);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmwsmfaa);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmwsmfa);
+SPE_DIRTY_HELPER_DECL_rDrArB(evmwsmf);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmwhsmfa);
+SPE_DIRTY_HELPER_DECL_rDrArB(evmwhsmf);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhosmfanw);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhosmfaaw);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhosmfa);
+SPE_DIRTY_HELPER_DECL_rDrArB(evmhosmf);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhesmfanw);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhesmfaaw);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhesmfa);
+SPE_DIRTY_HELPER_DECL_rDrArB(evmhesmf);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhogsmfan);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhogsmfaa);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhegsmfan);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhegsmfaa);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhegsmiaa);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhegsmian);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhegumiaa);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhegumian);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhogsmiaa);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhogsmian);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhogumiaa);
+SPE_DIRTY_HELPER_DECL_ACCrDrArB(evmhogumian);
 SPE_DIRTY_HELPER_DECL_crfDrArB(efdcmpeq);
 SPE_DIRTY_HELPER_DECL_rDrA(efdabs);
 SPE_DIRTY_HELPER_DECL_rDrArB(efdadd);
@@ -410,6 +305,8 @@ SPE_DIRTY_HELPER_DECL_ACCrDrA(evaddssiaaw);
 SPE_DIRTY_HELPER_DECL_ACCrDrA(evaddusiaaw);
 SPE_DIRTY_HELPER_DECL_rDrArB(evdivws);
 SPE_DIRTY_HELPER_DECL_rDrArB(evdivwu);
+extern void spe_dirtyhelper_mfspefscr ( VexGuestPPC32State* gst, UInt rD_off );
+extern void spe_dirtyhelper_mtspefscr ( VexGuestPPC32State* gst, UInt rD_off );
 
 #endif /* ndef __VEX_GUEST_PPC_DEFS_H */
 
diff --git a/VEX/priv/guest_ppc_helpers.c b/VEX/priv/guest_ppc_helpers.c
index 59924fb..74bc23f 100644
--- a/VEX/priv/guest_ppc_helpers.c
+++ b/VEX/priv/guest_ppc_helpers.c
@@ -184,297 +184,6 @@ void ppc64g_dirtyhelper_LVS ( VexGuestPPC64State* gst,
   (*pU128_dst)[3] = (*pU128_src)[3];
 }
 
-/*---------------------------------------------------------------*/
-/*---                       SPE helpers.                      ---*/
-/*---------------------------------------------------------------*/
-
-#ifdef __SPE__
-#include <spe.h>
-#endif
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmwsmfan ( VexGuestPPC32State* gst,
-                                 UInt ACC_off,
-                                 UInt rD_off,
-                                 UInt rA_off,
-                                 UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmwsmfan (Vector Multiply Word Signed, Modulo, Fractional and Accumulate Negative, SPEPEM p5-201)
-
-  // Note: Starting with GPR30 gives this GCC (4.6.2) error:
-  // error: 31 cannot be used in asm here
-  // BTW, the reason we're explicitly assigning registers is that we absolutely want each of these
-  // variables in a register, guaranteed.
-  // BTW, If we (did not include spe.h and instead of using __ev64_s64__ as the type, use Long as the
-  // type for rA, rB; with GCC (4.6.2) r29 gets clobbered - it is defined once for rA and then again for
-  // rB before the asm () for the evmwsmf! :) Definitely a GCC (4.6.2) bug.
-  register __ev64_s64__ rA asm ("29") = (__ev64_s64__) { 0x0 };
-  register __ev64_s64__ rB asm ("28") = (__ev64_s64__) { 0x0 };
-  register __ev64_s64__ rT asm ("27") = (__ev64_s64__) { 0x0 };
-
-  __ev64_s64__ ACC;
-  __ev64_s64__ rD;
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = (__ev64_s64__) { *((Long *) ((UChar *) gst + ACC_off)) };;
-  rA  = (__ev64_s64__) { *((Long *) ((UChar *) gst + rA_off)) };
-  rB  = (__ev64_s64__) { *((Long *) ((UChar *) gst + rB_off)) };
-
-  // rT <- rA[32:63] Xsf rB[32:63]
-  asm volatile ("evmwsmf %[t], %[a], %[b]" : [t] "=r" (rT) : [a] "r" (rA), [b] "r" (rB));
-
-  // rD[0:63] <- ACC[0:63] - rT[0:63]
-  rD = (__ev64_s64__) { (Long) ((Long) ACC - (Long) rT) };
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[0:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmwsmfaa ( VexGuestPPC32State* gst,
-                                 UInt ACC_off,
-                                 UInt rD_off,
-                                 UInt rA_off,
-                                 UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmwsmfaa (Vector Multiply Word Signed, Modulo, Fractional and Accumulate, SPEPEM p5-200)
-
-  // Note: Starting with GPR30 gives this GCC (4.6.2) error:
-  // error: 31 cannot be used in asm here
-  // BTW, the reason we're explicitly assigning registers is that we absolutely want each of these
-  // variables in a register, guaranteed.
-  // BTW, If we (did not include spe.h and instead of using __ev64_s64__ as the type, use Long as the
-  // type for rA, rB; with GCC (4.6.2) r29 gets clobbered - it is defined once for rA and then again for
-  // rB before the asm () for the evmwsmf! :) Definitely a GCC (4.6.2) bug.
-  register __ev64_s64__ rA asm ("29") = (__ev64_s64__) { 0x0 };
-  register __ev64_s64__ rB asm ("28") = (__ev64_s64__) { 0x0 };
-  register __ev64_s64__ rT asm ("27") = (__ev64_s64__) { 0x0 };
-
-  __ev64_s64__ ACC;
-  __ev64_s64__ rD;
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = (__ev64_s64__) { *((Long *) ((UChar *) gst + ACC_off)) };;
-  rA  = (__ev64_s64__) { *((Long *) ((UChar *) gst + rA_off)) };
-  rB  = (__ev64_s64__) { *((Long *) ((UChar *) gst + rB_off)) };
-
-  // rT <- rA[32:63] Xsf rB[32:63]
-  asm volatile ("evmwsmf %[t], %[a], %[b]" : [t] "=r" (rT) : [a] "r" (rA), [b] "r" (rB));
-
-  // rD[0:63] <- ACC[0:63] + rT[0:63]
-  rD = (__ev64_s64__) { (Long) ((Long) ACC + (Long) rT) };
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[0:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmwsmfa ( VexGuestPPC32State* gst,
-                                 UInt ACC_off,
-                                 UInt rD_off,
-                                 UInt rA_off,
-                                 UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmwsmfa (Vector Multiply Word Signed, Modulo, Fractional to Accumulator, SPEPEM p5-199)
-
-  // Note: Starting with GPR30 gives this GCC (4.6.2) error:
-  // error: 31 cannot be used in asm here
-  // BTW, the reason we're explicitly assigning registers is that we absolutely want each of these
-  // variables in a register, guaranteed.
-  // BTW, If we (did not include spe.h and instead of using __ev64_s64__ as the type, use Long as the
-  // type for rA, rB; with GCC (4.6.2) r29 gets clobbered - it is defined once for rA and then again for
-  // rB before the asm () for the evmwsmf! :) Definitely a GCC (4.6.2) bug.
-  register __ev64_s64__ rA asm ("29") = (__ev64_s64__) { 0x0 };
-  register __ev64_s64__ rB asm ("28") = (__ev64_s64__) { 0x0 };
-
-  __ev64_s64__ ACC;
-  __ev64_s64__ rD;
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read rA, rB from the Guest State:
-  rA  = (__ev64_s64__) { *((Long *) ((UChar *) gst + rA_off)) };
-  rB  = (__ev64_s64__) { *((Long *) ((UChar *) gst + rB_off)) };
-
-  // rD <- rA[32:63] Xsf rB[32:63]
-  asm volatile ("evmwsmf %[t], %[a], %[b]" : [t] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[0:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmwsmf ( VexGuestPPC32State* gst,
-                                 UInt rD_off,
-                                 UInt rA_off,
-                                 UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmwsmfa (Vector Multiply Word Signed, Modulo, Fractional to Accumulator, SPEPEM p5-199)
-
-  // Note: Starting with GPR30 gives this GCC (4.6.2) error:
-  // error: 31 cannot be used in asm here
-  // BTW, the reason we're explicitly assigning registers is that we absolutely want each of these
-  // variables in a register, guaranteed.
-  // BTW, If we (did not include spe.h and instead of using __ev64_s64__ as the type, use Long as the
-  // type for rA, rB; with GCC (4.6.2) r29 gets clobbered - it is defined once for rA and then again for
-  // rB before the asm () for the evmwsmf! :) Definitely a GCC (4.6.2) bug.
-  register __ev64_s64__ rA asm ("29") = (__ev64_s64__) { 0x0 };
-  register __ev64_s64__ rB asm ("28") = (__ev64_s64__) { 0x0 };
-
-  __ev64_s64__ rD;
-
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read rA, rB from the Guest State:
-  rA  = (__ev64_s64__) { *((Long *) ((UChar *) gst + rA_off)) };
-  rB  = (__ev64_s64__) { *((Long *) ((UChar *) gst + rB_off)) };
-
-  // rD <- rA[32:63] Xsf rB[32:63]
-  asm volatile ("evmwsmf %[t], %[a], %[b]" : [t] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmwhsmfa ( VexGuestPPC32State* gst,
-                                 UInt ACC_off,
-                                 UInt rD_off,
-                                 UInt rA_off,
-                                 UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmwhsmfa (Vector Multiply Word High Signed, Modulo, Fractional (to Accumulator), SPEPEM p5-184)
-
-  // Note: Starting with GPR30 gives this GCC (4.6.2) error:
-  // error: 31 cannot be used in asm here
-  // BTW, the reason we're explicitly assigning registers is that we absolutely want each of these
-  // variables in a register, guaranteed.
-  // BTW, If we (did not include spe.h and instead of using __ev64_s64__ as the type, use Long as the
-  // type for rA, rB; with GCC (4.6.2) r29 gets clobbered - it is defined once for rA and then again for
-  // rB before the asm () for the evmwsmf! :) Definitely a GCC (4.6.2) bug.
-  register __ev64_s64__ rA asm ("29") = (__ev64_s64__) { 0x0 };
-  register __ev64_s64__ rB asm ("28") = (__ev64_s64__) { 0x0 };
-
-  __ev64_s64__ ACC;
-  __ev64_s64__ rD;
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = (__ev64_s64__) { *((Long *) ((UChar *) gst + ACC_off)) };;
-  rA  = (__ev64_s64__) { *((Long *) ((UChar *) gst + rA_off)) };
-  rB  = (__ev64_s64__) { *((Long *) ((UChar *) gst + rB_off)) };
-
-  // rD <- rA[32:63] Xsf rB[32:63]
-  asm volatile ("evmwhsmf %[t], %[a], %[b]" : [t] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[0:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmwhsmf ( VexGuestPPC32State* gst,
-                                UInt rD_off,
-                                UInt rA_off,
-                                UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmwhsmf (Vector Multiply Word High Signed, Modulo, Fractional, SPEPEM p5-184)
-
-  // Note: Starting with GPR30 gives this GCC (4.6.2) error:
-  // error: 31 cannot be used in asm here
-  // BTW, the reason we're explicitly assigning registers is that we absolutely want each of these
-  // variables in a register, guaranteed.
-  // BTW, If we (did not include spe.h and instead of using __ev64_s64__ as the type, use Long as the
-  // type for rA, rB; with GCC (4.6.2) r29 gets clobbered - it is defined once for rA and then again for
-  // rB before the asm () for the evmwsmf! :) Definitely a GCC (4.6.2) bug.
-  register __ev64_s64__ rA asm ("29") = (__ev64_s64__) { 0x0 };
-  register __ev64_s64__ rB asm ("28") = (__ev64_s64__) { 0x0 };
-
-  __ev64_s64__ rD;
-
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read rA, rB from the Guest State:
-  rA  = (__ev64_s64__) { *((Long *) ((UChar *) gst + rA_off)) };
-  rB  = (__ev64_s64__) { *((Long *) ((UChar *) gst + rB_off)) };
-
-  // rD <- rA[32:63] Xsf rB[32:63]
-  asm volatile ("evmwhsmf %[t], %[a], %[b]" : [t] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-#endif // __SPE__
-  return;
-}
-
 /* Helper-function specialiser. */
 
 IRExpr* guest_ppc32_spechelper ( HChar* function_name,
@@ -493,911 +202,13 @@ IRExpr* guest_ppc64_spechelper ( HChar* function_name,
    return NULL;
 }
 
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhosmfanw ( VexGuestPPC32State* gst,
-                                   UInt ACC_off,
-                                   UInt rD_off,
-                                   UInt rA_off,
-                                   UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhosmfanw (Vector Multiply Half Words, Odd, Signed, Modulo, Fractional
-  // and Accumulate Negative into Words, SPEPEM p5-168)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rT  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-  register __ev64_opaque__ rD  asm ("25");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = __ev_create_s64 (*((Long *) ((UChar *) gst + ACC_off)));
-  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // rT[00:31] <- rA[16:31] Xsf rB[16:31]
-  // rT[32:63] <- rA[48:63] Xsf rB[48:63]
-  asm volatile ("evmhosmf %[t], %[a], %[b]" : [t] "=r" (rT) : [a] "r" (rA), [b] "r" (rB));
-
-  // rD[00:31] <- ACC[00:31] - rT[00:31]
-  rD = __ev_set_upper_s32 (rD, __ev_get_upper_s32(ACC) - __ev_get_upper_s32(rT));
-  // rD[32:63] <- ACC[32:63] - rT[32:63]
-  rD = __ev_set_lower_s32 (rD, __ev_get_lower_s32(ACC) - __ev_get_lower_s32(rT));
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[0:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhosmfaaw ( VexGuestPPC32State* gst,
-                                   UInt ACC_off,
-                                   UInt rD_off,
-                                   UInt rA_off,
-                                   UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhosmfaaw (Vector Multiply Half Words, Odd, Signed, Modulo, Fractional
-  // and Accumulate into Words, SPEPEM p5-167)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rT  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-  register __ev64_opaque__ rD  asm ("25");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = __ev_create_s64 (*((Long *) ((UChar *) gst + ACC_off)));
-  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // rT[00:31] <- rA[16:31] Xsf rB[16:31]
-  // rT[32:63] <- rA[48:63] Xsf rB[48:63]
-  asm volatile ("evmhosmf %[t], %[a], %[b]" : [t] "=r" (rT) : [a] "r" (rA), [b] "r" (rB));
-
-  // rD[00:31] <- ACC[00:31] + rT[00:31]
-  rD = __ev_set_upper_s32 (rD, __ev_get_upper_s32(ACC) + __ev_get_upper_s32(rT));
-  // rD[32:63] <- ACC[32:63] + rT[32:63]
-  rD = __ev_set_lower_s32 (rD, __ev_get_lower_s32(ACC) + __ev_get_lower_s32(rT));
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[0:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhosmfa ( VexGuestPPC32State* gst,
-                                 UInt ACC_off,
-                                 UInt rD_off,
-                                 UInt rA_off,
-                                 UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhosmfa (Vector Multiply Half Words, Odd, Signed, Modulo, Fractional (to Accumulator), SPEPEM p5-166)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rD  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read rA, rB from the Guest State:
-  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // rD[00:31] <- rA[16:31] Xsf rB[16:31]
-  // rD[32:63] <- rA[48:63] Xsf rB[48:63]
-  asm volatile ("evmhosmf %[t], %[a], %[b]" : [t] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[0:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhosmf ( VexGuestPPC32State* gst,
-                                UInt rD_off,
-                                UInt rA_off,
-                                UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhosmf (Vector Multiply Half Words, Odd, Signed, Modulo, Fractional, SPEPEM p5-166)
-
-  register __ev64_opaque__ rA asm ("29");
-  register __ev64_opaque__ rB asm ("28");
-  register __ev64_opaque__ rD asm ("27");
-
-  vassert(rD_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read rA, rB from the Guest State:
-  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // rD[00:31] <- rA[16:31] Xsf rB[16:31]
-  // rD[32:63] <- rA[48:63] Xsf rB[48:63]
-  asm volatile ("evmhosmf %[t], %[a], %[b]" : [t] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhesmfanw ( VexGuestPPC32State* gst,
-                                   UInt ACC_off,
-                                   UInt rD_off,
-                                   UInt rA_off,
-                                   UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhesmfanw (Vector Multiply Half Words, Even, Signed, Modulo, Fractional
-  // and Accumulate Negative into Words, SPEPEM p5-146)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rT  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-  register __ev64_opaque__ rD  asm ("25");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = __ev_create_s64 (*((Long *) ((UChar *) gst + ACC_off)));
-  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // rT[00:31] <- rA[00:15] Xsf rB[00:15]
-  // rT[32:63] <- rA[32:47] Xsf rB[32:47]
-  asm volatile ("evmhesmf %[t], %[a], %[b]" : [t] "=r" (rT) : [a] "r" (rA), [b] "r" (rB));
-
-  // rD[00:31] <- ACC[00:31] - rT[00:31]
-  rD = __ev_set_upper_s32 (rD, __ev_get_upper_s32(ACC) - __ev_get_upper_s32(rT));
-  // rD[32:63] <- ACC[32:63] - rT[32:63]
-  rD = __ev_set_lower_s32 (rD, __ev_get_lower_s32(ACC) - __ev_get_lower_s32(rT));
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[00:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhesmfaaw ( VexGuestPPC32State* gst,
-                                   UInt ACC_off,
-                                   UInt rD_off,
-                                   UInt rA_off,
-                                   UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhesmfaaw (Vector Multiply Half Words, Even, Signed, Modulo, Fractional
-  // and Accumulate into Words, SPEPEM p5-167)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rT  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-  register __ev64_opaque__ rD  asm ("25");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = __ev_create_s64 (*((Long *) ((UChar *) gst + ACC_off)));
-  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // rT[00:31] <- rA[00:15] Xsf rB[00:15]
-  // rT[32:63] <- rA[32:47] Xsf rB[32:47]
-  asm volatile ("evmhesmf %[t], %[a], %[b]" : [t] "=r" (rT) : [a] "r" (rA), [b] "r" (rB));
-
-  // rD[00:31] <- ACC[00:31] + rT[00:31]
-  rD = __ev_set_upper_s32 (rD, __ev_get_upper_s32(ACC) + __ev_get_upper_s32(rT));
-  // rD[32:63] <- ACC[32:63] + rT[32:63]
-  rD = __ev_set_lower_s32 (rD, __ev_get_lower_s32(ACC) + __ev_get_lower_s32(rT));
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[0:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhesmfa ( VexGuestPPC32State* gst,
-                                 UInt ACC_off,
-                                 UInt rD_off,
-                                 UInt rA_off,
-                                 UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhesmfa (Vector Multiply Half Words, Even, Signed, Modulo, Fractional (to Accumulator), SPEPEM p5-166)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rD  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read rA, rB from the Guest State:
-  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // rD[00:31] <- rA[00:15] Xsf rB[00:15]
-  // rD[32:63] <- rA[32:47] Xsf rB[32:47]
-  asm volatile ("evmhesmf %[t], %[a], %[b]" : [t] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[0:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhesmf ( VexGuestPPC32State* gst,
-                                UInt rD_off,
-                                UInt rA_off,
-                                UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhesmf (Vector Multiply Half Words, Even, Signed, Modulo, Fractional, SPEPEM p5-166)
-
-  register __ev64_opaque__ rA asm ("29");
-  register __ev64_opaque__ rB asm ("28");
-  register __ev64_opaque__ rD asm ("27");
-
-  vassert(rD_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read rA, rB from the Guest State:
-  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // rD[00:31] <- rA[00:15] Xsf rB[00:15]
-  // rD[32:63] <- rA[32:47] Xsf rB[32:47]
-  asm volatile ("evmhesmf %[t], %[a], %[b]" : [t] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhogsmfan ( VexGuestPPC32State* gst,
-                                   UInt ACC_off,
-                                   UInt rD_off,
-                                   UInt rA_off,
-                                   UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhogsmfan (Vector Multiply Half Words, Odd, Guarded, Signed, Modulo, Fractional
-  // and Accumulate Negative, SPEPEM p5-161)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rD  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = __ev_create_s64 (*((Long *) ((UChar *) gst + ACC_off)));
-  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // Since evmhogsmfan reads the ACC, get the guest state ACC value into
-  // the hard ACC:
-  asm volatile ("evmra %[d], %[acc]" : [d] "=r" (rD) : [acc] "r" (ACC));
-
-  // rD[0:63] <- ACC[0:63] - EXTS (rA[48:63] Xsf rB[48:63])
-  // (hard) ACC[0:63] <- rD[0:63]
-  asm volatile ("evmhogsmfan %[d], %[a], %[b]" : [d] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[00:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhogsmfaa ( VexGuestPPC32State* gst,
-                                   UInt ACC_off,
-                                   UInt rD_off,
-                                   UInt rA_off,
-                                   UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhogsmfaa (Vector Multiply Half Words, Odd, Guarded, Signed, Modulo, Fractional
-  // and Accumulate, SPEPEM p5-160)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rD  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = __ev_create_s64 (*((Long *) ((UChar *) gst + ACC_off)));
-  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // Since evmhogsmfaa reads the ACC, get the guest state ACC value into
-  // the hard ACC:
-  asm volatile ("evmra %[d], %[acc]" : [d] "=r" (rD) : [acc] "r" (ACC));
-
-  // rD[0:63] <- ACC[0:63] + EXTS (rA[48:63] Xsf rB[48:63])
-  // (hard) ACC[0:63] <- rD[0:63]
-  asm volatile ("evmhogsmfaa %[d], %[a], %[b]" : [d] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[00:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhegsmfan ( VexGuestPPC32State* gst,
-                                   UInt ACC_off,
-                                   UInt rD_off,
-                                   UInt rA_off,
-                                   UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhegsmfan (Vector Multiply Half Words, Even, Guarded, Signed, Modulo, Fractional
-  // and Accumulate Negative, SPEPEM p5-139)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rD  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = __ev_create_s64 (*((Long *) ((UChar *) gst + ACC_off)));
-  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // Since evmhegsmfan reads the ACC, get the guest state ACC value into
-  // the hard ACC:
-  asm volatile ("evmra %[d], %[acc]" : [d] "=r" (rD) : [acc] "r" (ACC));
-
-  // rD[0:63] <- ACC[0:63] - EXTS (rA[48:63] Xsf rB[48:63])
-  // (hard) ACC[0:63] <- rD[0:63]
-  asm volatile ("evmhegsmfan %[d], %[a], %[b]" : [d] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[00:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhegsmfaa ( VexGuestPPC32State* gst,
-                                   UInt ACC_off,
-                                   UInt rD_off,
-                                   UInt rA_off,
-                                   UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhegsmfaa (Vector Multiply Half Words, Even, Guarded, Signed, Modulo, Fractional
-  // and Accumulate, SPEPEM p5-138)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rD  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = __ev_create_s64 (*((Long *) ((UChar *) gst + ACC_off)));
-  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // Since evmhegsmfaa reads the ACC, get the guest state ACC value into
-  // the hard ACC:
-  asm volatile ("evmra %[d], %[acc]" : [d] "=r" (rD) : [acc] "r" (ACC));
-
-  // rD[0:63] <- ACC[0:63] + EXTS (rA[48:63] Xsf rB[48:63])
-  // (hard) ACC[0:63] <- rD[0:63]
-  asm volatile ("evmhegsmfaa %[d], %[a], %[b]" : [d] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[00:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhegsmiaa ( VexGuestPPC32State* gst,
-                                   UInt ACC_off,
-                                   UInt rD_off,
-                                   UInt rA_off,
-                                   UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhegsmiaa (Vector Multiply Half Words, Even, Guarded, Signed, Modulo, Integer
-  // and Accumulate, SPEPEM p5-140)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rD  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = __ev_create_s64 (*((Long *) ((UChar *) gst + ACC_off)));
-  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // Since evmhegsmiaa reads the ACC, get the guest state ACC value into
-  // the hard ACC:
-  asm volatile ("evmra %[d], %[acc]" : [d] "=r" (rD) : [acc] "r" (ACC));
-
-  // rD[0:63] <- ACC[0:63] + EXTS (rA[32:47] Xsi rB[32:47])
-  // (hard) ACC[0:63] <- rD[0:63]
-  asm volatile ("evmhegsmiaa %[d], %[a], %[b]" : [d] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[00:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhegsmian ( VexGuestPPC32State* gst,
-                                   UInt ACC_off,
-                                   UInt rD_off,
-                                   UInt rA_off,
-                                   UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhegsmian (Vector Multiply Half Words, Even, Guarded, Signed, Modulo, Integer
-  // and Accumulate Negative, SPEPEM p5-141)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rD  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = __ev_create_s64 (*((Long *) ((UChar *) gst + ACC_off)));
-  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // Since evmhegsmian reads the ACC, get the guest state ACC value into
-  // the hard ACC:
-  asm volatile ("evmra %[d], %[acc]" : [d] "=r" (rD) : [acc] "r" (ACC));
-
-  // rD[0:63] <- ACC[0:63] - EXTS (rA[32:47] Xsi rB[32:47])
-  // (hard) ACC[0:63] <- rD[0:63]
-  asm volatile ("evmhegsmian %[d], %[a], %[b]" : [d] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[00:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhegumiaa ( VexGuestPPC32State* gst,
-                                   UInt ACC_off,
-                                   UInt rD_off,
-                                   UInt rA_off,
-                                   UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhegumiaa (Vector Multiply Half Words, Even, Guarded, Unsigned, Modulo, Integer
-  // and Accumulate, SPEPEM p5-142)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rD  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = __ev_create_u64 (*((Long *) ((UChar *) gst + ACC_off)));
-  rA  = __ev_create_u64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_u64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // Since evmhegumiaa reads the ACC, get the guest state ACC value into
-  // the hard ACC:
-  asm volatile ("evmra %[d], %[acc]" : [d] "=r" (rD) : [acc] "r" (ACC));
-
-  // rD[0:63] <- ACC[0:63] + EXTZ (rA[32:47] Xui rB[32:47])
-  // (hard) ACC[0:63] <- rD[0:63]
-  asm volatile ("evmhegumiaa %[d], %[a], %[b]" : [d] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_u64 (rD);
-
-  // ACC[00:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_u64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhegumian ( VexGuestPPC32State* gst,
-                                   UInt ACC_off,
-                                   UInt rD_off,
-                                   UInt rA_off,
-                                   UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhegumian (Vector Multiply Half Words, Even, Guarded, Unsigned, Modulo, Integer
-  // and Accumulate Negative, SPEPEM p5-143)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rD  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = __ev_create_u64 (*((Long *) ((UChar *) gst + ACC_off)));
-  rA  = __ev_create_u64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_u64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // Since evmhegumian reads the ACC, get the guest state ACC value into
-  // the hard ACC:
-  asm volatile ("evmra %[d], %[acc]" : [d] "=r" (rD) : [acc] "r" (ACC));
-
-  // rD[0:63] <- ACC[0:63] - EXTZ (rA[32:47] Xui rB[32:47])
-  // (hard) ACC[0:63] <- rD[0:63]
-  asm volatile ("evmhegumian %[d], %[a], %[b]" : [d] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_u64 (rD);
-
-  // ACC[00:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_u64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhogsmiaa ( VexGuestPPC32State* gst,
-                                   UInt ACC_off,
-                                   UInt rD_off,
-                                   UInt rA_off,
-                                   UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhogsmiaa (Vector Multiply Half Words, Odd, Guarded, Signed, Modulo, Integer
-  // and Accumulate, SPEPEM p5-162)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rD  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = __ev_create_s64 (*((Long *) ((UChar *) gst + ACC_off)));
-  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // Since evmhogsmiaa reads the ACC, get the guest state ACC value into
-  // the hard ACC:
-  asm volatile ("evmra %[d], %[acc]" : [d] "=r" (rD) : [acc] "r" (ACC));
-
-  // rD[0:63] <- ACC[0:63] + EXTS (rA[48:63] Xsi rB[48:63])
-  // (hard) ACC[0:63] <- rD[0:63]
-  asm volatile ("evmhogsmiaa %[d], %[a], %[b]" : [d] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[00:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhogsmian ( VexGuestPPC32State* gst,
-                                   UInt ACC_off,
-                                   UInt rD_off,
-                                   UInt rA_off,
-                                   UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhogsmian (Vector Multiply Half Words, Odd, Guarded, Signed, Modulo, Integer
-  // and Accumulate Negative, SPEPEM p5-163)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rD  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = __ev_create_s64 (*((Long *) ((UChar *) gst + ACC_off)));
-  rA  = __ev_create_s64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_s64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // Since evmhogsmian reads the ACC, get the guest state ACC value into
-  // the hard ACC:
-  asm volatile ("evmra %[d], %[acc]" : [d] "=r" (rD) : [acc] "r" (ACC));
-
-  // rD[0:63] <- ACC[0:63] - EXTS (rA[48:63] Xsi rB[48:63])
-  // (hard) ACC[0:63] <- rD[0:63]
-  asm volatile ("evmhogsmian %[d], %[a], %[b]" : [d] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_s64 (rD);
-
-  // ACC[00:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_s64 (ACC);
-#endif // __SPE__
-  return;
-}
-
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhogumiaa ( VexGuestPPC32State* gst,
-                                   UInt ACC_off,
-                                   UInt rD_off,
-                                   UInt rA_off,
-                                   UInt rB_off)
-{
-#ifdef __SPE__
-
-  // evmhogumiaa (Vector Multiply Half Words, Odd, Guarded, Unsigned, Modulo, Integer
-  // and Accumulate, SPEPEM p5-164)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rD  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = __ev_create_u64 (*((Long *) ((UChar *) gst + ACC_off)));
-  rA  = __ev_create_u64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_u64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // Since evmhogumiaa reads the ACC, get the guest state ACC value into
-  // the hard ACC:
-  asm volatile ("evmra %[d], %[acc]" : [d] "=r" (rD) : [acc] "r" (ACC));
-
-  // rD[0:63] <- ACC[0:63] + EXTZ (rA[48:63] Xui rB[48:63])
-  // (hard) ACC[0:63] <- rD[0:63]
-  asm volatile ("evmhogumiaa %[d], %[a], %[b]" : [d] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_u64 (rD);
-
-  // ACC[00:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_u64 (ACC);
-#endif // __SPE__
-  return;
-}
+/*---------------------------------------------------------------*/
+/*---                    SPE helpers begin.                   ---*/
+/*---------------------------------------------------------------*/
 
-/* CALLED FROM GENERATED CODE */
-/* DIRTY HELPER (reads guest state, writes guest state) */
-void spe_dirtyhelper_evmhogumian ( VexGuestPPC32State* gst,
-                                   UInt ACC_off,
-                                   UInt rD_off,
-                                   UInt rA_off,
-                                   UInt rB_off)
-{
 #ifdef __SPE__
-
-  // evmhogumian (Vector Multiply Half Words, Odd, Guarded, Unsigned, Modulo, Integer
-  // and Accumulate Negative, SPEPEM p5-165)
-
-  register __ev64_opaque__ rA  asm ("29");
-  register __ev64_opaque__ rB  asm ("28");
-  register __ev64_opaque__ rD  asm ("27");
-  register __ev64_opaque__ ACC asm ("26");
-
-  vassert(ACC_off <= sizeof(VexGuestPPC32State) - sizeof(ULong));
-  vassert(rD_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rA_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-  vassert(rB_off  <= sizeof(VexGuestPPC32State) - 2 * sizeof(UInt));
-
-  // Read ACC, rA, rB from the Guest State:
-  ACC = __ev_create_u64 (*((Long *) ((UChar *) gst + ACC_off)));
-  rA  = __ev_create_u64 (*((Long *) ((UChar *) gst + rA_off)));
-  rB  = __ev_create_u64 (*((Long *) ((UChar *) gst + rB_off)));
-
-  // Since evmhogumian reads the ACC, get the guest state ACC value into
-  // the hard ACC:
-  asm volatile ("evmra %[d], %[acc]" : [d] "=r" (rD) : [acc] "r" (ACC));
-
-  // rD[0:63] <- ACC[0:63] - EXTZ (rA[48:63] Xui rB[48:63])
-  // (hard) ACC[0:63] <- rD[0:63]
-  asm volatile ("evmhogumian %[d], %[a], %[b]" : [d] "=r" (rD) : [a] "r" (rA), [b] "r" (rB));
-
-  // Write rD to the Guest State:
-  *((Long *) ((UChar *) gst + rD_off)) = __ev_convert_u64 (rD);
-
-  // ACC[00:63] <- rD[0:63]
-  ACC = rD;
-  // Write ACC to the Guest State:
-  *((Long *) ((UChar *) gst + ACC_off)) = __ev_convert_u64 (ACC);
-#endif // __SPE__
-  return;
-}
+#include <spe.h>
+#endif
 
 /* CALLED FROM GENERATED CODE */
 /* DIRTY HELPER (reads guest state, writes guest state) */
@@ -1434,6 +245,13 @@ void spe_dirtyhelper_mtspefscr ( VexGuestPPC32State* gst,
 
 /* CALLED FROM GENERATED CODE */
 /* DIRTY HELPER (reads guest state, writes guest state) */
+/* Note: Starting with GPR30 gives this GCC (4.6.2) error:
+   error: 31 cannot be used in asm here
+   BTW, the reason we're explicitly assigning registers is that we absolutely want each of these
+   variables in a register, guaranteed.
+   BTW, If we (did not include spe.h and instead of using __ev64_s64__ as the type, use Long as the
+   type for rA, rB; with GCC (4.6.2) r29 gets clobbered - it is defined once for rA and then again for
+   rB before the asm () for the evmwsmf! :) Definitely a GCC (4.6.2) bug.  */
 #ifdef __SPE__
 #define SPE_DIRTY_HELPER_DEFN_crfDrArB(insn, rA_type, rB_type)                    \
 UInt spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt rA_off, UInt rB_off ) \
@@ -1529,80 +347,6 @@ void spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt rD_off, UInt rB_off
 #define SPE_DIRTY_HELPER_DEFN_rDrA(insn, rD_type, rA_type) \
         SPE_DIRTY_HELPER_DEFN_rDrB(insn, rD_type, rA_type)
 
-SPE_DIRTY_HELPER_DEFN_rDrA(efdabs,        __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrArB(efdadd,      __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efdcfs,        __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efdcfsf,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efdcfsi,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efdcfuf,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efdcfui,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(efdcmpeq,  __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(efdcmpgt,  __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(efdcmplt,  __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efdctsf,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efdctsi,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efdctsiz,      __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efdctuf,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efdctui,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efdctuiz,      __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrArB(efddiv,      __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrArB(efdmul,      __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrA(efdnabs,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrA(efdneg,        __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrArB(efdsub,      __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(efdtsteq,  __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(efdtstgt,  __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(efdtstlt,  __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrA(efsabs,        __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrArB(efsadd,      __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efscfd,        __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efscfsf,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efscfsi,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efscfuf,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efscfui,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(efscmpeq,  __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(efscmpgt,  __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(efscmplt,  __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efsctsf,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efsctsi,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efsctsiz,      __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efsctuf,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efsctui,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(efsctuiz,      __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrArB(efsdiv,      __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrArB(efsmul,      __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrA(efsnabs,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrA(efsneg,        __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrArB(efssub,      __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(efststeq,  __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(efststgt,  __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(efststlt,  __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrA(evfsabs,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrArB(evfsadd,     __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(evfscfsf,      __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(evfscfsi,      __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(evfscfuf,      __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(evfscfui,      __ev64_opaque__, __ev64_opaque__)
-#undef EXTRACT_CMP_RES
-#define EXTRACT_CMP_RES(cr) ((cr) & 0xf)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(evfscmpeq, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(evfscmpgt, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(evfscmplt, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(evfsctsf,      __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(evfsctsi,      __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(evfsctsiz,     __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(evfsctuf,      __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(evfsctui,      __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrB(evfsctuiz,     __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrArB(evfsdiv,     __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrArB(evfsmul,     __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrA(evfsnabs,      __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrA(evfsneg,       __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_rDrArB(evfssub,     __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(evfststeq, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(evfststgt, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_crfDrArB(evfststlt, __ev64_opaque__, __ev64_opaque__)
-
 #ifdef __SPE__
 #define SPE_DIRTY_HELPER_DEFN_ACCrDrArB(insn, rD_type, rA_type, rB_type, reads_acc, writes_acc)             \
 void spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt ACC_off, UInt rD_off, UInt rA_off, UInt rB_off) \
@@ -1646,33 +390,6 @@ void spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt ACC_off, UInt rD_off
 { return; }
 #endif // __SPE__
 
-SPE_DIRTY_HELPER_DEFN_rDrArB(evmhessf,       __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhessfa,   __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 0, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhessfaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhessfanw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhessiaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhessianw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmheusiaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmheusianw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-SPE_DIRTY_HELPER_DEFN_rDrArB(evmhossf,       __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhossfa,   __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 0, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhossfaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhossfanw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhossiaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhossianw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhousiaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhousianw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-SPE_DIRTY_HELPER_DEFN_rDrArB(evmwhssf,       __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwhssfa,   __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 0, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwlssiaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwlssianw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwlusiaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwlusianw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-SPE_DIRTY_HELPER_DEFN_rDrArB(evmwssf,        __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwssfa,    __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 0, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwssfaa,   __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwssfan,   __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
-
 #ifdef __SPE__
 #define SPE_DIRTY_HELPER_DEFN_ACCrDrA(insn, rD_type, rA_type, reads_acc, writes_acc)           \
 void spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt ACC_off, UInt rD_off, UInt rA_off) \
@@ -1713,14 +430,142 @@ void spe_dirtyhelper_##insn ( VexGuestPPC32State* gst, UInt ACC_off, UInt rD_off
 { return; }
 #endif // __SPE__
 
+SPE_DIRTY_HELPER_DEFN_rDrA(efdabs,           __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrArB(efdadd,         __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efdcfs,           __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efdcfsf,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efdcfsi,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efdcfuf,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efdcfui,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(efdcmpeq,     __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(efdcmpgt,     __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(efdcmplt,     __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efdctsf,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efdctsi,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efdctsiz,         __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efdctuf,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efdctui,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efdctuiz,         __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrArB(efddiv,         __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrArB(efdmul,         __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrA(efdnabs,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrA(efdneg,           __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrArB(efdsub,         __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(efdtsteq,     __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(efdtstgt,     __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(efdtstlt,     __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrA(efsabs,           __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrArB(efsadd,         __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efscfd,           __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efscfsf,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efscfsi,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efscfuf,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efscfui,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(efscmpeq,     __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(efscmpgt,     __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(efscmplt,     __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efsctsf,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efsctsi,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efsctsiz,         __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efsctuf,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efsctui,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(efsctuiz,         __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrArB(efsdiv,         __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrArB(efsmul,         __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrA(efsnabs,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrA(efsneg,           __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrArB(efssub,         __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(efststeq,     __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(efststgt,     __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(efststlt,     __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrA(evfsabs,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrArB(evfsadd,        __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(evfscfsf,         __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(evfscfsi,         __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(evfscfuf,         __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(evfscfui,         __ev64_opaque__, __ev64_opaque__)
+#undef EXTRACT_CMP_RES
+#define EXTRACT_CMP_RES(cr) ((cr) & 0xf)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(evfscmpeq,    __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(evfscmpgt,    __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(evfscmplt,    __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(evfsctsf,         __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(evfsctsi,         __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(evfsctsiz,        __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(evfsctuf,         __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(evfsctui,         __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrB(evfsctuiz,        __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrArB(evfsdiv,        __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrArB(evfsmul,        __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrA(evfsnabs,         __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrA(evfsneg,          __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrArB(evfssub,        __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(evfststeq,    __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(evfststgt,    __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_crfDrArB(evfststlt,    __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwsmfan,   __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwsmfaa,   __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwsmfa,    __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 0, 1)
+SPE_DIRTY_HELPER_DEFN_rDrArB(evmwsmf,        __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwhsmfa,   __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 0, 1)
+SPE_DIRTY_HELPER_DEFN_rDrArB(evmwhsmf,       __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhosmfanw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhosmfaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhosmfa,   __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 0, 1)
+SPE_DIRTY_HELPER_DEFN_rDrArB(evmhosmf,       __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhesmfanw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhesmfaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhesmfa,   __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 0, 1)
+SPE_DIRTY_HELPER_DEFN_rDrArB(evmhesmf,       __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhogsmfan, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhogsmfaa, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhegsmfan, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhegsmfaa, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhegsmiaa, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhegsmian, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhegumiaa, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhegumian, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhogsmiaa, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhogsmian, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhogumiaa, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhogumian, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_rDrArB(evmhessf,       __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhessfa,   __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 0, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhessfaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhessfanw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhessiaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhessianw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmheusiaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmheusianw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_rDrArB(evmhossf,       __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhossfa,   __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 0, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhossfaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhossfanw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhossiaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhossianw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhousiaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmhousianw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_rDrArB(evmwhssf,       __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwhssfa,   __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 0, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwlssiaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwlssianw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwlusiaaw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwlusianw, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_rDrArB(evmwssf,        __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwssfa,    __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 0, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwssfaa,   __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
+SPE_DIRTY_HELPER_DEFN_ACCrDrArB(evmwssfan,   __ev64_opaque__, __ev64_opaque__, __ev64_opaque__, 1, 1)
 SPE_DIRTY_HELPER_DEFN_ACCrDrA(evsubfssiaaw,  __ev64_opaque__, __ev64_opaque__, 1, 1)
 SPE_DIRTY_HELPER_DEFN_ACCrDrA(evsubfusiaaw,  __ev64_opaque__, __ev64_opaque__, 1, 1)
 SPE_DIRTY_HELPER_DEFN_ACCrDrA(evaddssiaaw,   __ev64_opaque__, __ev64_opaque__, 1, 1)
 SPE_DIRTY_HELPER_DEFN_ACCrDrA(evaddusiaaw,   __ev64_opaque__, __ev64_opaque__, 1, 1)
 SPE_DIRTY_HELPER_DEFN_rDrArB(evdivws,        __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
 SPE_DIRTY_HELPER_DEFN_rDrArB(evdivwu,        __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+SPE_DIRTY_HELPER_DEFN_rDrArB(brinc,          __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
 
-SPE_DIRTY_HELPER_DEFN_rDrArB(brinc, __ev64_opaque__, __ev64_opaque__, __ev64_opaque__)
+/*---------------------------------------------------------------*/
+/*---                    SPE helpers end.                     ---*/
+/*---------------------------------------------------------------*/
 
 /*----------------------------------------------*/
 /*--- The exported fns ..                    ---*/
diff --git a/VEX/priv/guest_ppc_toIR.c b/VEX/priv/guest_ppc_toIR.c
index f28be19..79b86ae 100644
--- a/VEX/priv/guest_ppc_toIR.c
+++ b/VEX/priv/guest_ppc_toIR.c
@@ -14433,65 +14433,11 @@ static Bool dis_spe_ACC_based_multiply_insns_via_dirty_helpers ( UInt theInstr )
      break;
   case 0x42b:
      // evmhesmfa (Vector Multiply Half Words, Even, Signed, Modulo, Fractional (to Accumulator), SPEPEM p5-166)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhesmfa",
-                            &spe_dirtyhelper_evmhesmfa,
-                            args);
-     DIP( "evmhesmfa r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Write;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhesmfa, Ifx_Write);
      break;
   case 0x42f:
      // evmhosmfa (Vector Multiply Half Words, Odd, Signed, Modulo, Fractional (to Accumulator), SPEPEM p5-166)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhosmfa",
-                            &spe_dirtyhelper_evmhosmfa,
-                            args);
-     DIP( "evmhosmfa r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Write;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhosmfa, Ifx_Write);
      break;
   case 0x403:
      // evmhessf (Vector Multiply Half Words, Even, Signed, Saturate, Fractional, SPEPEM p5-150)
@@ -14503,57 +14449,11 @@ static Bool dis_spe_ACC_based_multiply_insns_via_dirty_helpers ( UInt theInstr )
      break;
   case 0x40b:
      // evmhesmf (Vector Multiply Half Words, Even, Signed, Modulo, Fractional, SPEPEM p5-166)
-     args = mkIRExprVec_3 ( mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhesmf",
-                            &spe_dirtyhelper_evmhesmf,
-                            args);
-     DIP( "evmhesmf r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 3;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Write;
-     d->fxState[0].offset = rD_off;
-     d->fxState[0].size   = 2 * sizeof(UInt);
-     d->fxState[1].fx     = Ifx_Read;
-     d->fxState[1].offset = rA_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rB_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_rDrArB(evmhesmf);
      break;
   case 0x40f:
      // evmhosmf (Vector Multiply Half Words, Odd, Signed, Modulo, Fractional, SPEPEM p5-166)
-     args = mkIRExprVec_3 ( mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhosmf",
-                            &spe_dirtyhelper_evmhosmf,
-                            args);
-     DIP( "evmhosmf r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 3;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Write;
-     d->fxState[0].offset = rD_off;
-     d->fxState[0].size   = 2 * sizeof(UInt);
-     d->fxState[1].fx     = Ifx_Read;
-     d->fxState[1].offset = rA_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rB_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_rDrArB(evmhosmf);
      break;
   case 0x447:
      // evmwhssf (Vector Multiply Word High Signed, Saturate, Fractional, SPEPEM p5-186)
@@ -14561,30 +14461,7 @@ static Bool dis_spe_ACC_based_multiply_insns_via_dirty_helpers ( UInt theInstr )
      break;
   case 0x44f:
      // evmwhsmf (Vector Multiply Word High Signed, Modulo, Fractional, SPEPEM p5-184)
-     args = mkIRExprVec_3 ( mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmwhsmf",
-                            &spe_dirtyhelper_evmwhsmf,
-                            args);
-     DIP( "evmwhsmf r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 3;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Write;
-     d->fxState[0].offset = rD_off;
-     d->fxState[0].size   = 2 * sizeof(UInt);
-     d->fxState[1].fx     = Ifx_Read;
-     d->fxState[1].offset = rA_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rB_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_rDrArB(evmwhsmf);
      break;
   case 0x453:
      // evmwssf (Vector Multiply Word Signed, Saturate, Fractional, SPEPEM p5-205)
@@ -14596,61 +14473,11 @@ static Bool dis_spe_ACC_based_multiply_insns_via_dirty_helpers ( UInt theInstr )
      break;
   case 0x46f:
      // evmwhsmfa (Vector Multiply Word High Signed, Modulo, Fractional (to Accumulator), SPEPEM p5-184)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmwhsmfa",
-                            &spe_dirtyhelper_evmwhsmfa,
-                            args);
-     DIP( "evmwhsmfa r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Write;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmwhsmfa, Ifx_Write);
      break;
   case 0x45b:
      // evmwsmf (Vector Multiply Word Signed, Modulo, Fractional, SPEPEM p5-199)
-     args = mkIRExprVec_3 ( mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmwsmf",
-                            &spe_dirtyhelper_evmwsmf,
-                            args);
-     DIP( "evmwsmf r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 3;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Write;
-     d->fxState[0].offset = rD_off;
-     d->fxState[0].size   = 2 * sizeof(UInt);
-     d->fxState[1].fx     = Ifx_Read;
-     d->fxState[1].offset = rA_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rB_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_rDrArB(evmwsmf);
      break;
   case 0x473:
      // evmwssfa (Vector Multiply Word Signed, Saturate, Fractional (to Accumulator), SPEPEM p5-205)
@@ -14658,34 +14485,7 @@ static Bool dis_spe_ACC_based_multiply_insns_via_dirty_helpers ( UInt theInstr )
      break;
   case 0x47b:
      // evmwsmfa (Vector Multiply Word Signed, Modulo, Fractional (to Accumulator), SPEPEM p5-199)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmwsmfa",
-                            &spe_dirtyhelper_evmwsmfa,
-                            args);
-     DIP( "evmwsmfa r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Write;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmwsmfa, Ifx_Write);
      break;
   case 0x500:
      // evmheusiaaw (Vector Multiply Half Words, Even, Unsigned, Saturate, Integer and Accumulate into Words, SPEPEM p5-158)
@@ -14725,321 +14525,51 @@ static Bool dis_spe_ACC_based_multiply_insns_via_dirty_helpers ( UInt theInstr )
      break;
   case 0x50b:
      // evmhesmfaaw (Vector Multiply Half Words, Even, Signed, Modulo, Fractional and Accumulate into Words, SPEPEM p5-167)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhesmfaaw",
-                            &spe_dirtyhelper_evmhesmfaaw,
-                            args);
-     DIP( "evmhesmfaaw r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhesmfaaw, Ifx_Modify);
      break;
   case 0x50f:
      // evmhosmfaaw (Vector Multiply Half Words, Odd, Signed, Modulo, Fractional and Accumulate into Words, SPEPEM p5-167)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhosmfaaw",
-                            &spe_dirtyhelper_evmhosmfaaw,
-                            args);
-     DIP( "evmhosmfaaw r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhosmfaaw, Ifx_Modify);
      break;
   case 0x528:
      // evmhegumiaa (Vector Multiply Half Words, Even, Guarded, Unsigned, Modulo, Integer
      // and Accumulate, SPEPEM p5-142)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhegumiaa",
-                            &spe_dirtyhelper_evmhegumiaa,
-                            args);
-     DIP( "evmhegumiaa r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhegumiaa, Ifx_Modify);
      break;
   case 0x529:
      // evmhegsmiaa (Vector Multiply Half Words, Even, Guarded, Signed, Modulo, Integer
      // and Accumulate, SPEPEM p5-140)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhegsmiaa",
-                            &spe_dirtyhelper_evmhegsmiaa,
-                            args);
-     DIP( "evmhegsmiaa r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhegsmiaa, Ifx_Modify);
      break;
   case 0x5a8:
      // evmhegumian (Vector Multiply Half Words, Even, Guarded, Unsigned, Modulo, Integer
      // and Accumulate Negative, SPEPEM p5-143)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhegumian",
-                            &spe_dirtyhelper_evmhegumian,
-                            args);
-     DIP( "evmhegumian r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhegumian, Ifx_Modify);
      break;
   case 0x5a9:
      // evmhegsmian (Vector Multiply Half Words, Even, Guarded, Signed, Modulo, Integer
      // and Accumulate Negative, SPEPEM p5-141)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhegsmian",
-                            &spe_dirtyhelper_evmhegsmian,
-                            args);
-     DIP( "evmhegsmian r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhegsmian, Ifx_Modify);
      break;
   case 0x52c:
      // evmhogumiaa (Vector Multiply Half Words, Odd, Guarded, Unsigned, Modulo, Integer
      // and Accumulate, SPEPEM p5-164)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhogumiaa",
-                            &spe_dirtyhelper_evmhogumiaa,
-                            args);
-     DIP( "evmhogumiaa r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhogumiaa, Ifx_Modify);
      break;
   case 0x52d:
      // evmhogsmiaa (Vector Multiply Half Words, Odd, Guarded, Signed, Modulo, Integer
      // and Accumulate, SPEPEM p5-162)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhogsmiaa",
-                            &spe_dirtyhelper_evmhogsmiaa,
-                            args);
-     DIP( "evmhogsmiaa r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhogsmiaa, Ifx_Modify);
      break;
   case 0x5ac:
      // evmhogumian (Vector Multiply Half Words, Odd, Guarded, Unsigned, Modulo, Integer
      // and Accumulate Negative, SPEPEM p5-165)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhogumian",
-                            &spe_dirtyhelper_evmhogumian,
-                            args);
-     DIP( "evmhogumian r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhogumian, Ifx_Modify);
      break;
   case 0x5ad:
      // evmhogsmian (Vector Multiply Half Words, Odd, Guarded, Signed, Modulo, Integer
      // and Accumulate Negative, SPEPEM p5-163)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhogsmian",
-                            &spe_dirtyhelper_evmhogsmian,
-                            args);
-     DIP( "evmhogsmian r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhogsmian, Ifx_Modify);
      break;
   case 0x553:
      // evmwssfaa (Vector Multiply Word Signed, Saturate, Fractional and Accumulate, SPEPEM p5-206)
@@ -15047,34 +14577,7 @@ static Bool dis_spe_ACC_based_multiply_insns_via_dirty_helpers ( UInt theInstr )
      break;
   case 0x55b:
      // evmwsmfaa (Vector Multiply Word Signed, Modulo, Fractional and Accumulate, SPEPEM p5-200)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmwsmfaa",
-                            &spe_dirtyhelper_evmwsmfaa,
-                            args);
-     DIP( "evmwsmfaa r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmwsmfaa, Ifx_Modify);
      break;
   case 0x584:
      // evmhousianw (Vector Multiply Half Words, Odd, Unsigned, Saturate, Integer and Accumulate Negative into Words, SPEPEM p5-182)
@@ -15090,65 +14593,11 @@ static Bool dis_spe_ACC_based_multiply_insns_via_dirty_helpers ( UInt theInstr )
      break;
   case 0x58b:
      // evmhesmfanw (Vector Multiply Half Words, Even, Signed, Modulo, Fractional and Accumulate Negative into Words, SPEPEM p5-168)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhesmfanw",
-                            &spe_dirtyhelper_evmhesmfanw,
-                            args);
-     DIP( "evmhesmfanw r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhesmfanw, Ifx_Modify);
      break;
   case 0x58f:
      // evmhosmfanw (Vector Multiply Half Words, Odd, Signed, Modulo, Fractional and Accumulate Negative into Words, SPEPEM p5-168)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhosmfanw",
-                            &spe_dirtyhelper_evmhosmfanw,
-                            args);
-     DIP( "evmhosmfanw r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhosmfanw, Ifx_Modify);
      break;
   case 0x5d3:
      // evmwssfan (Vector Multiply Word Signed, Saturate, Fractional and Accumulate Negative, SPEPEM p5-207)
@@ -15156,127 +14605,19 @@ static Bool dis_spe_ACC_based_multiply_insns_via_dirty_helpers ( UInt theInstr )
      break;
   case 0x5db:
      // evmwsmfan (Vector Multiply Word Signed, Modulo, Fractional and Accumulate Negative, SPEPEM p5-201)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmwsmfan",
-                            &spe_dirtyhelper_evmwsmfan,
-                            args);
-     DIP( "evmwsmfan r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmwsmfan, Ifx_Modify);
      break;
   case 0x52b:
      // evmhegsmfaa (Vector Multiply Half Words, Even, Guarded, Signed, Modulo, Fractional and Accumulate, SPEPEM p5-138)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhegsmfaa",
-                            &spe_dirtyhelper_evmhegsmfaa,
-                            args);
-     DIP( "evmhegsmfaa r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhegsmfaa, Ifx_Modify);
      break;
   case 0x5ab:
      // evmhegsmfan (Vector Multiply Half Words, Even, Guarded, Signed, Modulo, Fractional and Accumulate Negative, SPEPEM p5-139)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhegsmfan",
-                            &spe_dirtyhelper_evmhegsmfan,
-                            args);
-     DIP( "evmhegsmfan r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhegsmfan, Ifx_Modify);
      break;
   case 0x52f:
      // evmhogsmfaa (Vector Multiply Half Words, Odd, Guarded, Signed, Modulo, Fractional and Accumulate, SPEPEM p5-160)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhogsmfaa",
-                            &spe_dirtyhelper_evmhogsmfaa,
-                            args);
-     DIP( "evmhogsmfaa r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhogsmfaa, Ifx_Modify);
      break;
   case 0x540:
      // evmwlusiaaw (Vector Multiply Word Low Unsigned, Saturate, Integer and Accumulate in Words, SPEPEM p5-197)
@@ -15288,34 +14629,7 @@ static Bool dis_spe_ACC_based_multiply_insns_via_dirty_helpers ( UInt theInstr )
      break;
   case 0x5af:
      // evmhogsmfan (Vector Multiply Half Words, Odd, Guarded, Signed, Modulo, Fractional and Accumulate Negative, SPEPEM p5-161)
-     args = mkIRExprVec_4 ( mkU32( ACC_off ),
-                            mkU32( rD_off ),
-                            mkU32( rA_off ),
-                            mkU32( rB_off ) );
-     d = unsafeIRDirty_0_N (0 /* regparms */,
-                            "spe_dirtyhelper_evmhogsmfan",
-                            &spe_dirtyhelper_evmhogsmfan,
-                            args);
-     DIP( "evmhogsmfan r%d, r%d, r%d\n", rD_addr, rA_addr, rB_addr );
-     /* declare guest state effects */
-     d->needsBBP = True;
-     d->nFxState = 4;
-     vex_bzero(&d->fxState, sizeof(d->fxState));
-     d->fxState[0].fx     = Ifx_Modify;
-     d->fxState[0].offset = ACC_off;
-     d->fxState[0].size   = sizeof(ULong);
-     d->fxState[1].fx     = Ifx_Write;
-     d->fxState[1].offset = rD_off;
-     d->fxState[1].size   = 2 * sizeof(UInt);
-     d->fxState[2].fx     = Ifx_Read;
-     d->fxState[2].offset = rA_off;
-     d->fxState[2].size   = 2 * sizeof(UInt);
-     d->fxState[3].fx     = Ifx_Read;
-     d->fxState[3].offset = rB_off;
-     d->fxState[3].size   = 2 * sizeof(UInt);
-
-     /* execute the dirty call, side-effecting guest state */
-     stmt( IRStmt_Dirty(d) );
+     PREPARE_DIRTY_HELPER_CALL_ACCrDrArB(evmhogsmfan, Ifx_Modify);
      break;
   case 0x5c0:
      // evmwlusianw (Vector Multiply Word Low Unsigned, Saturate, Integer and Accumulate Negative in Words, SPEPEM p5-198)
diff --git a/regtest-power7-64.default-build.log b/regtest-power7-64.default-build.log
index 112b3e7..66e6fa8 100644
--- a/regtest-power7-64.default-build.log
+++ b/regtest-power7-64.default-build.log
@@ -1944,7 +1944,7 @@ badfree-2trace:  valgrind   --num-callers=2 -q ./badfree
 badfree:         valgrind   -q ./badfree 
 badfree3:        valgrind   -q --fullpath-after=/proj/ppc/DT/labhome/anmol/valgrind-3.8.1/ ./badfree 
 badjump:         valgrind   ./badjump 
-sh: line 1: 21368 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck ./badjump > badjump.stdout.out 2> badjump.stderr.out
+sh: line 1: 22326 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck ./badjump > badjump.stdout.out 2> badjump.stderr.out
 badjump2:        valgrind   -q ./badjump2 
 badloop:         valgrind   -q ./badloop 
 badpoll:         valgrind   -q ./badpoll 
@@ -1961,7 +1961,7 @@ clo_redzone_default: valgrind   --leak-check=no -q ./clo_redzone
 custom-overlap:  valgrind   --leak-check=summary -q ./custom-overlap 
 custom_alloc:    valgrind   -q ./custom_alloc 
 deep-backtrace:  valgrind   -q --num-callers=500 ./deep-backtrace 
-sh: line 1: 21930 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --num-callers=500 ./deep-backtrace > deep-backtrace.stdout.out 2> deep-backtrace.stderr.out
+sh: line 1: 22884 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --num-callers=500 ./deep-backtrace > deep-backtrace.stdout.out 2> deep-backtrace.stderr.out
 deep_templates:  valgrind   -q ./deep_templates 
 describe-block:  valgrind   ./describe-block 
 doublefree:      valgrind   -q ./doublefree 
@@ -2073,7 +2073,7 @@ supp-dir:        valgrind   --suppressions=x86/ ./../../tests/true
 supp1:           valgrind   --suppressions=supp.supp -q ./supp1 
 supp2:           valgrind   --suppressions=supp.supp -q ./supp2 
 supp_unknown:    valgrind   -q --suppressions=supp_unknown.supp ./badjump 
-sh: line 1: 26620 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --suppressions=supp_unknown.supp ./badjump > supp_unknown.stdout.out 2> supp_unknown.stderr.out
+sh: line 1: 27578 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --suppressions=supp_unknown.supp ./badjump > supp_unknown.stdout.out 2> supp_unknown.stderr.out
 *** supp_unknown failed (stderr) ***
 suppfree:        valgrind   --suppressions=suppfree.supp -q ./suppfree 
 test-plo-no:     valgrind   -q ./test-plo 
@@ -2210,7 +2210,7 @@ gxx304:          valgrind   ./gxx304
 ifunc:           (skipping, prereq failed: test -e ifunc)
 -- Running  tests in none/tests/linux ----------------------------------
 blockfault:      valgrind   ./blockfault 
-sh: line 1: 31099 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=none ./blockfault > blockfault.stdout.out 2> blockfault.stderr.out
+sh: line 1: 32062 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=none ./blockfault > blockfault.stdout.out 2> blockfault.stderr.out
 mremap:          valgrind   ./mremap 
 mremap2:         valgrind   ./mremap2 
 mremap3:         valgrind   ./mremap3 
@@ -2376,7 +2376,7 @@ tc20_verifywrap: valgrind   --read-var-info=yes ./tc20_verifywrap
 *** tc20_verifywrap failed (stderr) ***
 tc21_pthonce:    valgrind   --read-var-info=yes ./tc21_pthonce 
 tc22_exit_w_lock: valgrind   ./tc22_exit_w_lock 
-sh: line 1: 16278 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=helgrind ./tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
+sh: line 1: 17237 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=helgrind ./tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
 tc23_bogus_condwait: valgrind   ./tc23_bogus_condwait 
 tc24_nonzero_sem: valgrind   --hg-sanity-flags=111111 ./tc24_nonzero_sem 
 -- Finished tests in helgrind/tests ------------------------------------
@@ -2493,7 +2493,7 @@ tc18_semabuse:   valgrind   ./../../helgrind/tests/tc18_semabuse
 tc19_shadowmem:  valgrind   --error-limit=no --read-var-info=yes --show-confl-seg=no --num-callers=3 ./../../helgrind/tests/tc19_shadowmem 
 tc21_pthonce:    valgrind   --num-callers=3 ./../../helgrind/tests/tc21_pthonce 
 tc22_exit_w_lock: valgrind   --num-callers=3 ./../../helgrind/tests/tc22_exit_w_lock 
-sh: line 1: 21622 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=drd --num-callers=3 ./../../helgrind/tests/tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
+sh: line 1: 22579 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=drd --num-callers=3 ./../../helgrind/tests/tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
 tc23_bogus_condwait: valgrind   --num-callers=3 ./../../helgrind/tests/tc23_bogus_condwait 
 tc24_nonzero_sem: valgrind   --read-var-info=yes ./../../helgrind/tests/tc24_nonzero_sem 
 thread_name:     valgrind   --read-var-info=yes --check-stack-var=yes --num-callers=3 ./thread_name 
diff --git a/regtest-power7-64.log b/regtest-power7-64.log
index a2a10a4..d747d1b 100644
--- a/regtest-power7-64.log
+++ b/regtest-power7-64.log
@@ -1944,7 +1944,7 @@ badfree-2trace:  valgrind   --num-callers=2 -q ./badfree
 badfree:         valgrind   -q ./badfree 
 badfree3:        valgrind   -q --fullpath-after=/proj/ppc/DT/labhome/anmol/valgrind-3.8.1/ ./badfree 
 badjump:         valgrind   ./badjump 
-sh: line 1:  7068 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck ./badjump > badjump.stdout.out 2> badjump.stderr.out
+sh: line 1: 26346 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck ./badjump > badjump.stdout.out 2> badjump.stderr.out
 badjump2:        valgrind   -q ./badjump2 
 badloop:         valgrind   -q ./badloop 
 badpoll:         valgrind   -q ./badpoll 
@@ -1961,7 +1961,7 @@ clo_redzone_default: valgrind   --leak-check=no -q ./clo_redzone
 custom-overlap:  valgrind   --leak-check=summary -q ./custom-overlap 
 custom_alloc:    valgrind   -q ./custom_alloc 
 deep-backtrace:  valgrind   -q --num-callers=500 ./deep-backtrace 
-sh: line 1: 29193 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --num-callers=500 ./deep-backtrace > deep-backtrace.stdout.out 2> deep-backtrace.stderr.out
+sh: line 1: 26904 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --num-callers=500 ./deep-backtrace > deep-backtrace.stdout.out 2> deep-backtrace.stderr.out
 deep_templates:  valgrind   -q ./deep_templates 
 describe-block:  valgrind   ./describe-block 
 doublefree:      valgrind   -q ./doublefree 
@@ -2074,7 +2074,7 @@ supp-dir:        valgrind   --suppressions=x86/ ./../../tests/true
 supp1:           valgrind   --suppressions=supp.supp -q ./supp1 
 supp2:           valgrind   --suppressions=supp.supp -q ./supp2 
 supp_unknown:    valgrind   -q --suppressions=supp_unknown.supp ./badjump 
-sh: line 1: 25709 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --suppressions=supp_unknown.supp ./badjump > supp_unknown.stdout.out 2> supp_unknown.stderr.out
+sh: line 1: 31596 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=memcheck -q --suppressions=supp_unknown.supp ./badjump > supp_unknown.stdout.out 2> supp_unknown.stderr.out
 *** supp_unknown failed (stderr) ***
 suppfree:        valgrind   --suppressions=suppfree.supp -q ./suppfree 
 test-plo-no:     valgrind   -q ./test-plo 
@@ -2210,7 +2210,7 @@ gxx304:          valgrind   ./gxx304
 ifunc:           (skipping, prereq failed: test -e ifunc)
 -- Running  tests in none/tests/linux ----------------------------------
 blockfault:      valgrind   ./blockfault 
-sh: line 1:  8371 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=none ./blockfault > blockfault.stdout.out 2> blockfault.stderr.out
+sh: line 1:  3749 Segmentation fault      (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=none ./blockfault > blockfault.stdout.out 2> blockfault.stderr.out
 mremap:          valgrind   ./mremap 
 mremap2:         valgrind   ./mremap2 
 mremap3:         valgrind   ./mremap3 
@@ -2376,7 +2376,7 @@ tc20_verifywrap: valgrind   --read-var-info=yes ./tc20_verifywrap
 *** tc20_verifywrap failed (stderr) ***
 tc21_pthonce:    valgrind   --read-var-info=yes ./tc21_pthonce 
 tc22_exit_w_lock: valgrind   ./tc22_exit_w_lock 
-sh: line 1: 31694 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=helgrind ./tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
+sh: line 1: 21244 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=helgrind ./tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
 tc23_bogus_condwait: valgrind   ./tc23_bogus_condwait 
 tc24_nonzero_sem: valgrind   --hg-sanity-flags=111111 ./tc24_nonzero_sem 
 -- Finished tests in helgrind/tests ------------------------------------
@@ -2495,7 +2495,7 @@ tc18_semabuse:   valgrind   ./../../helgrind/tests/tc18_semabuse
 tc19_shadowmem:  valgrind   --error-limit=no --read-var-info=yes --show-confl-seg=no --num-callers=3 ./../../helgrind/tests/tc19_shadowmem 
 tc21_pthonce:    valgrind   --num-callers=3 ./../../helgrind/tests/tc21_pthonce 
 tc22_exit_w_lock: valgrind   --num-callers=3 ./../../helgrind/tests/tc22_exit_w_lock 
-sh: line 1: 25715 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=drd --num-callers=3 ./../../helgrind/tests/tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
+sh: line 1: 26605 Aborted                 (core dumped) VALGRIND_LIB=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place VALGRIND_LIB_INNER=/proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/.in_place /proj/.ppc_DT_labhome/labhome/anmol/valgrind-3.8.1/./coregrind/valgrind --command-line-only=yes --memcheck:leak-check=no --tool=drd --num-callers=3 ./../../helgrind/tests/tc22_exit_w_lock > tc22_exit_w_lock.stdout.out 2> tc22_exit_w_lock.stderr.out
 tc23_bogus_condwait: valgrind   --num-callers=3 ./../../helgrind/tests/tc23_bogus_condwait 
 tc24_nonzero_sem: valgrind   --read-var-info=yes ./../../helgrind/tests/tc24_nonzero_sem 
 thread_name:     valgrind   --read-var-info=yes --check-stack-var=yes --num-callers=3 ./thread_name 
-- 
1.7.3.4

